<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Untitled Document</title>
<script type="text/javascript">
       var M={};
	   M.FFT1=function(dataArr){
		   var size = dataArr.length,count=0,W=[];
		    for(var i = 0; i < size; i ++){
                    W[i] = this.exp(-2 * Math.PI * i / size);
                }
			butterflyCal();
			return dataArr;
			//蝶形运算单元
			  function butterflyCal(){
                    count ++;
                    var singleLength = size / Math.pow(2,count);
                    var everyLength = size / singleLength;
                    for(var i = 0; i < singleLength; i ++){
                        singleButterflyCal(i * everyLength, (i + 1) * everyLength - 1, count);
                    }
                    if(singleLength > 1){
                        butterflyCal();
                    }else{
                    }
                }
			//一个蝶形单元 n运算次数 蝶形单元的成对间隔
			function singleButterflyCal(start, end, n){

                    var delta =  Math.pow(2,n - 1);

                    for(var i = start, j = 0; i <= (end - delta); i ++){

                        //i 的运算对
                        var pairI = i + delta;

                        //计算i运算时的权重下标
                        var currWeightForI = j * size / Math.pow(2,n);

                        //计算i的运算对时候的权重
                        var currWeightForPairI = currWeightForI + size / 4;

                        if(!(dataArr[i] instanceof M.C)) dataArr[i] = new M.C(dataArr[i]);

                        if(!(dataArr[pairI] instanceof M.C)) dataArr[pairI] = new M.C(dataArr[pairI]);

                        var currResultForI = dataArr[i].plus(dataArr[pairI].mutiply(W[currWeightForI]));
                        var currResultForPairI = dataArr[i].plus(dataArr[pairI].mutiply(W[currWeightForPairI]));

                        dataArr[i] = currResultForI;
                        dataArr[pairI] = currResultForPairI;

                        j++;
                    }
                }
		   }
		   M.Matrix=function(arr,arg,arg2){
			   var resultArr = [];
			   if(arg){
				    if(isNaN(arg)){
						var m = /(\d+)\s*\*/.exec(arg)[1];
                        var n = /\*\s*(\d+)/.exec(arg)[1];
						}
					else{
						m = arg;
                        n = arg2;
						}
					  if(arr[0] && arr[0][0]){
                        for(var i = 0;i < m;i ++){
                            resultArr[i] = [];
                            for(var j = 0;j < n;j ++){
                                resultArr[i][j] = arr[i][j] || 0;
                            }
                        }
                    }
					else{
						for(var i = 0;i < m;i ++){
                            resultArr[i] = [];
                            for(var j = 0;j < n;j ++){
                                var t = i * n + j;
                                resultArr[i][j] = arr[i * n + j] || 0;
                            }
                        }
						}
					this.m = m;
                    this.n = n;
				   }
				   else{
					 this.m = arr.length;
                     this.n = arr[0].length;
					   }
				this.data = resultArr;
			   }
	    M.C=function(r,i){
			 this.r = r || 0;//实部
             this.i = i || 0;//虚部
			}
		M.exp=function(theta,r){
			theta = theta || 0,r = r || 1;
			var tempC = new M.C();
                tempC.r = r * Math.cos(theta);
                tempC.i = r * Math.sin(theta);
				return tempC;
			}
		M.lagrange=function(xArr,yArr){
			//Lagrange插值
			 var num = xArr.length;
			  function getLk(x,k){//计算lk
                    var omigaXk = 1;
                    var omigaX = 1;
                    for(var i = 0;i < num;i ++){
                        if(i != k){
                            omigaXk *= xArr[k] - xArr[i];
                            omigaX *= x - xArr[i];
                        }
                    }
                    var lk = omigaX / omigaXk;
                    return lk;
                }
			var getY = function(x){
                    var L = 0;
                    for(var k = 0;k < num;k ++){
                        var lk = getLk(x,k);
                        L += yArr[k] * lk;

                    }
                    return L;
                }
			return getY;
			}
		M.applyMatrix=function(imgData,matrixArr,low){
			//对图象信号实行掩模算子变换 low为阈值,滤波运算
			low = low || 0,data = imgData.data,width = imgData.width,height = imgData.height, matrixSize = matrixArr.length,template = new M.Matrix(matrixArr,matrixSize,1),tempData = [],start = -(Math.sqrt(matrixSize) - 1) / 2,pixelArr = [[],[],[]];
			for(var i = 0,n = data.length;i < n;i += 4){
				var ii = i / 4,row = parseInt(ii / width),col = ii % width;
				 if(row == 0 || col == 0) continue;
				  for(var k = start;k <= -start;k ++){
					  var currRow = row + k;
					   for(var kk = start;kk <= -start;kk ++){
						   var currCol = col + kk,currI = (currRow * width + currCol) * 4;
						   for(var j = 0;j < 3;j ++){
                                var tempI = currI + j; 
                                pixelArr[j].push(data[tempI]);
                            }
						   }
					  }
					  var pixelMatrix = new M.Matrix(pixelArr,3,matrixSize),resultMatrix = pixelMatrix.mutiply(template);
					 for(var j = 0;j < 3;j ++){
                       tempData[i + j] = resultMatrix.data[j]; 
                    }
				 tempData[i + 4] = data[i + 4];
				}
			 for(var i = 0,n = data.length;i < n;i ++){
                    if(tempData[i]){
                        data[i] = tempData[i] < low ? tempData[i] : data[i];
                    }
                }
			return imgData;
			}
		M.RGBToHSI=function(R,G,B){
			var theta = ((R - G + R - B) / 2) / Math.sqrt((R - G) * (R - G) + (R - B) * (G - B)) || 0,theta = Math.acos(theta),H = B > G ? (2 * Math.PI - theta) : theta;
			 if(R + G + B > 0){
                    var S = 1 - 3 * Math.min(R,G,B) / (R + G + B);
                }else{
                    var S = 0;
                }
			 var I = (R + G + B) / 3;
			 if(H > 2 * Math.PI) H = 2 * Math.PI;
                if(H < 0) H = 0;
				return {
                    H: H,
                    S: S,
                    I: I
                };
			}
		M.HSIToRGB=function(H,S,I){
			 if(H < 0){
                    H %= 2 * Math.PI;
                    H += 2 * Math.PI
                }else{
                    H %= 2 * Math.PI;
                }
			 if(H <= Math.PI * 2 / 3){
                    var B = I * (1 - S);
                    var R = I * (1 + S * Math.cos(H) / Math.cos(Math.PI / 3 - H));
                    var G = 3 * I - (R + B);

                }else if(H <= Math.PI * 4 / 3){
                    H = H - Math.PI * 2 / 3;

                    var R = I * (1 - S);
                    var G = I * (1 + S * Math.cos(H) / Math.cos(Math.PI / 3 - H));
                    var B = 3 * I - (G + R);

                }else{
                    H = H - Math.PI * 4 / 3;

                    var G = I * (1 - S);
                    var B = I * (1 + S * Math.cos(H) / Math.cos(Math.PI / 3 - H));
                    var R = 3 * I - (G + B);

                }
			    return {
                    R: R,
                    G: G,
                    B: B
                };
			}
		M.applyInHSI=function(imgData, func){
			var colorMap = ["R", "Y", "G", "C", "B", "M"],data = imgData.data,d30 = Math.PI / 6,d60 = Math.PI / 3;
			for(var i = 0, n = data.length; i < n; i += 4){
				var hsiObj = this.RGBToHSI(data[i], data[i + 1], data[i + 2]),h = hsiObj.H + d30,color = ~~ (h / d60),rColor = colorMap[color % 6];
				func(hsiObj, rColor, data[i + 3]);
				if(hsiObj.S > 1) hsiObj.S = 1;
                    if(hsiObj.S < 0) hsiObj.S = 0;
				}
				 var rgbObj = this.HSIToRGB(hsiObj.H,hsiObj.S,hsiObj.I);
				 data[i] = rgbObj.R;
                    data[i + 1] = rgbObj.G;
                    data[i + 2] = rgbObj.B;
			}
		M.distance=function(p1, p2){
			 p2 = p2 || [0, 0];
			 p1 = new M.C(p1[0], p1[1]);
             p2 = new M.C(p2[0], p2[1]);
			 var p3 = p1.minus(p2);
             return p3.distance();
			}
		M.xyToIFun=function(width){
			return function(x, y, z){
                    z = z || 0;
                    return (y * width + x) * 4 + z;
                };
			}
		M.xyCal=function(imgData, x, y, rgbFun, aFun){
			 var xyToIFun  = this.xyToIFun(imgData.width),j  = xyToIFun(x, y, 0),data = imgData.data,processedData = rgbFun(data[j], data[j + 1], data[j + 2]);
			 if(processedData){
                    data[j] = processedData[0];
                    data[j + 1] = processedData[1];
                    data[j + 2] = processedData[2];
                }
			if(aFun){
                    data[j + 3] = aFun(data[j + 3]);
                }
			}
		var p= M.Matrix.prototype;
		p.plus=function(matrix){
			if(this.m != matrix.m || this.n != matrix.n){
                    throw new Error("矩阵加法行列不匹配");
                }
			 var tempM = new M.Matrix([],this.m,this.n);
			 for(var i = 0;i < this.m;i ++){
                   for(var j = 0;j < this.n;j ++){
                        tempM.data[i][j] = this.data[i][j] + matrix.data[i][j];
                   }
                }
                return tempM;
			}
		p.minus=function(matrix){
			if(this.m != matrix.m || this.n != matrix.n){
                    throw new Error("矩阵减法法行列不匹配");
                }
			 var tempM = new M.Matrix([],this.m,this.n);
			 for(var i = 0;i < this.m;i ++){
                   for(var j = 0;j < this.n;j ++){
                        tempM.data[i][j] = this.data[i][j] - matrix.data[i][j];
                   }
                }
                return tempM;
			}
		p.mutiply=function(matrix){
			if(this.n != matrix.m){
                    throw new Error("矩阵乘法行列不匹配");
                }
			 var tempM = new M.Matrix([],this.m,matrix.n);
			 for(var i = 0;i < this.m;i ++){
                   for(var j = 0;j < matrix.n;j ++){

                        var sum = 0;
                        for(var ii = 0;ii < this.n;ii ++){
                            sum += this.data[i][ii] * matrix.data[ii][j];
                        }
                        tempM.data[i][j] = sum;
                   }
                }
                return tempM;
			}
		var p=M.C.prototype;
		p.plus=function(c){
			var tempC = new M.C();
                tempC.r = this.r + c.r;
                tempC.i = this.i + c.i;
                return tempC;
			}
		p.minus=function(c){
			var tempC = new M.C();
                tempC.r = this.r - c.r;
                tempC.i = this.i - c.i;
			 return tempC;
			}
		p.mutiply=function(c){
			var tempC = new M.C();
                tempC.r = this.r * c.r - this.i * c.i;
                tempC.i = this.r * c.i + this.i * c.r;
				return tempC;
			}
		p.divide=function(c){
			var tempC = new M.C();
			var m = c.mutiply(c.conjugated());
                var f = this.mutiply(c.conjugated());
                tempC.r = f.r / m.r;
                tempC.i = f.i / m.r;
			return tempC;
			}
		p.conjugated=function(){
			 var tempC = new M.C(this.r,-this.i);
                return tempC;
			}
		p.distance=function(){
			return Math.sqrt(this.r * this.r + this.i * this.i);
			}
       var newFilter={};
	   //add
	   newFilter.add=function(lowerData, upperData, method, alpha, dx, dy, isFast, channel){
		    //isFast用于快速，适用于中间处理
			var l = lowerData.data,u = upperData.data,dx = dx || 0,dy = dy || 0,alpha = alpha || 1,isFast = isFast || false,channel = channel || "RGB";
			 if(!(/[RGB]+/.test(channel))){
                    channel = "RGB";
                }
			var channelString = channel.replace("R","0").replace("G","1").replace("B","2"),jump = 1,result, width = lowerData.width,height = lowerData.height,upperLength = u.length,upperWidth = upperData.width, upperHeight = upperData.height,indexOfArr = [
                        channelString.indexOf("0") > -1,
                        channelString.indexOf("1") > -1,
                        channelString.indexOf("2") > -1
                    ],everyJump = 4 * jump;
					 var ii, row, col, uRow, uCol, uIi, uI;
					 var xMin, yMin, xMax, yMax;
					 var uXMin = dx;
                var uXMax = dx + upperWidth;
                var uYMin = dy;
                var uYMax = dy + upperHeight;
				if(uXMin > width){
                    return;
                }else if(uXMin < 0){
                    uXMin = 0;
                }

                if(uXMax < 0){
                    return;
                }else if(uXMax > width){
                    uXMax = width;
                }

                if(uYMin > height){
                    return;
                }else if(uYMin < 0){
                    uYMin = 0;
                }

                if(uYMax < 0){
                    return;
                }else if(uYMax > height){
                    uYMax = height;
                }
				 var currRow, upperY, upperRow;
				 for(var y = uYMin; y < uYMax; y ++){
					currRow = y * width;
                    upperY = y - dy;
                    upperRow = upperY * upperWidth;
					 for(var x = uXMin; x < uXMax; x ++){
						  var upperX = x - dx;
						  var i = (currRow + x) * 4;
						  var uI = (upperRow + upperX) * 4;
						   for(var j = 0; j < 3; j ++){
							   if(u[uI + 3] == 0) break;
							   else l[i + 3] = u[uI + 3];
							   switch(method){
                                case "颜色减淡" :
                                    if(indexOfArr[j]){
                                       result = l[i + j] + (l[i + j] * u[uI + j]) / (255 - u[uI + j]);
                                       l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "变暗":
                                    if(indexOfArr[j]){
                                        result = l[i + j] < u[uI + j] ? l[i + j] : u[uI + j];
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "变亮":
                                    if(indexOfArr[j]){
                                        result = l[i + j] > u[uI + j] ? l[i + j] : u[uI + j];
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "正片叠底":
                                    if(indexOfArr[j]){
                                        result = ~~((l[i + j] * u[uI + j]) / 255);
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "滤色" :
                                    if(indexOfArr[j]){
                                        result = ~~(255 - (255 - l[i + j]) * (255 - u[uI + j]) / 255);
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "叠加":
                                    if(indexOfArr[j]){
                                        if(l[i + j] <= 127.5){
                                            result = l[i + j] * u[uI + j] / 127.5;
                                        }else{
                                            result = 255 - (255 - l[i + j]) * (255 - u[uI + j]) / 127.5;
                                        }
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "强光":
                                    if(indexOfArr[j]){
                                        if(u[uI + j] <= 127.5){
                                            result = l[i + j] * u[uI + j] / 127.5;
                                        }else{
                                            result = l[i + j] + (255 - l[i + j]) * (u[uI + j] - 127.5) / 127.5;
                                        }
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "差值":
                                    if(indexOfArr[j]){
                                        result = l[i + j] > u[uI + j] ? l[i + j] - u[uI + j] : u[uI + j] - l[i + j];
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "排除":
                                    if(indexOfArr[j]){
                                        result = l[i + j] + u[uI + j] - (l[i + j] * u[uI + j]) / 127.5;
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "点光":
                                    if(indexOfArr[j]){
                                        if(l[i + j] < (2 * u[uI + j] - 255)){
                                            result = 2 * u[uI + j] - 255;
                                        }else if(l[i + j] < 2 * u[uI + j]){
                                            result = l[i + j];
                                        }else{
                                            result = 2 * u[uI + j];    
                                        }
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "颜色加深":
                                    if(indexOfArr[j]){
                                        result = 255 - 255 * (255 - l[i + j]) / u[uI + j];
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "线性加深":
                                    if(indexOfArr[j]){
                                        var tempR = l[i + j] + u[uI + j];
                                        result = tempR > 255 ? tempR - 255 : 0;
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "线性减淡":
                                    if(indexOfArr[j]){
                                        var tempR = l[i + j] + u[uI + j];
                                        result = tempR > 255 ? 255 : tempR;
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "柔光":
                                    if(indexOfArr[j]){
                                        if(u[uI + j] < 127.5){
                                            result = ((2 * u[uI + j] - 255) * (255 - l[i + j]) / (255 * 255) + 1) * l[i + j];
                                        }else{
                                            result = (2 * u[uI + j] - 255) * (Math.sqrt(l[i + j] / 255) - l[i + j] / 255) + l[i + j];
                                        }
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "亮光":
                                    if(indexOfArr[j]){
                                        if(u[uI + j] < 127.5){
                                            result = (1 - (255 - l[i + j]) / (2 * u[uI + j])) * 255;
                                        }else{
                                            result = l[i + j] / (2 * (1 - u[uI + j] / 255));
                                        }
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "线性光":
                                    if(indexOfArr[j]){
                                        var tempR = l[i + j] + 2 * u[uI + j] - 255;
                                        result = tempR > 255 ? 255 : tempR;
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                case "实色混合":
                                    if(indexOfArr[j]){
                                        if(u[uI + j] < (255 - l[i + j])){
                                            result = 0;
                                        }else{
                                            result = 255;
                                        }
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                                    break;

                                default: 
                                    if(indexOfArr[j]){
                                        result = u[uI + j];
                                        l[i + j] = (1 - alpha) * l[i + j] + (alpha) * result;
                                    }
                            }//end switch
							   }
						 }
					 }
					return lowerData;
		   }
	   //腐蚀 
	   newFilter.corrode=function(imgData,arg){
		   if(imgData&&imgData.data){
			   var data=imgData.data,width=imgData.width,height=imgData.height,R = parseInt(arg[0]) || 3;
			   for(var x=0;x<width;x++){
				   for(var y=0;y<height;y++){
					    var randomI = parseInt(Math.random() * R * 2) - R,randomJ = parseInt(Math.random() * R * 2) - R,realI = y * width + x,realJ = (y + randomI) * width + x + randomJ;
                        for(var j = 0; j < 3; j ++){
                            data[realI * 4 + j] = data[realJ * 4 + j];
                        }
					   }
				   }
			   }
		   }
		// 暗角
		newFilter.darkCorner=function(imgData,arg){
			//R暗角级别 分1-10级
			 var R = parseInt(arg[0]) || 3,type = arg[2] || "round",lastLevel = arg[1] || 30,data = imgData.data,width = imgData.width,height = imgData.height,xLength = R * 2 + 1,middleX = width * 2 / 3,middleY = height * 1/ 2,maxDistance = M.distance([middleX ,middleY]),startDistance = maxDistance * (1 - R / 10);
			 var f = function(x, p0, p1, p2, p3){
                 //基于三次贝塞尔曲线 
                     return p0 * Math.pow((1 - x), 3) + 3 * p1 * x * Math.pow((1 - x), 2) + 3 * p2 * x * x * (1 - x) + p3 * Math.pow(x, 3);
               }
			 function calDark(x, y, p){
                    //计算距中心点距离
                    var distance = M.distance([x, y], [middleX, middleY]);
                    var currBilv = (distance - startDistance) / (maxDistance - startDistance);
                    if(currBilv < 0) currBilv = 0;
                    //应该增加暗度
                    return  f(currBilv, 0, 0.02, 0.3, 1) * p * lastLevel / 255;
                }
			 for(var x = 0; x < width; x ++){
                    for(var y = 0; y < height; y ++){  
                        var realI = y * width + x;
                        for(var j = 0;j < 3;j ++){
                            var dDarkness = calDark(x, y, data[realI * 4 + j]);
                            data[realI * 4 + j] -= dDarkness;
                        }
                    }
                }
			return imgData;
			}
		//马赛克 
		newFilter.dotted=function(imgData,arg){
			var R = parseInt(arg[0]) || 1,r = parseInt(arg[1]) || 1,data = imgData.data,width = imgData.width,height = imgData.height,xLength = R * 2 + 1,disTmlMatrix=[];
			var r2 = r * r;
                for(var x = -R; x < R; x ++){

                    for(var y = -R; y < R; y ++){
                        if((x * x + y * y) > r2){
                            disTmlMatrix.push([x, y]);
                        }
                    }

                }
			var xyToIFun = M.xyToIFun(width);
			 for(var x = 0, n = parseInt(width / xLength); x < n; x ++){

                    for(var y = 0, m = parseInt(height / xLength); y < m;y ++){
                        var middleX = parseInt((x + 0.5) * xLength);
                        var middleY = parseInt((y + 0.5) * xLength);
                        for(var i = 0; i < disTmlMatrix.length; i ++){
                            var dotX = middleX + disTmlMatrix[i][0];
                            var dotY = middleY + disTmlMatrix[i][1];
                            //data[(dotY * width + dotX) * 4 + 3] = 0;
                            data[xyToIFun(dotX, dotY, 3)] = 225;
                            data[xyToIFun(dotX, dotY, 2)] = 225;
                            data[xyToIFun(dotX, dotY, 0)] = 225;
                            data[xyToIFun(dotX, dotY, 1)] = 225;
                        }
                    }
                }
				return imgData;
			}
		//浮雕效果
		newFilter.embossment=function(imgData,arg){
			var data = imgData.data,width = imgData.width,height = imgData.height,outData = [];
			for(var i = 0,n = data.length;i < n;i += 4){
				 var ii = i / 4,row = parseInt(ii / width),col = ii % width,A = ((row - 1) *  width + (col - 1)) * 4,G = (row + 1) * width * 4 + (col + 1) * 4;
				 if(row == 0 || col == 0) continue;
				 for(var j = 0;j < 3;j ++){
                        outData[i + j] = data[A + j] - data[G + j] + 127.5;
                    }
				outData[i + 4] = data[i + 4];
				}
			for(var i = 0,n = data.length;i < n;i ++){
                    data[i] = outData[i] || data[i];
                }
			 return imgData;
			}
		//高斯模糊
	   newFilter.gaussBlur=function(imgData,radius, sigma){
		   var pixes = imgData.data,width = imgData.width, height = imgData.height,gaussMatrix = [],gaussSum = 0, x, y,r, g, b, a,i, j, k, len,radius = Math.floor(radius) || 3,sigma = sigma || radius / 3,a = 1 / (Math.sqrt(2 * Math.PI) * sigma),b = -1 / (2 * sigma * sigma);
		    for (i = 0, x = -radius; x <= radius; x++, i++){
				g = a * Math.exp(b * x * x);
                    gaussMatrix[i] = g;
                    gaussSum += g;
				}
			for (i = 0, len = gaussMatrix.length; i < len; i++) {
                    gaussMatrix[i] /= gaussSum;
                }
			for (y = 0; y < height; y++) {
                    for (x = 0; x < width; x++) {
                        r = g = b = a = 0;
                        gaussSum = 0;
                        for(j = -radius; j <= radius; j++){
                            k = x + j;
                            if(k >= 0 && k < width){//确保 k 没超出 x 的范围
                                //r,g,b,a 四个一组
                                i = (y * width + k) * 4;
                                r += pixes[i] * gaussMatrix[j + radius];
                                g += pixes[i + 1] * gaussMatrix[j + radius];
                                b += pixes[i + 2] * gaussMatrix[j + radius];
                                // a += pixes[i + 3] * gaussMatrix[j];
                                gaussSum += gaussMatrix[j + radius];
                            }
                        }
                        i = (y * width + x) * 4;
                        // 除以 gaussSum 是为了消除处于边缘的像素, 高斯运算不足的问题
                        // console.log(gaussSum)
                        pixes[i] = r / gaussSum;
                        pixes[i + 1] = g / gaussSum;
                        pixes[i + 2] = b / gaussSum;
                        // pixes[i + 3] = a ;
                    }
                }
			 for (x = 0; x < width; x++) {
                    for (y = 0; y < height; y++) {
                        r = g = b = a = 0;
                        gaussSum = 0;
                        for(j = -radius; j <= radius; j++){
                            k = y + j;
                            if(k >= 0 && k < height){//确保 k 没超出 y 的范围
                                i = (k * width + x) * 4;
                                r += pixes[i] * gaussMatrix[j + radius];
                                g += pixes[i + 1] * gaussMatrix[j + radius];
                                b += pixes[i + 2] * gaussMatrix[j + radius];
                                // a += pixes[i + 3] * gaussMatrix[j];
                                gaussSum += gaussMatrix[j + radius];
                            }
                        }
                        i = (y * width + x) * 4;
                        pixes[i] = r / gaussSum;
                        pixes[i + 1] = g / gaussSum;
                        pixes[i + 2] = b / gaussSum;
                    }
                }
			imgData.data = pixes;
			return imgData;
		   }
		//灰度扩展
		newFilter.ImageEnhance=function(imgData,arg1,arg2){
			var lamta = arg || 0.5,data = imgData.data,width = imgData.width,height = imgData.height,p1 = arg1 || {x: 10,y: 10},p2 = arg2 || {x: 50,y: 40};
			function transfer(d){
                }
                for(var i = 0,n = data.length;i < n;i += 4){    
                }
                imgData.data = data;
                return imgData;
			}
		newFilter.borderline=function(imgData,arg){
			var template1 = [
                    -2,-4,-4,-4,-2,
                    -4,0,8,0,-4,
                    -4,8,24,8,-4,
                    -4,0,8,0,-4,
                    -2,-4,-4,-4,-2
                ];
			var template2 = [
                        0,		1,		0,
						1,		-4,		1,
						0,		1,		0
                ];
            var template3 = [
                ];
			return M.applyMatrix(imgData,template2,250);
			}
		//马赛克
	   newFilter.mosaic=function(imgData,arg){
		   var R = parseInt(arg[0]) || 3,data = imgData.data,width = imgData.width,height = imgData.height,xLength = R * 2 + 1;
		   for(var x = 0,n = parseInt(width / xLength);x < n;x ++){
			    for(var y = 0,m = parseInt(height / xLength);y < m;y ++){
					var average = [],sum = [0,0,0];
					for(var i = 0;i < xLength;i ++){
						  for(var j = 0;j < xLength;j ++){
                                var realI = (y * xLength + i) * width + x * xLength + j;
                                sum[0] += data[realI * 4];
                                sum[1] += data[realI * 4 + 1];
                                sum[2] += data[realI * 4 + 2];
                            }
						}
					 average[0] = sum[0] / (xLength * xLength);
                     average[1] = sum[1] / (xLength * xLength);
                     average[2] = sum[2] / (xLength * xLength);
					  for(var i = 0;i < xLength;i ++){
						  for(var j = 0;j < xLength;j ++){
							 var realI = (y * xLength + i) * width + x * xLength + j;
                                data[realI * 4] = average[0];
                                data[realI * 4 + 1] = average[1];
                                data[realI * 4 + 2] = average[2];
							  }
						  }
					}
			   }
			   return imgData;
		   }
		 //添加杂色
		  newFilter.noise=function(imgData,arg){
			  var R = parseInt(arg[0]) || 100,data = imgData.data,width = imgData.width,height = imgData.height,xLength = R * 2 + 1;
			   for(var x = 0;x < width;x ++){
				   for(var y = 0;y < height;y ++){
					   var realI = y * width + x;
                        for(var j = 0;j < 3;j ++){
                            var rand = parseInt(Math.random() * R * 2) - R;
                            data[realI * 4 + j] += rand;
                        }
					   }
				   }
				  return imgData;
			  }
			//油画
			newFilter.oilPainting=function(imgData,arg){
				var R = parseInt(arg[0]) || 16,data = imgData.data,width = imgData.width,height = imgData.height,xLength = R * 2 + 1;
				 for(var x = 0;x < width;x ++){
					 for(var y = 0;y < height;y ++){
						 var realI = y * width + x,gray = 0;
						 for(var j = 0;j < 3;j ++){
                            gray += data[realI * 4 + j];
                        }
						gray = gray / 3,every = parseInt(gray / R) * R;
						for(var j = 0;j < 3;j ++){
                            data[realI * 4 + j] = every;
                        }
						 }
					 }
					return imgData;
				}
			//色调分离
			newFilter.posterize=function(imgData,arg){
				var data = imgData.data,width = imgData.width,height = imgData.height,step = args[0] || 20;
				step = step < 1 ? 1 : (step > 255 ? 255 : step);
				var level = Math.floor(255 / step);
				 for(var x = 0; x < width; x ++){
					 for(var y = 0; y < height; y ++){
						 M.xyCal(imgData, x, y, function(r, g, b){
                            return [
                                Math.floor(r / level) * level,
                                Math.floor(g / level) * level,
                                Math.floor(b / level) * level
                            ];
                        });
						 }
					 }
					 return imgData;
				}
			//棕褐色
			newFilter.sepia=function(imgData){
				var data = imgData.data,width = imgData.width,height = imgData.height;
				 for(var x = 0; x < width; x ++){
					 for(var y = 0; y < height; y ++){
						 M.xyCal(imgData, x, y, function(r, g, b){
                            return [
                                r * 0.393 + g * 0.769 + b * 0.189,
                                r * 0.349 + g * 0.686 + b * 0.168,
                                r * 0.272 + g * 0.534 + b * 0.131
                            ];
                        });
						 }
					 }
					return imgData;
				}
			//锐化
			newFilter.sharp=function(imgData,arg){
				var lamta = arg[0] || 0.6,data = imgData.data,width = imgData.width,height = imgData.height
				for(var i = 0,n = data.length;i < n;i += 4){
					 var ii = i / 4,row = parseInt(ii / width),col = ii % width;
					 if(row == 0 || col == 0) continue;
					 var A = ((row - 1) *  width + (col - 1)) * 4,B = ((row - 1) * width + col) * 4,E = (ii - 1) * 4;
					 for(var j = 0;j < 3;j ++){
						var delta = data[i + j] - (data[B + j] + data[E + j] + data[A + j]) / 3;
                        data[i + j] += delta * lamta;
						 }
					}
				 return imgData;
				}
			//灰度处理
			newFilter.toGray=function(imgData){
				 var data = imgData.data;
				 for(var i = 0,n = data.length;i < n;i += 4){
                    var gray = parseInt((0.299 * data[i] + 0.578 * data[i + 1] + 0.114 * data[i + 2]));
                    data[i + 2] = data[i + 1] = data[i] = gray;
                }
                imgData.data = data;
				return imgData;
				}
			//反色
			newFilter.toReverse=function(imgData){
				var data = imgData.data;
				for(var i = 0,n = data.length;i < n;i += 4){
                    data[i] = 255 - data[i];
                    data[i + 1] = 255 - data[i + 1];
                    data[i + 2] = 255 - data[i + 2];
                }
				imgData.data = data;
				return imgData;
				}
			//灰度阈值
			newFilter.toThresh=function(imgData){
				imgData=newFilter.toGray(imgData);
				 var data = imgData.data,arg = arg[0] || 128;
				 for(var i = 0,n = data.length;i < n;i ++){
					  if((i + 1) % 4){
                        data[i] = data[i] > arg ? 255 : 0;
                    }
				}
				imgData.data = data;
				return imgData;
				}
		//查找边缘
		newFilter.applyMatrix=function(imgData,arg){
			var lamta = arg || 0.6,data = imgData.data,width = imgData.width,height = imgData.height,template = new M.Matrix([
                        -2,-4,-4,-4,-2,
                        -4,0,8,0,-4,
                        -4,8,24,8,-4,
                        -4,0,8,0,-4,
                        -2,-4,-4,-4,-2
                    ],25,1),tempData = [];
					for(var i = 0, n = data.length; i < n; i += 4){
						var ii = i / 4,row = parseInt(ii / width),col = ii % width;
						if(row == 0 || col == 0) continue;
						var pixelArr = [[],[],[]];
						for(var k = -2; k < 3; k ++){
							var currRow = row + k;
							 for(var kk = -2; kk < 3; kk ++){
								 var currCol = col + kk,currI = (currRow * width + currCol) * 4;
								 for(var j = 0; j < 3; j ++){
                                var tempI = currI + j; 
                                pixelArr[j].push(data[tempI]);
                            }
								 }
							}
						var pixelMatrix = new M.Matrix(pixelArr, 3, 25),resultMatrix = pixelMatrix.mutiply(template);
						  for(var j = 0; j < 3; j ++){
                       tempData[i + j] = resultMatrix.data[j]; 
                    }
					tempData[i + 4] = data[i + 4];
						}
					for(var i = 0, n = data.length; i < n; i ++){
                    data[i] = tempData[i] || data[i];
                }
				return imgData;
			}
		//调整亮度对比度
		newFilter.brightness=function(imgData,args){
			var data = imgData.data,brightness = args[0] / 50,arg2 = args[1] || 0,c = arg2 / 50,k = Math.tan((45 + 44 * c) * Math.PI / 180);
			 for(var i = 0,n = data.length;i < n;i += 4){
				 for(var j = 0;j < 3;j ++){
                        data[i + j] = (data[i + j] - 127.5 * (1 - brightness)) * k + 127.5 * (1 + brightness);
                    }
				 }
				return imgData;
			}
		//曲线
		newFilter.curve=function(imgData,arg){
			var f = M.lagrange(arg[0], arg[1]),data = imgData.data,width = imgData.width,height = imgData.height;
			 var channel = arg[2];
                if(!(/[RGB]+/.test(channel))){
                    channel = "RGB";
                }
			var channelString = channel.replace("R","0").replace("G","1").replace("B","2");
			var indexOfArr = [
                    channelString.indexOf("0") > -1,
                    channelString.indexOf("1") > -1,
                    channelString.indexOf("2") > -1
                ];
			for(var x = 0; x < width; x ++){
				for(var y = 0; y < height; y ++){
					var realI = y * width + x;
					for(var j = 0; j < 3; j ++){
                            if(! indexOfArr[j]) continue;
                            data[realI * 4 + j] = f(data[realI * 4 + j]);
                        }
					}
				}
			return imgData;
			}
		//gamma调节
		newFilter.gamma=function(imgData,arg){
			var data = imgData.data,width = imgData.width,height = imgData.height;
			var gamma;
			if(args[0] == undefined) gamma = 10;
			else gamma = args[0];
			var normalizedArg = ((gamma + 100) / 200) * 2;
			for(var x = 0; x < width; x ++){
				for(var y = 0; y < height; y ++){
					M.xyCal(imgData, x, y, function(r, g, b){
                            return [
                                Math.pow(r, normalizedArg),
                                Math.pow(g, normalizedArg),
                                Math.pow(b, normalizedArg)
                            ];
                        });
					}
				}
			 return imgData;
			}
		//可选颜色
		newFilter.selectiveColor=function(imgData,arg){
			  var color = arg[0];
			  var C = arg[1];
                var M = arg[2];
                var Y = arg[3];
                var K = arg[4];
				var isRelative = arg[5] || 0;
		  var maxColorMap = {
                    red: "R",
                    green: "G",
                    blue: "B",
                    "红色": "R",
                    "绿色": "G",
                    "蓝色": "B"
                };
		  var minColorMap = {
                    cyan: "R",
                    magenta: "G",
                    yellow: "B",
                    "青色": "R",
                    "洋红": "G",
                    "黄色": "B"
                };
		  var checkSelectedColor = function(colorObj){
                    if(maxColorMap[color]){
                        return Math.max(colorObj.R, colorObj.G, colorObj.B) == colorObj[maxColorMap[color]];
                    }else if(minColorMap[color]){
                        return Math.min(colorObj.R, colorObj.G, colorObj.B) == colorObj[minColorMap[color]];
                    }else if(color == "black" || color == "黑色"){
                        return Math.min(colorObj.R, colorObj.G, colorObj.B) < 128;
                    }else if(color == "white" || color == "白色"){
                        return Math.max(colorObj.R, colorObj.G, colorObj.B) > 128;
                    }else if(color == "中性色"){
                        return ! ((Math.max(colorObj.R, colorObj.G, colorObj.B) < 1) || (Math.min(colorObj.R, colorObj.G, colorObj.B) > 224));
                    }
                };
			    var upLimit = 0;
                var lowLimit = 0;
                var limit = 0;
				var alterNum = [C, M, Y, K];
				 for(var x = 0, w = imgData.width; x < w; x ++){
					  for(var y = 0, h = imgData.height; y < h; y ++){
						  M.xyCal(imgData, x, y, function(R, G, B){
                            var colorObj = {
                                R: R,
                                G: G,
                                B: B
                            };

                            var colorArr = [R, G, B];
                            var resultArr =[];

                            if(checkSelectedColor(colorObj)){
                                if(maxColorMap[color]){
                                    var maxColor = maxColorMap[color];

                                    var middleValue = R + G + B - Math.max(R, G, B) - Math.min(R, G, B);
                                    limit = colorObj[maxColor] - middleValue;
                                }else if(minColorMap[color]){
                                    var minColor = minColorMap[color];

                                    var middleValue = R + G + B - Math.max(R, G, B) - Math.min(R, G, B);
                                    limit = middleValue - colorObj[minColor]  ;
                                }else if(color == "black" || color == "黑色"){
                                    limit = parseInt(127.5 - Math.max(R, G, B)) * 2;
                                }else if(color == "white" || color == "白色"){
                                    limit = parseInt(Math.min(R, G, B) - 127.5) * 2;
                                }else if(color == "中性色"){
                                    limit = 255 - (Math.abs(Math.max(R, G, B) - 127.5) + Math.abs(Math.min(R, G, B) - 127.5));
                                }else{
                                    return;
                                }

                                for(var i = 0; i < 3; i ++){
                                    //可减少到的量
                                    var lowLimitDelta = parseInt(limit * (colorArr[i] / 255));
                                    var lowLimit = colorArr[i] - lowLimitDelta;

                                    //可增加到的量
                                    var upLimitDelta =  parseInt(limit * (1 - colorArr[i] / 255));
                                    var upLimit = colorArr[i] + upLimitDelta;

                                    //将黑色算进去 得到影响百分比因子
                                    var factor = (alterNum[i] + K + alterNum[i] * K);

                                    //相对调节
                                    if(isRelative){
                                        //如果分量大于128  减少量=增加量
                                        if(colorArr[i] > 128){
                                            lowLimitDelta = upLimitDelta;
                                        }

                                        //先算出黑色导致的原始增量
                                        if(K > 0){
                                            var realUpLimit = colorArr[i] - K * lowLimitDelta; 
                                        }else{
                                            var realUpLimit = colorArr[i] - K * upLimitDelta; 
                                        }

                                        //标准化
                                        if(realUpLimit > upLimit) realUpLimit = upLimit;
                                        if(realUpLimit < lowLimit) realUpLimit = lowLimit;

                                        upLimitDelta = upLimit - realUpLimit;
                                        lowLimitDelta = realUpLimit - lowLimit;

                                        if(K < 0){
                                            lowLimitDelta = upLimitDelta;
                                        }else{
                                        }

                                        //> 0表明在减少
                                        if(alterNum[i] > 0){
                                            realUpLimit -= alterNum[i] * lowLimitDelta; 
                                        }else{
                                            realUpLimit -= alterNum[i] * upLimitDelta; 
                                        }


                                    }else{

                                        //现在量
                                        var realUpLimit = limit * - factor + colorArr[i];

                                    }

                                    if(realUpLimit > upLimit) realUpLimit = upLimit;
                                    if(realUpLimit < lowLimit) realUpLimit = lowLimit;
                                    
                                    resultArr[i] = realUpLimit;
                                }

                                return resultArr;
                            }
                        });
						  }
					 }
					return imgData;
		}
		//调整RGB 饱和和度 
		newFilter.setHSI=function(imgData,arg){
			arg[0] = arg[0] / 180 * Math.PI;
			arg[1] = arg[1] / 100 || 0;
			arg[2] = arg[2] / 100 * 255 || 0;
			arg[3] = arg[3] || false;//着色
			var channel = arg[4];
			if(!(/[RGBCMY]+/.test(channel))){
                    channel = "RGBCMY";
                }
			var letters = channel.split("");
			var indexOf = {};
			 for(var i = 0; i < letters.length; i ++){
                    indexOf[letters[i]] = 1;
                }
			M.applyInHSI(imgData,function(i, color){
                    if(! indexOf[color]) return;

                    if(arg[3]){
                        i.H = arg[0];
                        i.S = arg[1];
                        i.I += arg[2];
                    }else{
                        i.H += arg[0];
                        i.S += arg[1];
                        i.I += arg[2];
                    }

                });
				 return imgData;
			} 
       var Filters={};
       Filters.Grayscale = function(imageData) {
        var data = imageData.data,
            len = data.length,
            i, brightness;

        for(i = 0; i < len; i += 4) {
            brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
            // red
            data[i] = brightness;
            // green
            data[i + 1] = brightness;
            // blue
            data[i + 2] = brightness;
        }
    };
	 Filters.Brighten = function(imageData) {
        var brightness = this.brightness() * 255,
            data = imageData.data,
            len = data.length,
            i;

        for(i = 0; i < len; i += 4) {
            // red
            data[i] += brightness;
            // green
            data[i + 1] += brightness;
            // blue
            data[i + 2] += brightness;
        }
    };
    Filters.Invert = function(imageData) {
        var data = imageData.data,
            len = data.length,
            i;

        for(i = 0; i < len; i += 4) {
            // red
            data[i] = 255 - data[i];
            // green
            data[i + 1] = 255 - data[i + 1];
            // blue
            data[i + 2] = 255 - data[i + 2];
        }
    };
	 function BlurStack() {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null;
    }

    var mul_table = [
        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259
    ];

    var shg_table = [
        9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
        17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
        19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
        20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
    ];
    function filterGaussBlurRGBA( imageData, radius) {

        var pixels = imageData.data,
            width = imageData.width,
            height = imageData.height;

        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
            r_out_sum, g_out_sum, b_out_sum, a_out_sum,
            r_in_sum, g_in_sum, b_in_sum, a_in_sum,
            pr, pg, pb, pa, rbs;

        var div = radius + radius + 1,
            widthMinus1  = width - 1,
            heightMinus1 = height - 1,
            radiusPlus1  = radius + 1,
            sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2,
            stackStart = new BlurStack(),
            stackEnd = null,
            stack = stackStart,
            stackIn = null,
            stackOut = null,
            mul_sum = mul_table[radius],
            shg_sum = shg_table[radius];

        for ( i = 1; i < div; i++ ) {
            stack = stack.next = new BlurStack();
            if ( i == radiusPlus1 ){
                stackEnd = stack;
            }
        }

        stack.next = stackStart;

        yw = yi = 0;

        for ( y = 0; y < height; y++ )
        {
            r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

            r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
            g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
            b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
            a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;

            stack = stackStart;

            for( i = 0; i < radiusPlus1; i++ )
            {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }

            for( i = 1; i < radiusPlus1; i++ )
            {
                p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
                r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
                g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
                b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
                a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;

                stack = stack.next;
            }


            stackIn = stackStart;
            stackOut = stackEnd;
            for ( x = 0; x < width; x++ )
            {
                pixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;
                if ( pa !== 0 )
                {
                    pa = 255 / pa;
                    pixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;
                    pixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                    pixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
                } else {
                    pixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;
                }

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;

                p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;

                r_in_sum += ( stackIn.r = pixels[p]);
                g_in_sum += ( stackIn.g = pixels[p+1]);
                b_in_sum += ( stackIn.b = pixels[p+2]);
                a_in_sum += ( stackIn.a = pixels[p+3]);

                r_sum += r_in_sum;
                g_sum += g_in_sum;
                b_sum += b_in_sum;
                a_sum += a_in_sum;

                stackIn = stackIn.next;

                r_out_sum += ( pr = stackOut.r );
                g_out_sum += ( pg = stackOut.g );
                b_out_sum += ( pb = stackOut.b );
                a_out_sum += ( pa = stackOut.a );

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;

                stackOut = stackOut.next;

                yi += 4;
            }
            yw += width;
        }


        for ( x = 0; x < width; x++ )
        {
            g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

            yi = x << 2;
            r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
            g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
            b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
            a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;

            stack = stackStart;

            for( i = 0; i < radiusPlus1; i++ )
            {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }

            yp = width;

            for( i = 1; i <= radius; i++ )
            {
                yi = ( yp + x ) << 2;

                r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
                g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
                b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
                a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;

                stack = stack.next;

                if( i < heightMinus1 )
                {
                    yp += width;
                }
            }

            yi = x;
            stackIn = stackStart;
            stackOut = stackEnd;
            for ( y = 0; y < height; y++ )
            {
                p = yi << 2;
                pixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;
                if ( pa > 0 )
                {
                    pa = 255 / pa;
                    pixels[p]   = ((r_sum * mul_sum) >> shg_sum ) * pa;
                    pixels[p+1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
                    pixels[p+2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
                } else {
                    pixels[p] = pixels[p+1] = pixels[p+2] = 0;
                }

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;

                p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;

                r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
                g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
                b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
                a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));

                stackIn = stackIn.next;

                r_out_sum += ( pr = stackOut.r );
                g_out_sum += ( pg = stackOut.g );
                b_out_sum += ( pb = stackOut.b );
                a_out_sum += ( pa = stackOut.a );

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;

                stackOut = stackOut.next;

                yi += width;
            }
        }
    }
	Filters.Blur = function Blur(imageData) {
        var radius = Math.round(this.blurRadius());

        if (radius > 0) {
            filterGaussBlurRGBAi(mageData, radius);
        }
    }
   function pixelAt(idata, x, y) {
		var idx = (y * idata.width + x) * 4;
		var d = [];
		d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
		return d;
	}
	function rgbDistance(p1, p2) {
		return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
	}
	function rgbMean(pTab) {
		var m = [0, 0, 0];

		for (var i = 0; i < pTab.length; i++) {
			m[0] += pTab[i][0];
			m[1] += pTab[i][1];
			m[2] += pTab[i][2];
		}

		m[0] /= pTab.length;
		m[1] /= pTab.length;
		m[2] /= pTab.length;

		return m;
	}
    function backgroundMask(idata, threshold) {
		var rgbv_no = pixelAt(idata, 0, 0);
		var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
		var rgbv_so = pixelAt(idata, 0, idata.height - 1);
		var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);


		var thres = threshold || 10;
		if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {

			// Mean color
			var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);

			// Mask based on color distance
			var mask = [];
			for (var i = 0; i < idata.width * idata.height; i++) {
				var d = rgbDistance(mean, [idata.data[i * 4], idata.data[i * 4 + 1], idata.data[i * 4 + 2]]);
				mask[i] = (d < thres) ? 0 : 255;
			}

			return mask;
		}
	}
	function applyMask(idata, mask) {
		for (var i = 0; i < idata.width * idata.height; i++) {
			idata.data[4 * i + 3] = mask[i];
		}
	}
	function erodeMask(mask, sw, sh) {

		var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = (a === 255 * 8) ? 255 : 0;
			}
		}

		return maskResult;
	}
	function dilateMask(mask, sw, sh) {

		var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = (a >= 255 * 4) ? 255 : 0;
			}
		}

		return maskResult;
	}
	function smoothEdgeMask(mask, sw, sh) {

		var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = a;
			}
		}

		return maskResult;
	}
	Filters.Mask = function(imageData) {
		// Detect pixels close to the background color
		var threshold = this.threshold(),
        mask = backgroundMask(imageData, threshold);
		if (mask) {
			// Erode
			mask = erodeMask(mask, imageData.width, imageData.height);

			// Dilate
			mask = dilateMask(mask, imageData.width, imageData.height);

			// Gradient
			mask = smoothEdgeMask(mask, imageData.width, imageData.height);

			// Apply mask
			applyMask(imageData, mask);
			
			// todo : Update hit region function according to mask
		}

		return imageData;
	};
	Filters.RGB = function (imageData) {	
        var data = imageData.data,
            nPixels = data.length,
            red = this.red(),
            green = this.green(),
            blue = this.blue(),
            i, brightness;

        for (i = 0; i < nPixels; i += 4) {
            brightness = (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2])/255;
            data[i    ] = brightness*red; // r
            data[i + 1] = brightness*green; // g
            data[i + 2] = brightness*blue; // b
            data[i + 3] = data[i + 3]; // alpha
        }
    };
	Filters.HSV = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            v = Math.pow(2,this.value()),
            s = Math.pow(2,this.saturation()),
            h = Math.abs((this.hue()) + 360) % 360,
            i;

        // Basis for the technique used:
        // http://beesbuzz.biz/code/hsv_color_transforms.php
        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
        // H is the hue shift in degrees (0 to 360)
        // vsu = V*S*cos(H*PI/180);
        // vsw = V*S*sin(H*PI/180);
        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

        // Precompute the values in the matrix:
        var vsu = v*s*Math.cos(h*Math.PI/180),
            vsw = v*s*Math.sin(h*Math.PI/180);
        // (result spot)(source spot)
        var rr = 0.299*v+0.701*vsu+0.167*vsw,
            rg = 0.587*v-0.587*vsu+0.330*vsw,
            rb = 0.114*v-0.114*vsu-0.497*vsw;
        var gr = 0.299*v-0.299*vsu-0.328*vsw,
            gg = 0.587*v+0.413*vsu+0.035*vsw,
            gb = 0.114*v-0.114*vsu+0.293*vsw;
        var br = 0.299*v-0.300*vsu+1.250*vsw,
            bg = 0.587*v-0.586*vsu-1.050*vsw,
            bb = 0.114*v+0.886*vsu-0.200*vsw;

        var r,g,b,a;

        for (i = 0; i < nPixels; i += 4) {
            r = data[i+0];
            g = data[i+1];
            b = data[i+2];
            a = data[i+3];

            data[i+0] = rr*r + rg*g + rb*b;
            data[i+1] = gr*r + gg*g + gb*b;
            data[i+2] = br*r + bg*g + bb*b;
            data[i+3] = a; // alpha
        }

    };
	Filters.HSL = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            v = 1,
            s = Math.pow(2,this.saturation()),
            h = Math.abs((this.hue()) + 360) % 360,
            l = this.luminance()*127,
            i;

        // Basis for the technique used:
        // http://beesbuzz.biz/code/hsv_color_transforms.php
        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
        // H is the hue shift in degrees (0 to 360)
        // vsu = V*S*cos(H*PI/180);
        // vsw = V*S*sin(H*PI/180);
        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

        // Precompute the values in the matrix:
        var vsu = v*s*Math.cos(h*Math.PI/180),
            vsw = v*s*Math.sin(h*Math.PI/180);
        // (result spot)(source spot)
        var rr = 0.299*v+0.701*vsu+0.167*vsw,
            rg = 0.587*v-0.587*vsu+0.330*vsw,
            rb = 0.114*v-0.114*vsu-0.497*vsw;
        var gr = 0.299*v-0.299*vsu-0.328*vsw,
            gg = 0.587*v+0.413*vsu+0.035*vsw,
            gb = 0.114*v-0.114*vsu+0.293*vsw;
        var br = 0.299*v-0.300*vsu+1.250*vsw,
            bg = 0.587*v-0.586*vsu-1.050*vsw,
            bb = 0.114*v+0.886*vsu-0.200*vsw;

        var r,g,b,a;

        for (i = 0; i < nPixels; i += 4) {
            r = data[i+0];
            g = data[i+1];
            b = data[i+2];
            a = data[i+3];

            data[i+0] = rr*r + rg*g + rb*b + l;
            data[i+1] = gr*r + gg*g + gb*b + l;
            data[i+2] = br*r + bg*g + bb*b + l;
            data[i+3] = a; // alpha
        }
    };
	Filters.Emboss = function (imageData,strength,greyLevel,direction,blend) {

        // pixastic strength is between 0 and 10.  I want it between 0 and 1
        // pixastic greyLevel is between 0 and 255.  I want it between 0 and 1.  Also,
        // a max value of greyLevel yields a white emboss, and the min value yields a black
        // emboss.  Therefore, I changed greyLevel to whiteLevel
        var strength = (strength||.5) * 10,
            greyLevel = (greyLevel||.5) * 255,
            direction =direction||('top-left'),
            blend = blend||true,
            dirY = 0,
            dirX = 0,
            data = imageData.data,
            w = imageData.width,
            h = imageData.height,
            w4 = w*4,
            y = h;

        switch (direction) {
            case 'top-left':
                dirY = -1;
                dirX = -1;
                break;
            case 'top':
                dirY = -1;
                dirX = 0;
                break;
            case 'top-right':
                dirY = -1;
                dirX = 1;
                break;
            case 'right':
                dirY = 0;
                dirX = 1;
                break;
            case 'bottom-right':
                dirY = 1;
                dirX = 1;
                break;
            case 'bottom':
                dirY = 1;
                dirX = 0;
                break;
            case 'bottom-left':
                dirY = 1;
                dirX = -1;
                break;
            case 'left':
                dirY = 0;
                dirX = -1;
                break;
        }

        do {
            var offsetY = (y-1)*w4;

            var otherY = dirY;
            if (y + otherY < 1){
                otherY = 0;
            }
            if (y + otherY > h) {
                otherY = 0;
            }

            var offsetYOther = (y-1+otherY)*w*4;

            var x = w;
            do {
                var offset = offsetY + (x-1)*4;

                var otherX = dirX;
                if (x + otherX < 1){
                    otherX = 0;
                }
                if (x + otherX > w) {
                    otherX = 0;
                }

                var offsetOther = offsetYOther + (x-1+otherX)*4;

                var dR = data[offset] - data[offsetOther];
                var dG = data[offset+1] - data[offsetOther+1];
                var dB = data[offset+2] - data[offsetOther+2];

                var dif = dR;
                var absDif = dif > 0 ? dif : -dif;

                var absG = dG > 0 ? dG : -dG;
                var absB = dB > 0 ? dB : -dB;

                if (absG > absDif) {
                    dif = dG;
                }
                if (absB > absDif) {
                    dif = dB;
                }

                dif *= strength;

                if (blend) {
                    var r = data[offset] + dif;
                    var g = data[offset+1] + dif;
                    var b = data[offset+2] + dif;

                    data[offset] = (r > 255) ? 255 : (r < 0 ? 0 : r);
                    data[offset+1] = (g > 255) ? 255 : (g < 0 ? 0 : g);
                    data[offset+2] = (b > 255) ? 255 : (b < 0 ? 0 : b);
                } else {
                    var grey = greyLevel - dif;
                    if (grey < 0) {
                        grey = 0;
                    } else if (grey > 255) {
                        grey = 255;
                    }

                    data[offset] = data[offset+1] = data[offset+2] = grey;
                }

            } while (--x);
        } while (--y);
    };
	 function remap(fromValue, fromMin, fromMax, toMin, toMax) {
        // Compute the range of the data
        var fromRange = fromMax - fromMin,
          toRange = toMax - toMin,
          toValue;

        // If either range is 0, then the value can only be mapped to 1 value
        if (fromRange === 0) {
            return toMin + toRange / 2;
        }
        if (toRange === 0) {
            return toMin;
        }

        // (1) untranslate, (2) unscale, (3) rescale, (4) retranslate
        toValue = (fromValue - fromMin) / fromRange;
        toValue = (toRange * toValue) + toMin;

        return toValue;
    }
	Filters.Enhance = function (imageData) {
        var data = imageData.data,
            nSubPixels = data.length,
            rMin = data[0], rMax = rMin, r,
            gMin = data[1], gMax = gMin, g,
            bMin = data[2], bMax = bMin, b,
            aMin = data[3], aMax = aMin,
            i;

        // If we are not enhancing anything - don't do any computation
        var enhanceAmount = this.enhance();
        if( enhanceAmount === 0 ){ return; }

        // 1st Pass - find the min and max for each channel:
        for (i = 0; i < nSubPixels; i += 4) {
            r = data[i + 0];
            if (r < rMin) { rMin = r; }
            else if (r > rMax) { rMax = r; }
            g = data[i + 1];
            if (g < gMin) { gMin = g; } else
            if (g > gMax) { gMax = g; }
            b = data[i + 2];
            if (b < bMin) { bMin = b; } else
            if (b > bMax) { bMax = b; }
            //a = data[i + 3];
            //if (a < aMin) { aMin = a; } else
            //if (a > aMax) { aMax = a; }
        }

        // If there is only 1 level - don't remap
        if( rMax === rMin ){ rMax = 255; rMin = 0; }
        if( gMax === gMin ){ gMax = 255; gMin = 0; }
        if( bMax === bMin ){ bMax = 255; bMin = 0; }
        if( aMax === aMin ){ aMax = 255; aMin = 0; }

        var rMid, rGoalMax,rGoalMin,
            gMid, gGoalMax,gGoalMin,
            bMid, bGoalMax,aGoalMin,
            aMid, aGoalMax,bGoalMin;

        // If the enhancement is positive - stretch the histogram 
        if ( enhanceAmount > 0 ){
            rGoalMax = rMax + enhanceAmount*(255-rMax);
            rGoalMin = rMin - enhanceAmount*(rMin-0);
            gGoalMax = gMax + enhanceAmount*(255-gMax);
            gGoalMin = gMin - enhanceAmount*(gMin-0);
            bGoalMax = bMax + enhanceAmount*(255-bMax);
            bGoalMin = bMin - enhanceAmount*(bMin-0);
            aGoalMax = aMax + enhanceAmount*(255-aMax);
            aGoalMin = aMin - enhanceAmount*(aMin-0);
        // If the enhancement is negative - compress the histogram
        } else {
            rMid = (rMax + rMin)*0.5;
            rGoalMax = rMax + enhanceAmount*(rMax-rMid);
            rGoalMin = rMin + enhanceAmount*(rMin-rMid);
            gMid = (gMax + gMin)*0.5;
            gGoalMax = gMax + enhanceAmount*(gMax-gMid);
            gGoalMin = gMin + enhanceAmount*(gMin-gMid);
            bMid = (bMax + bMin)*0.5;
            bGoalMax = bMax + enhanceAmount*(bMax-bMid);
            bGoalMin = bMin + enhanceAmount*(bMin-bMid);
            aMid = (aMax + aMin)*0.5;
            aGoalMax = aMax + enhanceAmount*(aMax-aMid);
            aGoalMin = aMin + enhanceAmount*(aMin-aMid);
        }

        // Pass 2 - remap everything, except the alpha
        for (i = 0; i < nSubPixels; i += 4) {
            data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
            data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
            data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
            //data[i + 3] = remap(data[i + 3], aMin, aMax, aGoalMin, aGoalMax);
        }
    };
	Filters.Posterize = function (imageData) {
        // level must be between 1 and 255
        var levels = Math.round(this.levels() * 254) + 1,
            data = imageData.data,
            len = data.length,
            scale = (255 / levels),
            i;

        for (i = 0; i < len; i += 1) {
            data[i] = Math.floor(data[i] / scale) * scale;
        }
    };
	Filters.Noise = function (imageData) {
        var amount = this.noise() * 255,
            data = imageData.data,
            nPixels = data.length,
            half = amount / 2,
            i;

        for (i = 0; i < nPixels; i += 4) {
            data[i + 0] += half - 2 * half * Math.random();
            data[i + 1] += half - 2 * half * Math.random();
            data[i + 2] += half - 2 * half * Math.random();
        }
    };
	Filters.Pixelate = function (imageData) {

        var pixelSize = Math.ceil(this.pixelSize()),
            width = imageData.width,
            height = imageData.height,
            x, y, i,
            //pixelsPerBin = pixelSize * pixelSize,
            red, green, blue, alpha,
            nBinsX = Math.ceil(width / pixelSize),
            nBinsY = Math.ceil(height / pixelSize),
            xBinStart, xBinEnd, yBinStart, yBinEnd,
            xBin, yBin, pixelsInBin;
        imageData = imageData.data;

        for (xBin = 0; xBin < nBinsX; xBin += 1) {
            for (yBin = 0; yBin < nBinsY; yBin += 1) {
        
                // Initialize the color accumlators to 0
                red = 0;
                green = 0;
                blue = 0;
                alpha = 0;

                // Determine which pixels are included in this bin
                xBinStart = xBin * pixelSize;
                xBinEnd = xBinStart + pixelSize;
                yBinStart = yBin * pixelSize;
                yBinEnd = yBinStart + pixelSize;

                // Add all of the pixels to this bin!
                pixelsInBin = 0;
                for (x = xBinStart; x < xBinEnd; x += 1) {
                    if( x >= width ){ continue; }
                    for (y = yBinStart; y < yBinEnd; y += 1) {
                        if( y >= height ){ continue; }
                        i = (width * y + x) * 4;
                        red += imageData[i + 0];
                        green += imageData[i + 1];
                        blue += imageData[i + 2];
                        alpha += imageData[i + 3];
                        pixelsInBin += 1;
                    }
                }

                // Make sure the channels are between 0-255
                red = red / pixelsInBin;
                green = green / pixelsInBin;
                blue = blue / pixelsInBin;

                // Draw this bin
                for (x = xBinStart; x < xBinEnd; x += 1) {
                    if( x >= width ){ continue; }
                    for (y = yBinStart; y < yBinEnd; y += 1) {
                        if( y >= height ){ continue; }
                        i = (width * y + x) * 4;
                        imageData[i + 0] = red;
                        imageData[i + 1] = green;
                        imageData[i + 2] = blue;
                        imageData[i + 3] = alpha;
                    }
                }
            }
        }
      
    };
	Filters.Threshold = function (imageData) {
        var level = this.threshold() * 255,
            data = imageData.data,
            len = data.length,
            i;

        for (i = 0; i < len; i += 1) {
            data[i] = data[i] < level ? 0 : 255;
        }
    };
	Filters.Sepia = function (imageData) {
        var data = imageData.data,
            w = imageData.width,
            y = imageData.height,
            w4 = w*4,
            offsetY, x, offset, or, og, ob, r, g, b;
        
        do {
            offsetY = (y-1)*w4;
            x = w;
            do {
                offset = offsetY + (x-1)*4;
                
                or = data[offset];
                og = data[offset+1];
                ob = data[offset+2];

                r = or * 0.393 + og * 0.769 + ob * 0.189;
                g = or * 0.349 + og * 0.686 + ob * 0.168;
                b = or * 0.272 + og * 0.534 + ob * 0.131;

                data[offset] = r > 255 ? 255 : r;
                data[offset+1] = g > 255 ? 255 : g;
                data[offset+2] = b > 255 ? 255 : b;
                data[offset+3] = data[offset+3];
            } while (--x);
        } while (--y);
    };
	Filters.Solarize = function (imageData) {
        var data = imageData.data,
            w = imageData.width,
            h = imageData.height,
            w4 = w*4,
            y = h;

        do {
            var offsetY = (y-1)*w4;
            var x = w;
            do {
                var offset = offsetY + (x-1)*4;
                var r = data[offset];
                var g = data[offset+1];
                var b = data[offset+2];

                if (r > 127) {
                    r = 255 - r;
                }
                if (g > 127) {
                    g = 255 - g;
                }
                if (b > 127) {
                    b = 255 - b;
                }

                data[offset] = r;
                data[offset+1] = g;
                data[offset+2] = b;
            } while (--x);
        } while (--y);
    };
	var ToPolar = function(src,dst,opt){

        var srcPixels = src.data,
            dstPixels = dst.data,
            xSize = src.width,
            ySize = src.height,
            xMid = opt.polarCenterX || xSize/2,
            yMid = opt.polarCenterY || ySize/2,
            i, x, y, r=0,g=0,b=0,a=0;

        // Find the largest radius
        var rad, rMax = Math.sqrt( xMid*xMid + yMid*yMid );
        x = xSize - xMid;
        y = ySize - yMid;
        rad = Math.sqrt( x*x + y*y );
        rMax = (rad > rMax)?rad:rMax;

        // We'll be uisng y as the radius, and x as the angle (theta=t)
        var rSize = ySize,
            tSize = xSize,
            radius, theta;

        // We want to cover all angles (0-360) and we need to convert to
        // radians (*PI/180)
        var conversion = 360/tSize*Math.PI/180, sin, cos;

        // var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;

        for( theta=0; theta<tSize; theta+=1 ){
            sin = Math.sin(theta*conversion);
            cos = Math.cos(theta*conversion);
            for( radius=0; radius<rSize; radius+=1 ){
                x = Math.floor(xMid+rMax*radius/rSize*cos);
                y = Math.floor(yMid+rMax*radius/rSize*sin);
                i = (y*xSize + x)*4;
                r = srcPixels[i+0];
                g = srcPixels[i+1];
                b = srcPixels[i+2];
                a = srcPixels[i+3];

                // Store it
                //i = (theta * xSize + radius) * 4;
                i = (theta + radius*xSize) * 4;
                dstPixels[i+0] = r;
                dstPixels[i+1] = g;
                dstPixels[i+2] = b;
                dstPixels[i+3] = a;

            }
        }
    };
	 var FromPolar = function(src,dst,opt){

        var srcPixels = src.data,
            dstPixels = dst.data,
            xSize = src.width,
            ySize = src.height,
            xMid = opt.polarCenterX || xSize/2,
            yMid = opt.polarCenterY || ySize/2,
            i, x, y, dx, dy, r=0,g=0,b=0,a=0;


        // Find the largest radius
        var rad, rMax = Math.sqrt( xMid*xMid + yMid*yMid );
        x = xSize - xMid;
        y = ySize - yMid;
        rad = Math.sqrt( x*x + y*y );
        rMax = (rad > rMax)?rad:rMax;

        // We'll be uisng x as the radius, and y as the angle (theta=t)
        var rSize = ySize,
        tSize = xSize,
        radius, theta,
        phaseShift = opt.polarRotation || 0;

        // We need to convert to degrees and we need to make sure
        // it's between (0-360)
        // var conversion = tSize/360*180/Math.PI;
        //var conversion = tSize/360*180/Math.PI;

        var x1, y1;

        for( x=0; x<xSize; x+=1 ){
            for( y=0; y<ySize; y+=1 ){
                dx = x - xMid;
                dy = y - yMid;
                radius = Math.sqrt(dx*dx + dy*dy)*rSize/rMax;
                theta = (Math.atan2(dy,dx)*180/Math.PI + 360 + phaseShift)%360;
                theta = theta*tSize/360;
                x1 = Math.floor(theta);
                y1 = Math.floor(radius);
                i = (y1*xSize + x1)*4;
                r = srcPixels[i+0];
                g = srcPixels[i+1];
                b = srcPixels[i+2];
                a = srcPixels[i+3];

                // Store it
                i = (y*xSize + x)*4;
                dstPixels[i+0] = r;
                dstPixels[i+1] = g;
                dstPixels[i+2] = b;
                dstPixels[i+3] = a;
            }
        }

    };
	var Effects = (function() {

    function defaultOptions(options, defaults) {
        var O = {};
        for (var opt in defaults) {
            if (typeof options[opt] == "undefined") {
                O[opt] = defaults[opt];
            } else {
                O[opt] = options[opt];
            }
        }
        return O;
    }

    function clamp(val, min, max) {
        return Math.min(max, Math.max(min, val));
    }

    function convolve3x3(inData, outData, width, height, kernel, progress, alpha, invert, mono) {
        var idx, r, g, b, a,
            pyc, pyp, pyn,
            pxc, pxp, pxn,
            x, y,
            
            prog, lastProg = 0,
            n = width * height * 4,
            
            k00 = kernel[0][0], k01 = kernel[0][1], k02 = kernel[0][2],
            k10 = kernel[1][0], k11 = kernel[1][1], k12 = kernel[1][2],
            k20 = kernel[2][0], k21 = kernel[2][1], k22 = kernel[2][2],
            
            p00, p01, p02,
            p10, p11, p12,
            p20, p21, p22;
            
        for (y=0;y<height;++y) {
            pyc = y * width * 4;
            pyp = pyc - width * 4;
            pyn = pyc + width * 4;

            if (y < 1) pyp = pyc;
            if (y >= width-1) pyn = pyc;
            
            for (x=0;x<width;++x) {
                idx = (y * width + x) * 4;
                
                pxc = x * 4;
                pxp = pxc - 4;
                pxn = pxc + 4;
          
                if (x < 1) pxp = pxc;
                if (x >= width-1) pxn = pxc;
                
                p00 = pyp + pxp;    p01 = pyp + pxc;    p02 = pyp + pxn;
                p10 = pyc + pxp;    p11 = pyc + pxc;    p12 = pyc + pxn;
                p20 = pyn + pxp;    p21 = pyn + pxc;    p22 = pyn + pxn;

                r = inData[p00] * k00 + inData[p01] * k01 + inData[p02] * k02
                  + inData[p10] * k10 + inData[p11] * k11 + inData[p12] * k12
                  + inData[p20] * k20 + inData[p21] * k21 + inData[p22] * k22;

                g = inData[p00 + 1] * k00 + inData[p01 + 1] * k01 + inData[p02 + 1] * k02
                  + inData[p10 + 1] * k10 + inData[p11 + 1] * k11 + inData[p12 + 1] * k12
                  + inData[p20 + 1] * k20 + inData[p21 + 1] * k21 + inData[p22 + 1] * k22;
                  
                b = inData[p00 + 2] * k00 + inData[p01 + 2] * k01 + inData[p02 + 2] * k02
                  + inData[p10 + 2] * k10 + inData[p11 + 2] * k11 + inData[p12 + 2] * k12
                  + inData[p20 + 2] * k20 + inData[p21 + 2] * k21 + inData[p22 + 2] * k22;

                if (alpha) {
                    a = inData[p00 + 3] * k00 + inData[p01 + 3] * k01 + inData[p02 + 3] * k02
                      + inData[p10 + 3] * k10 + inData[p11 + 3] * k11 + inData[p12 + 3] * k12
                      + inData[p20 + 3] * k20 + inData[p21 + 3] * k21 + inData[p22 + 3] * k22;
                } else {
                    a = inData[idx+3];
                }

                if (mono) {
                    r = g = b = (r + g + b) / 3;
                }
                if (invert) {
                    r = 255 - r;
                    g = 255 - g;
                    b = 255 - b;
                }
                
                outData[idx] = r;
                outData[idx+1] = g;
                outData[idx+2] = b;
                outData[idx+3] = a;
                
                if (progress) {
                    prog = (idx/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        }
    }
    
    function convolve5x5(inData, outData, width, height, kernel, progress, alpha, invert, mono) {
        var idx, r, g, b, a,
            pyc, pyp, pyn, pypp, pynn,
            pxc, pxp, pxn, pxpp, pxnn,
            x, y,
            
            prog, lastProg = 0,
            n = width * height * 4,
            
            k00 = kernel[0][0], k01 = kernel[0][1], k02 = kernel[0][2], k03 = kernel[0][3], k04 = kernel[0][4],
            k10 = kernel[1][0], k11 = kernel[1][1], k12 = kernel[1][2], k13 = kernel[1][3], k14 = kernel[1][4],
            k20 = kernel[2][0], k21 = kernel[2][1], k22 = kernel[2][2], k23 = kernel[2][3], k24 = kernel[2][4],
            k30 = kernel[3][0], k31 = kernel[3][1], k32 = kernel[3][2], k33 = kernel[3][3], k34 = kernel[3][4],
            k40 = kernel[4][0], k41 = kernel[4][1], k42 = kernel[4][2], k43 = kernel[4][3], k44 = kernel[4][4],
            
            p00, p01, p02, p03, p04,
            p10, p11, p12, p13, p14,
            p20, p21, p22, p23, p24,
            p30, p31, p32, p33, p34,
            p40, p41, p42, p43, p44;
            
        for (y=0;y<height;++y) {
            pyc = y * width * 4;
            pyp = pyc - width * 4;
            pypp = pyc - width * 4 * 2;
            pyn = pyc + width * 4;
            pynn = pyc + width * 4 * 2;

            if (y < 1) pyp = pyc;
            if (y >= width-1) pyn = pyc;
            if (y < 2) pypp = pyp;
            if (y >= width-2) pynn = pyn;
            
            for (x=0;x<width;++x) {
                idx = (y * width + x) * 4;
                
                pxc = x * 4;
                pxp = pxc - 4;
                pxn = pxc + 4;
                pxpp = pxc - 8;
                pxnn = pxc + 8;
          
                if (x < 1) pxp = pxc;
                if (x >= width-1) pxn = pxc;
                if (x < 2) pxpp = pxp;
                if (x >= width-2) pxnn = pxn;
                
                p00 = pypp + pxpp;    p01 = pypp + pxp;    p02 = pypp + pxc;    p03 = pypp + pxn;    p04 = pypp + pxnn;
                p10 = pyp  + pxpp;    p11 = pyp  + pxp;    p12 = pyp  + pxc;    p13 = pyp  + pxn;    p14 = pyp  + pxnn;
                p20 = pyc  + pxpp;    p21 = pyc  + pxp;    p22 = pyc  + pxc;    p23 = pyc  + pxn;    p24 = pyc  + pxnn;
                p30 = pyn  + pxpp;    p31 = pyn  + pxp;    p32 = pyn  + pxc;    p33 = pyn  + pxn;    p34 = pyn  + pxnn;
                p40 = pynn + pxpp;    p41 = pynn + pxp;    p42 = pynn + pxc;    p43 = pynn + pxn;    p44 = pynn + pxnn;

                r = inData[p00] * k00 + inData[p01] * k01 + inData[p02] * k02 + inData[p03] * k04 + inData[p02] * k04
                  + inData[p10] * k10 + inData[p11] * k11 + inData[p12] * k12 + inData[p13] * k14 + inData[p12] * k14
                  + inData[p20] * k20 + inData[p21] * k21 + inData[p22] * k22 + inData[p23] * k24 + inData[p22] * k24
                  + inData[p30] * k30 + inData[p31] * k31 + inData[p32] * k32 + inData[p33] * k34 + inData[p32] * k34
                  + inData[p40] * k40 + inData[p41] * k41 + inData[p42] * k42 + inData[p43] * k44 + inData[p42] * k44;
                  
                g = inData[p00+1] * k00 + inData[p01+1] * k01 + inData[p02+1] * k02 + inData[p03+1] * k04 + inData[p02+1] * k04
                  + inData[p10+1] * k10 + inData[p11+1] * k11 + inData[p12+1] * k12 + inData[p13+1] * k14 + inData[p12+1] * k14
                  + inData[p20+1] * k20 + inData[p21+1] * k21 + inData[p22+1] * k22 + inData[p23+1] * k24 + inData[p22+1] * k24
                  + inData[p30+1] * k30 + inData[p31+1] * k31 + inData[p32+1] * k32 + inData[p33+1] * k34 + inData[p32+1] * k34
                  + inData[p40+1] * k40 + inData[p41+1] * k41 + inData[p42+1] * k42 + inData[p43+1] * k44 + inData[p42+1] * k44;
                  
                b = inData[p00+2] * k00 + inData[p01+2] * k01 + inData[p02+2] * k02 + inData[p03+2] * k04 + inData[p02+2] * k04
                  + inData[p10+2] * k10 + inData[p11+2] * k11 + inData[p12+2] * k12 + inData[p13+2] * k14 + inData[p12+2] * k14
                  + inData[p20+2] * k20 + inData[p21+2] * k21 + inData[p22+2] * k22 + inData[p23+2] * k24 + inData[p22+2] * k24
                  + inData[p30+2] * k30 + inData[p31+2] * k31 + inData[p32+2] * k32 + inData[p33+2] * k34 + inData[p32+2] * k34
                  + inData[p40+2] * k40 + inData[p41+2] * k41 + inData[p42+2] * k42 + inData[p43+2] * k44 + inData[p42+2] * k44;

                if (alpha) {
                    a = inData[p00+3] * k00 + inData[p01+3] * k01 + inData[p02+3] * k02 + inData[p03+3] * k04 + inData[p02+3] * k04
                      + inData[p10+3] * k10 + inData[p11+3] * k11 + inData[p12+3] * k12 + inData[p13+3] * k14 + inData[p12+3] * k14
                      + inData[p20+3] * k20 + inData[p21+3] * k21 + inData[p22+3] * k22 + inData[p23+3] * k24 + inData[p22+3] * k24
                      + inData[p30+3] * k30 + inData[p31+3] * k31 + inData[p32+3] * k32 + inData[p33+3] * k34 + inData[p32+3] * k34
                      + inData[p40+3] * k40 + inData[p41+3] * k41 + inData[p42+3] * k42 + inData[p43+3] * k44 + inData[p42+3] * k44;
                } else {
                    a = inData[idx+3];
                }

                if (mono) {
                    r = g = b = (r + g + b) / 3;
                }
                
                if (invert) {
                    r = 255 - r;
                    g = 255 - g;
                    b = 255 - b;
                }
                
                outData[idx] = r;
                outData[idx+1] = g;
                outData[idx+2] = b;
                outData[idx+3] = a;
                
                if (progress) {
                    prog = (idx/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        }
    }
    
    function gaussian(inData, outData, width, height, kernelSize, progress) {
        var r, g, b, a, idx,
            n = width * height * 4,
            x, y, i, j, 
            inx, iny, w,
            tmpData = [],
            maxKernelSize = 13,
            kernelSize = clamp(kernelSize, 3, maxKernelSize),
            k1 = -kernelSize / 2 + (kernelSize % 2 ? 0.5 : 0),
            k2 = kernelSize + k1,
            weights,
            kernels = [[1]],
            prog, lastProg = 0;
            
            
        for (i=1;i<maxKernelSize;++i) {
            kernels[0][i] = 0;
        }
        
        for (i=1;i<maxKernelSize;++i) {
            kernels[i] = [1];
            for (j=1;j<maxKernelSize;++j) {
                kernels[i][j] = kernels[i-1][j] + kernels[i-1][j-1];
            }
        }

        weights = kernels[kernelSize - 1]
        
        for (i=0,w=0;i<kernelSize;++i) {
            w += weights[i];
        }
        for (i=0;i<kernelSize;++i) {
            weights[i] /= w;
        }
        
        // pass 1
        for (y=0;y<height;++y) {
            for (x=0;x<width;++x) {
                r = g = b = a = 0;

                for (i=k1;i<k2;++i) {
                    inx = x + i;
                    iny = y;
                    w = weights[i - k1];
                    
                    if (inx < 0) {
                        inx = 0;
                    }
                    if (inx >= width) {
                        inx = width - 1;
                    }
                    
                    idx = (iny * width + inx) * 4;

                    r += inData[idx] * w;
                    g += inData[idx + 1] * w;
                    b += inData[idx + 2] * w;
                    a += inData[idx + 3] * w;

                }
                
                idx = (y * width + x) * 4;
                
                tmpData[idx] = r;
                tmpData[idx+1] = g;
                tmpData[idx+2] = b;
                tmpData[idx+3] = a;
                
                if (progress) {
                    prog = (idx/n*50 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        }
        
        lastProg = 0;
        
        // pass 2
        for (y=0;y<height;++y) {
            for (x=0;x<width;++x) {
                r = g = b = a = 0;

                for (i=k1;i<k2;++i) {
                    inx = x;
                    iny = y + i;
                    w = weights[i - k1];
                    
                    if (iny < 0) {
                        iny = 0;
                    }
                    if (iny >= height) {
                        iny = height - 1;
                    }
                    
                    idx = (iny * width + inx) * 4;
                    
                    r += tmpData[idx] * w;
                    g += tmpData[idx + 1] * w;
                    b += tmpData[idx + 2] * w;
                    a += tmpData[idx + 3] * w;
                }
                
                idx = (y * width + x) * 4;
                
                outData[idx] = r;
                outData[idx+1] = g;
                outData[idx+2] = b;
                outData[idx+3] = a;
                
                if (progress) {
                    prog = 0.5 + (idx/n*50 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        }
    }
    
    
    return {

        invert : function(inData, outData, width, height, options, progress) {
            var n = width * height * 4,
                prog, lastProg = 0;

            for (i=0;i<n;i+=4) {
                outData[i] = 255 - inData[i];
                outData[i+1] = 255 - inData[i+1];
                outData[i+2] = 255 - inData[i+2];
                outData[i+3] = inData[i+3];

                
                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },
        
        sepia : function(inData, outData, width, height, options, progress) {
            var n = width * height * 4,
                prog, lastProg = 0,
                r, g, b;

            for (var i=0;i<n;i+=4) {
                r = inData[i];
                g = inData[i+1];
                b = inData[i+2];
                outData[i] = (r * 0.393 + g * 0.769 + b * 0.189);
                outData[i+1] = (r * 0.349 + g * 0.686 + b * 0.168);
                outData[i+2] = (r * 0.272 + g * 0.534 + b * 0.131);
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },
        
        solarize : function(inData, outData, width, height, options, progress) {
            var n = width * height * 4,
                prog, lastProg = 0,
                r, g, b;

            for (i=0;i<n;i+=4) {
                r = inData[i];
                g = inData[i+1];
                b = inData[i+2];
                
                outData[i] = r > 127 ? 255 - r : r;
                outData[i+1] = g > 127 ? 255 - g : g;
                outData[i+2] = b > 127 ? 255 - b : b;
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },

        brightness : function(inData, outData, width, height, options, progress) {
            options = defaultOptions(options, {
                brightness : 0,
                contrast : 0
            });
            
            var contrast = clamp(options.contrast, -1, 1) / 2,
                brightness = 1 + clamp(options.brightness, -1, 1),
                prog, lastProg = 0,
                r, g, b,
                n = width * height * 4;

            var brightMul = brightness < 0 ? - brightness : brightness;
            var brightAdd = brightness < 0 ? 0 : brightness;

            contrast = 0.5 * Math.tan((contrast + 1) * Math.PI/4);
            contrastAdd = - (contrast - 0.5) * 255;

            for (var i=0;i<n;i+=4) {
                r = inData[i];
                g = inData[i+1];
                b = inData[i+2];
                
                r = (r + r * brightMul + brightAdd) * contrast + contrastAdd;
                g = (g + g * brightMul + brightAdd) * contrast + contrastAdd;
                b = (b + b * brightMul + brightAdd) * contrast + contrastAdd;
                
                outData[i] = r;
                outData[i+1] = g;
                outData[i+2] = b;
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },
        
        desaturate : function(inData, outData, width, height, options, progress) {
            var n = width * height * 4,
                prog, lastProg = 0,
                level;

            for (var i=0;i<n;i+=4) {
                level = inData[i] * 0.3 + inData[i+1] * 0.59 + inData[i+2] * 0.11;
                outData[i] = level;
                outData[i+1] = level;
                outData[i+2] = level;
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },
        
        lighten : function(inData, outData, width, height, options, progress) {
            var n = width * height * 4,
                prog, lastProg = 0,
                mul = 1 + clamp(options.amount, 0, 1);

            for (var i=0;i<n;i+=4) {
                outData[i] = inData[i] * mul;
                outData[i+1] = inData[i+1] * mul;
                outData[i+2] = inData[i+2] * mul;
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },
        
        noise : function(inData, outData, width, height, options, progress) {
            var n = width * height * 4,
                prog, lastProg = 0,
                amount = clamp(options.amount, 0, 1),
                strength = clamp(options.strength, 0, 1),
                mono = !!options.mono,
                random = Math.random,
                rnd, r, g, b;
                
            for (var i=0;i<n;i+=4) {
                r = inData[i];
                g = inData[i+1];
                b = inData[i+2];
                
                rnd = random();
                
                if (rnd < amount) {
                    if (mono) {
                        rnd = strength * ((rnd / amount) * 2 - 1) * 255;
                        r += rnd;
                        g += rnd;
                        b += rnd;
                    } else {
                        r += strength * random() * 255;
                        g += strength * random() * 255;
                        b += strength * random() * 255;
                    }
                }
                
                outData[i] = r;
                outData[i+1] = g;
                outData[i+2] = b;
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },
        
        fliph : function(inData, outData, width, height, options, progress) {
            var inPix, outPix,
                n = width * height * 4,
                prog, lastProg = 0,
                x, y;
            for (y=0;y<height;++y) {
                for (x=0;x<width;++x) {
                    inPix = (y * width + x) * 4;
                    outPix = (y * width + (width - x - 1)) * 4;
                    
                    outData[outPix] = inData[inPix];
                    outData[outPix+1] = inData[inPix+1];
                    outData[outPix+2] = inData[inPix+2];
                    outData[outPix+3] = inData[inPix+3];
                    
                    if (progress) {
                        prog = (inPix/n*100 >> 0) / 100;
                        if (prog > lastProg) {
                            lastProg = progress(prog);
                        }
                    }
                }
            }
        },
        
        flipv : function(inData, outData, width, height, options, progress) {
            var inPix, outPix,
                n = width * height * 4,
                prog, lastProg = 0,
                x, y;
            for (y=0;y<height;++y) {
                for (x=0;x<width;++x) {
                    inPix = (y * width + x) * 4;
                    outPix = ((height - y - 1) * width + x) * 4;
                    
                    outData[outPix] = inData[inPix];
                    outData[outPix+1] = inData[inPix+1];
                    outData[outPix+2] = inData[inPix+2];
                    outData[outPix+3] = inData[inPix+3];
                    
                    if (progress) {
                        prog = (inPix/n*100 >> 0) / 100;
                        if (prog > lastProg) {
                            lastProg = progress(prog);
                        }
                    }
                }
            }
        },

        blur : function(inData, outData, width, height, options, progress) {
            gaussian(inData, outData, width, height, options.kernelSize, progress);
        },

        glow : function(inData, outData, width, height, options, progress) {
            var n = width * height * 4,
                i, r, g, b,
                amount = options.amount,
                tmpData = [],
                gaussProgress,
                prog, lastProg = 0;

            if (progress) {
                gaussProgress = function(p) {
                    progress(p * 0.8);
                    return p;
                }
            }
            
            gaussian(inData, tmpData, width, height, options.kernelSize, gaussProgress);
            
            for (i=0;i<n;i+=4) {
                r = inData[i]   + tmpData[i]   * amount;
                g = inData[i+1] + tmpData[i+1] * amount;
                b = inData[i+2] + tmpData[i+2] * amount;
                if (r > 255) r = 255;
                if (g > 255) g = 255;
                if (b > 255) b = 255;
                outData[i] = r;
                outData[i+1] = g;
                outData[i+2] = b;
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = 0.8 + (i/n*100 >> 0) / 100 * 0.2;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },

        convolve3x3 : function(inData, outData, width, height, options, progress) {
            convolve3x3(inData, outData, width, height, options.kernel, progress);
        },
        
        convolve5x5 : function(inData, outData, width, height, options, progress) {
            convolve3x3(inData, outData, width, height, options.kernel, progress);
        },
        
        // A 3x3 high-pass filter
        sharpen3x3 : function(inData, outData, width, height, options, progress) {
            var a = - clamp(options.strength, 0, 1);
            convolve3x3(
                inData, outData, width, height, 
                [[a,     a, a],
                 [a, 1-a*8, a],
                 [a,     a, a]],
                progress
            );
        },

        // A 5x5 high-pass filter
        sharpen5x5 : function(inData, outData, width, height, options, progress) {
            var a = - clamp(options.strength, 0, 1);
            convolve5x5(
                inData, outData, width, height, 
                [[a, a,      a, a, a],
                 [a, a,      a, a, a],
                 [a, a, 1-a*24, a, a],
                 [a, a,      a, a, a],
                 [a, a,      a, a, a]],
                progress
             );
        },

        // A 3x3 low-pass mean filter
        soften3x3 : function(inData, outData, width, height, options, progress) {
            var c = 1/9;
            convolve3x3(
                inData, outData, width, height, 
                [[c, c, c],
                 [c, c, c],
                 [c, c, c]],
                progress
            );
        },
        
        // A 5x5 low-pass mean filter
        soften5x5 : function(inData, outData, width, height, options, progress) {
            var c = 1/25;
            convolve5x5(
                inData, outData, width, height, 
                [[c, c, c, c, c],
                 [c, c, c, c, c],
                 [c, c, c, c, c],
                 [c, c, c, c, c],
                 [c, c, c, c, c]],
                progress
            );
        },
        
        // A 3x3 Cross edge-detect
        crossedges : function(inData, outData, width, height, options, progress) {
            var a = clamp(options.strength, 0, 1) * 5
            convolve3x3(
                inData, outData, width, height, 
                [[ 0, -a, 0],
                 [-a,  0, a],
                 [ 0,  a, 0]],
                progress,
                false, true
            );
        },
        
        // 3x3 directional emboss
         emboss : function(inData, outData, width, height, options, progress) {
            var amount = options.amount,
                angle = options.angle,
                x = Math.cos(-angle) * amount,
                y = Math.sin(-angle) * amount,
                n = width * height * 4,
                
                a00 = -x - y,
                a10 = -x,
                a20 = y - x,
                a01 = -y,
                a21 = y,
                a02 = -y + x,
                a12 = x,
                a22 = y + x,

                tmpData = [],
                
                prog, lastProg = 0,
                convProgress;
                
            if (progress) {
                convProgress = function(p) {
                    progress(p * 0.5)
                    return p;
                };
            }
            
            convolve3x3(
                inData, tmpData, width, height, 
                [[a00, a01, a02],
                 [a10,   0, a12],
                 [a20, a21, a22]]
            );
            
            for (var i=0;i<n;i+=4) {
                outData[i]   = 128 + tmpData[i];
                outData[i+1] = 128 + tmpData[i+1];
                outData[i+2] = 128 + tmpData[i+2];
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = 0.5 + (i/n*100 >> 0) / 100 * 0.5;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },

        
        // A 3x3 Sobel edge detect (similar to Photoshop's)
        findedges : function(inData, outData, width, height, options, progress) {
            var n = width * height * 4,
                i,
                data1 = [], 
                data2 = [],
                gr1, gr2, gg1, gg2, gb1, gb2,
                prog, lastProg = 0,
                convProgress1, convProgress2;

            if (progress) {
                convProgress1 = function(p) {
                    progress(p * 0.4);
                    return p;
                };
                convProgress2 = function(p) {
                    progress(0.4 + p * 0.4);
                    return p;
                };
            }
            
            convolve3x3(inData, data1, width, height, 
                [[-1, 0, 1],
                 [-2, 0, 2],
                 [-1, 0, 1]]
            );
            convolve3x3(inData, data2, width, height, 
                [[-1, -2, -1],
                 [ 0,  0,  0],
                 [ 1,  2,  1]]
            );
            
            for (i=0;i<n;i+=4) {
                gr1 = data1[i];
                gr2 = data2[i];
                gg1 = data1[i+1];
                gg2 = data2[i+1];
                gb1 = data1[i+2];
                gb2 = data2[i+2];
                
                if (gr1 < 0) gr1 = -gr1;
                if (gr2 < 0) gr2 = -gr2;
                if (gg1 < 0) gg1 = -gg1;
                if (gg2 < 0) gg2 = -gg2;
                if (gb1 < 0) gb1 = -gb1;
                if (gb2 < 0) gb2 = -gb2;
            
                outData[i] = 255 - (gr1 + gr2) * 0.8;
                outData[i+1] = 255 - (gg1 + gg2) * 0.8;
                outData[i+2] = 255 - (gb1 + gb2) * 0.8;
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = 0.8 + (i/n*100 >> 0) / 100 * 0.2;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },
        
        // A 3x3 edge enhance
        edgeenhance3x3 : function(inData, outData, width, height, options, progress) {
            convolve3x3(
                inData, outData, width, height, 
                [[-1/9, -1/9, -1/9],
                 [-1/9,  17/9, -1/9],
                 [-1/9, -1/9, -1/9]],
                progress
            );
        },
        
        // A 5x5 edge enhance
        edgeenhance5x5 : function(inData, outData, width, height, options, progress) {
            convolve5x5(
                inData, outData, width, height, 
                [[-1/25, -1/25, -1/25, -1/25, -1/25],
                 [-1/25, -1/25, -1/25, -1/25, -1/25],
                 [-1/25, -1/25, 49/25, -1/25, -1/25],
                 [-1/25, -1/25, -1/25, -1/25, -1/25],
                 [-1/25, -1/25, -1/25, -1/25, -1/25]],
                progress
            );
        },

        // A 3x3 Laplacian edge-detect
        laplace3x3 : function(inData, outData, width, height, options, progress) {
            convolve3x3(
                inData, outData, width, height, 
                [[-1, -1, -1],
                 [-1,  8, -1],
                 [-1, -1, -1]],
                progress,
                false, true, true
            );
        },
        
        // A 5x5 Laplacian edge-detect
        laplace5x5 : function(inData, outData, width, height, options, progress) {
            convolve5x5(
                inData, outData, width, height, 
                [[-1, -1, -1, -1, -1],
                 [-1, -1, -1, -1, -1],
                 [-1, -1, 24, -1, -1],
                 [-1, -1, -1, -1, -1],
                 [-1, -1, -1, -1, -1]],
                progress,
                false, true, true
            );
        },
        
        coloradjust : function(inData, outData, width, height, options, progress) {
            var n = width * height * 4,
                r, g, b,
                prog, lastProg = 0,
                ar = clamp(options.r, -1, 1) * 255,
                ag = clamp(options.g, -1, 1) * 255,
                ab = clamp(options.b, -1, 1) * 255;

            for (var i=0;i<n;i+=4) {
                r = inData[i] + ar;
                g = inData[i+1] + ag;
                b = inData[i+2] + ab;
                if (r < 0) r = 0;
                if (g < 0) g = 0;
                if (b < 0) b = 0;
                if (r > 255) r = 255;
                if (g > 255) g = 255;
                if (b > 255) b = 255;
                outData[i] = r;
                outData[i+1] = g;
                outData[i+2] = b;
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },
        
        colorfilter : function(inData, outData, width, height, options, progress) {
            var n = width * height * 4,
                i, r, g, b,
                luminosity = !!options.luminosity,
                prog, lastProg = 0,
                min, max, h, l, h1, chroma, tmp, m,
                ar = clamp(options.r, 0, 1),
                ag = clamp(options.g, 0, 1),
                ab = clamp(options.b, 0, 1);
                
            for (i=0;i<n;i+=4) {
                r = inData[i] / 255;
                g = inData[i+1] / 255;
                b = inData[i+2] / 255;
                
                l = r * 0.3 + g * 0.59 + b * 0.11;
                    
                r = (r + r * ar) / 2;
                g = (g + g * ag) / 2;
                b = (b + b * ab) / 2;

                if (luminosity) {
                    min = max = r;
                    if (g > max) max = g;
                    if (b > max) max = b;
                    if (g < min) min = g;
                    if (b < min) min = b;
                    chroma = (max - min);

                    if (r == max) {
                        h = ((g - b) / chroma) % 6;
                    } else if (g == max) {
                        h = ((b - r) / chroma) + 2;
                    } else {
                        h = ((r - g) / chroma) + 4;
                    }

                    h1 = h >> 0;
                    tmp = chroma * (h - h1);
                    r = g = b = l - (r * 0.3 + g * 0.59 + b * 0.11);
                        
                    if (h1 == 0) {
                        r += chroma; 
                        g += tmp;
                    } else if (h1 == 1) {
                        r += chroma - tmp;
                        g += chroma;
                    } else if (h1 == 2) {
                        g += chroma;
                        b += tmp;
                    } else if (h1 == 3) {
                        g += chroma - tmp;
                        b += chroma;
                    } else if (h1 == 4) {
                        r += tmp;
                        b += chroma;
                    } else if (h1 == 5) {
                        r += chroma;
                        b += chroma - tmp;
                    }
                }

                outData[i] = r * 255;
                outData[i+1] = g * 255;
                outData[i+2] = b * 255;
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },
        
        hsl : function(inData, outData, width, height, options, progress) {
            var n = width * height * 4,
                hue = clamp(options.hue, -1, 1),
                saturation = clamp(options.saturation, -1, 1),
                lightness = clamp(options.lightness, -1, 1),
                satMul = 1 + saturation * (saturation < 0 ? 1 : 2),
                lightMul = lightness < 0 ? 1 + lightness : 1 - lightness,
                lightAdd = lightness < 0 ? 0 : lightness * 255,
                vs, ms, vm, h, s, l, v, m, vmh, sextant,
                prog, lastProg = 0;

            hue = (hue * 6) % 6;
                    
            for (var i=0;i<n;i+=4) {

                r = inData[i];
                g = inData[i+1];
                b = inData[i+2];
                
                if (hue != 0 || saturation != 0) {
                    // ok, here comes rgb to hsl + adjust + hsl to rgb, all in one jumbled mess. 
                    // It's not so pretty, but it's been optimized to get somewhat decent performance.
                    // The transforms were originally adapted from the ones found in Graphics Gems, but have been heavily modified.
                    vs = r;
                    if (g > vs) vs = g;
                    if (b > vs) vs = b;
                    ms = r;
                    if (g < ms) ms = g;
                    if (b < ms) ms = b;
                    vm = (vs-ms);
                    l = (ms+vs)/510;
                    
                    if (l > 0 && vm > 0) {
                        if (l <= 0.5) {
                            s = vm / (vs+ms) * satMul;
                            if (s > 1) s = 1;
                            v = (l * (1+s));
                        } else {
                            s = vm / (510-vs-ms) * satMul;
                            if (s > 1) s = 1;
                            v = (l+s - l*s);
                        }
                        if (r == vs) {
                            if (g == ms) {
                                h = 5 + ((vs-b)/vm) + hue;
                            } else {
                                h = 1 - ((vs-g)/vm) + hue;
                            }
                        } else if (g == vs) {
                            if (b == ms) {
                                h = 1 + ((vs-r)/vm) + hue;
                            } else {
                                h = 3 - ((vs-b)/vm) + hue;
                            }
                        } else {
                            if (r == ms) {
                                h = 3 + ((vs-g)/vm) + hue;
                            } else {
                                h = 5 - ((vs-r)/vm) + hue;
                            }
                        }
                        if (h < 0) h += 6;
                        if (h >= 6) h -= 6;
                        m = (l + l - v);
                        sextant = h >> 0;
                        vmh = (v - m) * (h - sextant);
                        if (sextant == 0) {
                            r = v; 
                            g = m + vmh;
                            b = m;
                        } else if (sextant == 1) {
                            r = v - vmh;
                            g = v;
                            b = m;
                        } else if (sextant == 2) {
                            r = m;
                            g = v;
                            b = m + vmh;
                        } else if (sextant == 3) {
                            r = m;
                            g = v - vmh;
                            b = v;
                        } else if (sextant == 4) {
                            r = m + vmh;
                            g = m;
                            b = v;
                        } else if (sextant == 5) {
                            r = v;
                            g = m;
                            b = v - vmh;
                        }
                        
                        r *= 255;
                        g *= 255;
                        b *= 255;
                    }
                }
                
                r = r * lightMul + lightAdd;
                g = g * lightMul + lightAdd;
                b = b * lightMul + lightAdd;
                
                if (r < 0) r = 0;
                if (g < 0) g = 0;
                if (b < 0) b = 0;
                if (r > 255) r = 255;
                if (g > 255) g = 255;
                if (b > 255) b = 255;
                
                outData[i] = r;
                outData[i+1] = g;
                outData[i+2] = b;
                outData[i+3] = inData[i+3];
                
                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        },
        
        posterize : function(inData, outData, width, height, options, progress) {
            var numLevels = clamp(options.levels, 2, 256),
                numAreas = 256 / numLevels,
                numValues = 256 / (numLevels-1),
                r, g, b,
                n = width * height * 4,
                prog, lastProg = 0;

            for (i=0;i<n;i+=4) {
            
                outData[i] = numValues * ((inData[i] / numAreas)>>0);
                outData[i+1] = numValues * ((inData[i+1] / numAreas)>>0); 
                outData[i+2] = numValues * ((inData[i+2] / numAreas)>>0); 
            
                outData[i+3] = inData[i+3];

                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
            
        },
        
        removenoise : function(inData, outData, width, height, options, progress) {
            var r, g, b, c, y, x, idx,
                pyc, pyp, pyn,
                pxc, pxp, pxn,
                minR, minG, minB, maxR, maxG, maxB,
                n, prog, lastProg = 0;
                
            n = width * height * 4;
                
            for (y=0;y<height;++y) {
                pyc = y * width * 4;
                pyp = pyc - width * 4;
                pyn = pyc + width * 4;

                if (y < 1) pyp = pyc;
                if (y >= width-1) pyn = pyc;
                
                for (x=0;x<width;++x) {
                    idx = (y * width + x) * 4;
                    
                    pxc = x * 4;
                    pxp = pxc - 4;
                    pxn = pxc + 4;
              
                    if (x < 1) pxp = pxc;
                    if (x >= width-1) pxn = pxc;
                    
                    minR = maxR = inData[pyc + pxp];
                    c = inData[pyc + pxn];
                    if (c < minR) minR = c;
                    if (c > maxR) maxR = c;
                    c = inData[pyp + pxc];
                    if (c < minR) minR = c;
                    if (c > maxR) maxR = c;
                    c = inData[pyn + pxc];
                    if (c < minR) minR = c;
                    if (c > maxR) maxR = c;

                    minG = inData[pyc + pxp + 1];
                    c = inData[pyc + pxn + 1];
                    if (c < minG) minG = c;
                    c = inData[pyp + pxc + 1];
                    if (c < minG) minG = c;
                    c = inData[pyn + pxc + 1];
                    if (c < minG) minG = c;
                    
                    minB = inData[pyc + pxp + 2];
                    c = inData[pyc + pxn + 2];
                    if (c < minB) minB = c;
                    c = inData[pyp + pxc + 2];
                    if (c < minB) minB = c;
                    c = inData[pyn + pxc + 2];
                    if (c < minB) minB = c;

                    r = inData[idx]
                    g = inData[idx + 1]
                    b = inData[idx + 2]
                    
                    if (r < minR) r = minR;
                    if (r > maxR) r = maxR;
                    if (g < minG) g = minG;
                    if (g > maxG) g = maxG;
                    if (b < minB) b = minB;
                    if (b > maxB) b = maxB;
                    
                    outData[idx] = r;
                    outData[idx+1] = g;
                    outData[idx+2] = b;
                    outData[idx+3] = inData[idx+3];
                    
                    if (progress) {
                        prog = (idx/n*100 >> 0) / 100;
                        if (prog > lastProg) {
                            lastProg = progress(prog);
                        }
                    }
                }
            }
        },

        mosaic : function(inData, outData, width, height, options, progress) {

            var blockSize = clamp(options.blockSize, 1, Math.max(width, height)),
                yBlocks = Math.ceil(height / blockSize),
                xBlocks = Math.ceil(width / blockSize),
                y0, y1, x0, x1, idx, pidx,
                n = yBlocks * xBlocks,
                prog, lastProg = 0;

            for (i=0, y0=0, bidx=0;i<yBlocks;i++) {
                y1 = clamp(y0 + blockSize, 0, height);
                for(j=0, x0=0;j<xBlocks;j++,bidx++) {
                    x1 = clamp(x0 + blockSize, 0, width);

                    idx = (y0 * width + x0) << 2;
                    var r = inData[idx], g = inData[idx+1], b = inData[idx+2];

                    for(bi=y0;bi<y1;bi++) {
                        for(bj=x0;bj<x1;bj++) {
                            pidx = (bi*width+bj) << 2;
                            outData[pidx] = r, outData[pidx+1] = g, outData[pidx+2] = b;
                            outData[pidx+3] = inData[pidx+3];
                        }
                    }

                    x0 = x1;

                    if (progress) {
                        prog = (bidx/n*100 >> 0) / 100;
                        if (prog > lastProg) {
                            lastProg = progress(prog);
                        }
                    }
                }
                y0 = y1;
            }
        },

        equalize : function(inData, outData, width, height, options, progress) {
            var n = width * height, p, i, level, ratio,
                prog, lastProg;
            var round = Math.round;
            // build histogram
            var pdf = new Array(256);
            for (i=0;i<256;i++) {
                pdf[i] = 0;
            }

            for (i=0;i<n;i++) {
                p = i * 4;
                level = clamp(round(inData[p] * 0.3 + inData[p+1] * 0.59 + inData[p+2] * 0.11), 0, 255);
                outData[p+3] = level;
                pdf[ level ]++;
            }

            // build cdf
            var cdf = new Array(256);
            cdf[0] = pdf[0];
            for(i=1;i<256;i++) {
                cdf[i] = cdf[i-1] + pdf[i];
            }

            // normalize cdf
            for(i=0;i<256;i++) {
                cdf[i] = cdf[i] / n * 255.0;
            }

            // map the pixel values
            for (i=0;i<n;i++) {
                p = i * 4;
                level = outData[p+3];
                ratio = cdf[level] / (level || 1);
                outData[p] = clamp(round(inData[p] * ratio), 0, 255);
                outData[p+1] = clamp(round(inData[p+1] * ratio), 0, 255);
                outData[p+2] = clamp(round(inData[p+2] * ratio), 0, 255);
                outData[p+3] = inData[p+3];

                if (progress) {
                    prog = (i/n*100 >> 0) / 100;
                    if (prog > lastProg) {
                        lastProg = progress(prog);
                    }
                }
            }
        }
    };

})();
//求灰度值
function grayValues(src){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,gray,out=[];
		var total=width*height;
		for(var i=0,j=0;i<total*4;i+=4){
			gray=Math.round(data[i]*.3+data[i+1]*.59+data[i+2]*.11);
			out[j++]=gray;
			}
			return out;
		}
		else{
			return false;
			}
	}
//负向变换
function negative(src){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,out=[],total=width*height;
		for(var i=0,j=0;i<total*4;i+=4){
			out[i]=255-data[i];
			out[i+1]=255-data[i+1];
			out[i+2]=255-data[i+2];
			}
		return out;
		}
	}
function negativeGray(src){
	if(src&&src.data){
		var width=src.width,height=src.height,out=[],total=width*height,grayValue=grayValues(src);
		for(var i=0;i<total;i++){
			out[i]=255-grayValue[i];
			}
		return out;
		}
	}
// 二值化合阈值处理
function grayTrans(src,threshold){
	if(src&&src.data){
		var width=src.width,height=src.height,out=[],total=width*height,grayValue=grayValues(src);
		for(var i=0;i<total;i++){
			if(grayValue[i]<threshold){
				grayValue[i]=0;
				}
			else{
				grayValue[i]=255;
				}
			}
		}
	else if(src instanceof Array&&src.length>0){
		for(var i=0,len=src.length;i<len;i++){
			if(src[i]<threshold){
				src[i]=0;
				}
			else{
				src[i]=255;
				}
			}
		}
	}
//分段线性变换
function grayLinearTrans(src,x1,y1,x2,y2){
	if(src&&src.data){
		//3个分段的直线斜率
		var slope1=y1/x1,slope2=(y2-y1)/(x2-x1),slope3=(255-y2)/(255-x2),width=src.width,height=src.height,grayValue=grayValues(src),out=[];
		//3个直线坐标的斜率
		var dis1=0,dis2=y1-slope2*x1,dis3=y2-slope3*x2;
		// 映射表
		var map=[];
		//根据三个分段，对输入图像每个灰度级计算映射表
		for(var i=0;i<256;i++){
			if(i<x1){
				map[i]=Math.floor(slope1*i+dis1+.5);
				}
			else if(i<x2){
				map[i]=Math.floor(slope2*i+dis2+.5);
				}
			else {
				map[i]=Math.floor(slope3*i+dis3+.5);
				}
			}
		//临时变量
		var temp;
		//对每个像素，根据输入像素灰度级查找映射表，并为输出像素赋值
		for(var i=0,len=grayValue.length;i<len;i++){
			out[i]=map[i];
			}
		}
	}
//对数函数非线性变换
function grayLogTrans(src,a,b,c){
	if(src&&src.data){
		var temp1,temp2,t,width=src.width,height=src.height,grayValue=grayValues(src),out=[];
		for(var i=0,len=grayValue.length;i<len;i++){
				//根据输入点像素灰度值，计算输出点像素灰度值
				temp1=Math.log(grayValue[i])/Math.LN2;
				temp2=b*Math.log(c)/Math.LN2;
				t=a+temp1/temp2;
				if(t>255){
					t=255;
					}
				else if(t<0){
					t=0;
					}
				out[i]=t;
			}
		}
	}
//指数函数非线性变
function grayexTrans(src,a,b,c){
	var t,grayValue=grayValues(src),out=[];
	for(var i=0,len=grayValue.length;i<len;i++){
		t=c*(grayValue[i]-a);
		t=Math.pow(b,t)-1;
		if(t>255){
			t=255;
			}
		else if(t<0){
			t=0;
			}
		out[i]=t;
		}
	}
function histogram(src){
	if(src&&src.data){
		var grayValue=grayValues(src),m_histArray=[],temp;
		for(var i=0;i<256;i++){
			m_histArray[i]=0;
			}
		for(var i=0,len=grayValue.length;i<len;i++){
			temp=grayValue[i];
			m_histArray[temp]++;
			}
		}
	else if(src instanceof Array){
		var m_histArray=[],temp;
		for(var i=0;i<256;i++){
			m_histArray[i]=0;
			}
		for(var i=0,len=src.length;i<len;i++){
			temp=src[i];
			m_histArray[temp]++;
			}
		}
		return m_histArray;
	}
// 图像的亮度统计直方图
function HistBrightness(src){
	if(src&&src.data){
		var m_histArray=[],width=src.width,height=src.height,data=src.data,total=width*height,temp;
		for(var i=0;i<256;i++){
			m_histArray[i]=0;
			}
		//统计亮度
		for(var i=0;i<total;i+=4){
			temp=.11*data[i]+.59*data[i+1]+.30*data[i+2]+.5;
			m_histArray[temp]++;
			}
	return m_histArray;
	}
}
//对图像红色分量的统计
function HistRed(src){
	if(src&&src.data){
		var m_histArray=[],width=src.width,height=src.height,data=src.data,total=width*height,temp;
		for(var i=0;i<256;i++){
			m_histArray[i]=0;
			}
		for(var i=0;i<total;i+=4){
			temp=data[i];
			m_histArray[temp]++;
			}
			return m_histArray;
		}
	}
	//对图像绿色分量的统
	function HistGreen(src){
		if(src&&src.data){
			var m_histArray=[],width=src.width,height=src.height,data=src.data,total=width*height,temp;
		for(var i=0;i<256;i++){
			m_histArray[i]=0;
			}
		for(var i=0;i<total;i+=4){
			temp=data[i+1];
			m_histArray[temp]++;
			}
			return m_histArray;
			}
		}
	//对图像蓝色分量的统
	function HistBlue(src){
		if(src&&src.data){
			var m_histArray=[],width=src.width,height=src.height,data=src.data,total=width*height,temp;
		for(var i=0;i<256;i++){
			m_histArray[i]=0;
			}
		for(var i=0;i<total;i+=4){
			temp=data[i+2];
			m_histArray[temp]++;
			}
		return m_histArray;
			}
		} 
//直方图均衡
function histAve(src){
	if(src&&src.data){
		var width=src.width,height=src.height,temp,map=[],sum=0,m_histArray=histogram(src),data=src.data,out=[];
		for(var i=0;i<256;i++){
			sun+=m_histArray[i];
			map[i]=sun*255/(width*height)+.5;
			}
		for(var i=0;i<data.length;i++){
			temp=data[i];
			out[i]=Math.floor(map[temp]);
			}
		}
	}
// 移动图像
function imageMove(src,offsetX,offsetY){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,out=[];
		for(var i=0;i<data.length;i++){
			out[i]=0;
			}
		for(var i=0;i<height;i++){
			for(var j=0;j<width;j++){
				//输出的点在输入图像范围内
				if(i-offsetY>=0&&i-offsetY<height&&(j-offsetX)>=0&&(j-offsetX)<width){
					out[(i*width+j)*4]=data[(i*width+j)*4];
					out[(i*width+j)*4+1]=data[(i*width+j)*4+1];
					out[(i*width+j)*4+2]=data[(i*width+j)*4+2];
					out[(i*width+j)*4+3]=data[(i*width+j)*4+3];
					}
				}
			}
		return out;
		}
	}
	//图像的转置
	function transpos(src){
		if(src&&src.data){
			var width=src.width,height=src.height,data=src.data,out=[];
			for(var i=0;i<height;i++){
				for(var j=0;j<width;j++){
					out[(j*width+i)*4]=data[(i*width+j)*4];
					out[(j*width+i)*4+1]=data[(i*width+j)*4+1];
					out[(j*width+i)*4+2]=data[(i*width+j)*4+2];
					out[(j*width+i)*4+3]=data[(i*width+j)*4+3];
					}
				}
			return out;
			}
		}
	//图像的水平镜像
		function flipX(src){
			if(src&&src.data){
				var width=src.width,height=src.height,data=src.data,out=[];
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						out[(i*width+j)*4]=data[(i*width+width-1-j)*4];
						out[(i*width+j)*4+1]=data[(i*width+width-1-j)*4+1];
						out[(i*width+j)*4+2]=data[(i*width+width-1-j)*4+2];
						out[(i*width+j)*4+3]=data[(i*width+width-1-j)*4+3];
						}
					}
				}
			}
	//图像的垂直镜像
	function flipY(src){
		if(src&&src.data){
			var width=src.width,height=src.height,data=src.data,out=[];
			for(var i=0;i<height;i++){
				for(var j=0;j<width;j++){
					out[(i*width+j)*4]=data[((height-1-i)*width+j*4)];
					out[(i*width+j)*4+1]=data[((height-1-i)*width+j*4)+1];
					out[(i*width+j)*4+2]=data[((height-1-i)*width+j*4)+2];
					out[(i*width+j)*4+3]=data[((height-1-i)*width+j*4)+3];
					}
				}
			}
		}
	//最近零插值
	function interpolationLinear(array,xpos,ypos){
		if(array instanceof Array&&array.length==4){
			var t1,t2;
			t1=(1-ypos)*array[0]+ypos*array[1];
			t2=(1-ypos)*array[2]+ypos*array[3];
			var t=Math.floor((1-xpos)*t1+xpos*t2);
			if(t<0){
				t=0;
				}
			if(t>255){
				t=255;
				}	
			return t;
			}
		}
	//立方卷积插值
	function interpolationCube(array,xpos,ypos){
		if(array instanceof Array&&array.length==16){
			var col=[],row=[],t,tempArray=[],temp;
			col[0]=xpos+1;
			col[1]=xpos;
			col[2]=1-xpos;
			col[3]=2-xpos;
			//准备插值的y方向数据量
			row[0]=ypos+1;
			row[1]=ypos;
			row[2]=1-ypos;
			row[3]=2-ypos;
			for(var i=0;i<4;i++){
				t=Math.abs(col[i]);
				if(t>0&&t<1){
					col[i]=Math.pow(t,3)-2*Math.pow(t,2)+1;
					}
				else if(t>=1&&t<2){
					col[i]=-Math.pow(t,3)+5*Math.pow(t,2)-8*t+4;
				}
				else {
					col[i]=0;
					}
			}
			for(var i=0;i<4;i++){
				t=Math.abs(col[i]);
				if(t>0&&t<1){
					row[i]=Math.pow(t,3)-2*Math.pow(t,2)+1;
					}
				else if(t>=1&&t<2){
					row[i]=-Math.pow(t,3)+5*Math.pow(t,2)-8*t+4;
				}
				else {
					row[i]=0;
					}
			}
			for(var i=0;i<4;i++){
				tempArrayp[i]=row[0]*array[0*4+i]+row[1]*array[1*4+i]+row[2]*array[2*4+i]+row[3]*array[3*4+i];
			}
				temp=0;
				for(var i=0;i<4;i++){
					temp+=tempArrayp[i]*col[i];
					}
				if(temp>255){
					temp=255;
					}
				if(temp<0){
					temp=0;
					}
				
			return Math.floor(temp);
		}
	}
//图像的缩放
function zoomNeighbor(src,widthOut,heightOut){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data;
		var ratioX=widthOut/width,ratioY=heightOut/height,coordinateX,coordinateY,out=[];
		//近邻插值法
		for(var i=0;i<heightOut;i++){
			for(var j=0;j<widthOut;j++){
				coordinateX=Math.floor(j/ratioX+.5);
				coordinateY=Math.floor(i/ratioY+.5);
				if(0<=coordinateX&&coordinateX<width&&coordinateY>=0&&coordinateY<height){
					out[(i*widthOut+j)*4]=data[(coordinateY*width+coordinateX)*4];
					out[(i*widthOut+j)*4+1]=data[(coordinateY*width+coordinateX)*4+1];
					out[(i*widthOut+j)*4+2]=data[(coordinateY*width+coordinateX)*4+2];
					out[(i*widthOut+j)*4+3]=data[(coordinateY*width+coordinateX)*4+3];
					}
				else{
					out[(i*widthOut+j)*4]=255;
					out[(i*widthOut+j)*4+1]=255;
					out[(i*widthOut+j)*4+2]=255;
					out[(i*widthOut+j)*4+3]=255;
					}
				}
			}
		}
	}
function zoomLinear(src,widthOut,heightOut){
	if(src&&src.data){
		var width=src.width,height=src.height,ratioX=widthOut/width,ratioY=heightOut/height,array=[],out=[],data=src.data,coordinateX,coordinateY;
		//双线性插值
		for(var i=0;i<heightOut;i++){
			for(var j=0;j<widthOut;j++){
				coordinateX=j/ratioX;
				coordinateY=i/ratioY;
				iu=Math.floor(coordinateX);
				iv=Math.floor(coordinateY);
				if(0<=coordinateX&&coordinateX<width&&coordinateY>=0&&coordinateY<height){
					for(var k=0;k<4;k++)
					{
					array[0]=data[(iv*width+iu)*4];
					array[1]=data[(iv*width+iu+1)*4];
					array[2]=data[((iv+1)*width+iu)*4];
					array[3]=data[((iv+1)*width+iu+1)*4];
					out[(i*widthOut+j)*4+k]=interpolationLinear(array,coordinateX-iu,coordinateY-iv);
					}
					}
				else{
					for(var k=0;k<4;k++){
						out[(i*widthOut+j)*4+k]=data[(iv*widthOut+iu)*4+k];
						}
					}
				}
			}
		}
	}
	function zoomCube(src,widthOut,heightOut){
		if(src&&src.data){
			var width=src.width,height=src.height,data=src.data,ratioX=widthOut/width,ratioY=heightOut/height,coordinateX,coordinateY,array=[];
			//立方卷积插值
			for(var i=0;i<heightOut;i++){
				for(var j=0;j<widthOut;j++){
					coordinateX=j/ratioX;
					coordinateY=i/ratioY;
					iu=Math.floor(coordinateX);
					iv=Math.floor(coordinateY);
					if(1<=coordinateX&&coordinateX<width-2&&coordinateY>=1&&coordinateY<height-2){
						for(var k=0;k<4;k++){
							for(var y=iv-1;y<iv+3;y++){
								for(var x=iu-1;x<iu+3;x++){
									array[(y-iv+1)*4+x-iu+1]=data[(y*width+x)*4+k];
									}
								}
							out[(i*widthOut+j)*4+k]=interpolationCube(array,coordinateX-iu,coordinateY-iv);
							}
						}
						else{
							for(var k=0;k<4;k++){
								out[(i*widthOut+j)*4+k]=data[(iv*width+iu)*4+k];
								}
							}
					}
				}
			}
		}
	// 图像的旋转,对图像按顺时针旋转90度
	function clockWise(src){
		if(src&&src.data){
			var width=src.width,height=src.height,data=src.data,widthOut=height,heightOut=width,out=[];
			for(var i=0;i<heightOut;i++){
				for(var j=0;j<widthOut;j++){
					for(var k=0;k<4;k++){
						out[(i*widthOut+j)*4+k]=data[(j*width+width-1-i)*4+k];
						}
					}
				}
			}
		}
	//对图像按逆时针旋转90
	function antiClockWise(src){
		if(src&&src.data){
			var width=src.width,height=src.height,data=src.data,widthOut=height,heightOut=width,out=[];
			for(var i=0;i<heightOut;i++){
				for(var j=0;j<widthOut;j++){
					for(var k=0;k<4;k++){
						out[(i*widthOut+j)*4+k]=data[((height-1-j)*width+i)*4+k];
						}
					}
				}
			}
		}
	//对图像旋转180度
	function rotate180(src){
		if(src&&src.data){
			var width=src.width,height=src.height,data=src.data,widthOut=height,heightOut=width,out=[];
			for(var i=0;i<heightOut;i++){
				for(var j=0;j<widthOut;j++){
					for(var k=0;k<4;k++){
						out[(i*widthOut+j)*4+k]=data[((height-1-j)*width+i)*4+k];
						}
					}
				}
			}
		
		}
		function rotateAny(src,angle){
			if(src&&src.data){
				var width=src.width,height=src.height,widthOut,heightOut,data=src.data,out=[],angle=2*Math.PI*angle/360,fSrcX1,fSrcY1,fSrcX2,fSrcY2,fSrcX3,fSrcY3,fSrcX4,fSrcY4,fDstX1,fDstY1,fDstX2,fDstY2,fDstX3,fDstY3,fDstX4,fDstY4,Sin=Math.sin(angle),Cos=Math.cos(angle);
				//计算原图的四个角的坐标;
				fSrcX1=-(width-1)/2;
				fSrcY1=(height-1)/2;
				fSrcX2=(width-1)/2;
				fSrcY2=(height-1)/2;
				fSrcX3=-(width-1)/2;
				fSrcY3=-(height-1)/2;
				fSrcX4=(width-1)/2;
				fSrcY4=-(height-1)/2;
				//计算新图的四个角的坐标，以图像中心为坐标系原点
				fDstX1=Cos*fSrcX1+Sin*fSrcY1;
				fDstY1=-Sin*fSrcX1+Cos*fSrcY1;
				fDstX2=Cos*fSrcX2+Sin*fSrcY2;
				fDstY2=-Sin*fSrcX2+Cos*fSrcY2;
				fDstX3=Cos*fSrcX3+Sin*fSrcY3;
				fDstY3=-Sin*fSrcX3+Cos*fSrcY3;
				fDstX4=Cos*fSrcX4+Sin*fSrcY4;
				fDstY4=-Sin*fSrcX4+Cos*fSrcY4;
				widthOut=Math.max(Math.abs(fDstX4-fDstX1),Math.abs(fDstX3-fDstX2))+.5;
				heightOut=Math.max(Math.abs(fDstY4-fDstY1),Math.abs(fDstY3-fDstY2))+.5;
				var f1,f2,coordinateX,coordinateY;
				f1=-.5*(widthOut-1)*Cos+.5*(heightOut-1)*Sin+.5*(width-1);
				f2=-.5*(widthOut-1)*Sin-.5*(heightOut-1)*Cos+.5*(height-1);
				for(var i=0;i<heightOut;i++){
					for(var j=0;j<widthOut;j++){
						coordinateX=Math.floor(j*Cos-i*Sin+f1+.5);
						coordinateY=Math.floor(j*Sin+i*Cos+f2+.5);
						if(coordinateX>=0&&coordinateX<width&&coordinateY>=0&&coordinateY<height){
							for(var k=0;k<4;k++){
								out[(i*widthOut+j)*4+k]=data[(coordinateY*width+coordinateX)*4+k];
								}
							}
						else{
							for(var k=0;k<4;k++){
								out[(i*widthOut+j)*4+k]=255;
								}
							}
						}
					}
				}
			}
	//采用双线性插值法
	function rotateDbLinear(src,angle){
		if(src&&src.data){
			var width=src.width,height=src.height,widthOut,heightOut,data=src.data,out=[],angle=2*Math.PI*angle/360,fSrcX1,fSrcY1,fSrcX2,fSrcY2,fSrcX3,fSrcY3,fSrcX4,fSrcY4,fDstX1,fDstY1,fDstX2,fDstY2,fDstX3,fDstY3,fDstX4,fDstY4,Sin=Math.sin(angle),Cos=Math.cos(angle);
		//计算原图的四个角的坐标;
				fSrcX1=-(width-1)/2;
				fSrcY1=(height-1)/2;
				fSrcX2=(width-1)/2;
				fSrcY2=(height-1)/2;
				fSrcX3=-(width-1)/2;
				fSrcY3=-(height-1)/2;
				fSrcX4=(width-1)/2;
				fSrcY4=-(height-1)/2;
				//计算新图的四个角的坐标，以图像中心为坐标系原点
				fDstX1=Cos*fSrcX1+Sin*fSrcY1;
				fDstY1=-Sin*fSrcX1+Cos*fSrcY1;
				fDstX2=Cos*fSrcX2+Sin*fSrcY2;
				fDstY2=-Sin*fSrcX2+Cos*fSrcY2;
				fDstX3=Cos*fSrcX3+Sin*fSrcY3;
				fDstY3=-Sin*fSrcX3+Cos*fSrcY3;
				fDstX4=Cos*fSrcX4+Sin*fSrcY4;
				fDstY4=-Sin*fSrcX4+Cos*fSrcY4;
				widthOut=Math.max(Math.abs(fDstX4-fDstX1),Math.abs(fDstX3-fDstX2))+.5;
				heightOut=Math.max(Math.abs(fDstY4-fDstY1),Math.abs(fDstY3-fDstY2))+.5;
				var f1,f2,coordinateX,coordinateY,array=[],iu,iv;
				f1=-.5*(widthOut-1)*Cos+.5*(heightOut-1)*Sin+.5*(width-1);
				f2=-.5*(widthOut-1)*Sin-.5*(heightOut-1)*Cos+.5*(height-1);
				for(var i=0;i<heightOut;i++){
					for(var j=0;j<widthOut;j++){
						coordinateX=Math.floor(j*Cos-i*Sin+f1+.5);
						coordinateY=Math.floor(j*Sin+i*Cos+f2+.5);
						iu=Math.floor(coordinateX);
						iv=Math.floor(coordinateY);
						//判断是否在原图像内
						if(coordinateX>=0&&coordinateX<width-1&&coordinateY>=0&&coordinateY<height-1){
							for(var k=0;k<4;k++){
								array[0]=data[(iv*width+iu)*4+k];
								array[1]=data[(iv*width+iu+1)*4+k];
								array[2]=data[((iv+1)*width+iu)*4+k];
								array[3]=data[((iv+1)*width+iu+1)*4+k];
								out[(i*widthOut+j)*4+k]=interpolationLinear(array,coordinateX-iu,coordinateY-iv);
								}
							}
						else{
							for(var k=0;k<4;k++){
								out[(i*widthOut+j)*4+k]=255;
								}
							}
					}
					}
			}
		}
	//立方卷积插值法
	function rotateCube(src,angle){
		if(src&&src.data){
			var width=src.width,height=src.height,widthOut,heightOut,data=src.data,out=[],angle=2*Math.PI*angle/360,fSrcX1,fSrcY1,fSrcX2,fSrcY2,fSrcX3,fSrcY3,fSrcX4,fSrcY4,fDstX1,fDstY1,fDstX2,fDstY2,fDstX3,fDstY3,fDstX4,fDstY4,Sin=Math.sin(angle),Cos=Math.cos(angle);
		//计算原图的四个角的坐标;
				fSrcX1=-(width-1)/2;
				fSrcY1=(height-1)/2;
				fSrcX2=(width-1)/2;
				fSrcY2=(height-1)/2;
				fSrcX3=-(width-1)/2;
				fSrcY3=-(height-1)/2;
				fSrcX4=(width-1)/2;
				fSrcY4=-(height-1)/2;
				//计算新图的四个角的坐标，以图像中心为坐标系原点
				fDstX1=Cos*fSrcX1+Sin*fSrcY1;
				fDstY1=-Sin*fSrcX1+Cos*fSrcY1;
				fDstX2=Cos*fSrcX2+Sin*fSrcY2;
				fDstY2=-Sin*fSrcX2+Cos*fSrcY2;
				fDstX3=Cos*fSrcX3+Sin*fSrcY3;
				fDstY3=-Sin*fSrcX3+Cos*fSrcY3;
				fDstX4=Cos*fSrcX4+Sin*fSrcY4;
				fDstY4=-Sin*fSrcX4+Cos*fSrcY4;
				widthOut=Math.max(Math.abs(fDstX4-fDstX1),Math.abs(fDstX3-fDstX2))+.5;
				heightOut=Math.max(Math.abs(fDstY4-fDstY1),Math.abs(fDstY3-fDstY2))+.5;
				var f1,f2,coordinateX,coordinateY,array=[],iu,iv;
				f1=-.5*(widthOut-1)*Cos+.5*(heightOut-1)*Sin+.5*(width-1);
				f2=-.5*(widthOut-1)*Sin-.5*(heightOut-1)*Cos+.5*(height-1);
				for(var i=0;i<heightOut;i++){
					for(var j=0;j<widthOut;j++){
						iu=Math.floor(coordinateX);
						iv=Math.floor(coordinateY);
						if(coordinateX>=1&&coordinateX<width-3&&coordinateY>=1&&coordinateY<height-3){
							for(var k=0;k<4;k++){
								for(var y=iv-1;y<iv+3;y++){
									for(var x=iu-1;x<iu+3;x++){
										array[(y-iv+1)*4+x-iu+1]=data[(y*width+x)*4+k];
										}
									}
									out[(i*widthOut+j)*4+k]=interpolationCube(array,coordinateX-iu,coordinateY-iv);
								}
							}
						else{
							for(var k=0;k<4;k++){
								out[(i*widthOut+j)*4+k]=255;
								}
							}
					}
				}
			}
		}
//  图像缩放
// 一维快速傅里叶变换  complex  imaginary
function fft(array){
	if(array instanceof Array&&array.length>0){
		//若0,1,2,3,4,5,6,7八点序列对调后变为04261537；
		var t1,t2,len=array.length,out=[];
		for(var i=0;i<len;i++){
			out[i]=array[i].clone();
			}
		for(var r=1;Math.pow(2,r)<len;r++){
			t1=Math.pow(2,r),t2=Math.pow(2,r-1);
			for(var k=0;k<t1;k++){
				for(var i=0;i<len/t1;i++){
					out[k*n/t1+i].real=array[k/2*n/t2+i*2+k%2].real;
					out[k*n/t1+i].imaginary=array[k/2*n/t2+i*2+k%2].imaginary;		
					}
				}
			}
			for(var i=0;i<out.length;i++){
				array[i]=out[i].clone();
				}
		//采用蝶形算法进行快速傅里叶变化
		for(var r=1;Math.pow(2,r);r++){
			t1=Math.pow(2,r);
			for(var k=0;k<n/t1;k++){
				for(var i=t1/2;i<t1;i++){
					//加权因子
					c=Math.cos(-2*Math.PI*(i-t1/2)/t1);
					s=Math.sin(-2*Math.PI*(i-t1/2)/t1);
					out[k*t1+i].real=array[k*t1+i].real*c-array[k*t1+i].imaginary*s;
					out[k*t1+i].imaginary=array[k*t1+i].imaginary*c+array[k*t1+i].real*s;
					}
				}
			for(var k=0;k<n/t1;k++){
				for(var i=0;i<t1/2;i++){
					array[k*t1+i].real=out[k*t1+i].real+out[k*t1+i+t1/2].real;
					array[k*t1+i].imaginary=out[k*t1+i].imaginary+out[k*t1+i+t1/2].imaginary;
					}
				for(var i=t1/2;i<t1;i++){
					array[k*t1+i].real=out[k*t1+i-t1/2].real-out[k*t1+i].real;
					array[k*t1+i].imaginary=out[k*t1+i-t1/2].imaginary-out[k*t1+i].imaginary;
					}
				}
			for(var i=0;i<array.length;i++){
				out[i]=array[i].clone();
				}
			}
			return out.slice(0);
		}
	}
//一维快速傅里叶变换 
function ifft(array){
	var len=array.length;
	for(var i=0;i<len;i++){
		array[i].imaginary=-array[i].imaginary;
		}
	fft(array);
	for(var i=0;i<len;i++){
		array[i].real=array[i].real/len;
		array[i].imaginary=-array[i].imaginary/len;
		}
	}
function zoom(src,w,h,type){
	var x=0,y=0,width,height,data,halfWidth,halfHeight,grayValue=[];
	if(type!=1&&type!=2){
		type=1;
		}
	if(src&&src.data){
		data=src.data;
		width=src.width;
		height=src.height;
		halfWidth=Math.floor(width/2);
		halfHeight=Math.floor(height/2);
		x=(+w).toFixed(2);
		y=(+h).toFixed(2);
		grayValue=grayValues(src);
		var xz=0,yz=0,tempWidth=0,tempHeight=0,tempArray=[];
		switch(type)
		{
		case 1:
		for(var i=0;i<width;i++){
			for(var j=0;j<height;j++){
				tempHeight=i-halfHeight;
				tempWidth=j-halfWidth;
				//在不同象限进行四舍五入处理
				if(tempWidth>0){
					xz=Math.ceil(tempWidth/x+.5);
					}
				else{
					xz=Math.ceil(tempWidth/x-.5);
					}
				if(tempHeight>0){
					yz=Math.ceil(tempHeight/x+.5);
					}
				else{
					yz=Math.ceil(tempHeight/x-.5);
					}
				//坐标里逆变化
				tempWidth=xz+halfWidth;
				tempHeight=yz+halfHeight;
				if(tempWidth<0||tempWidth>=width||tempHeight<0||tempHeight>height){
					tempArray[i*width+j]=255;
					}
				else{
					tempArray[i*width+j]=grayValue[tempHeight*width+tempWidth];
					}
				}
			}
		case 2:
		//双线性插入
		var tempX,tempY,p,q;
		for(var i=0;i<width;i++){
			for(var j=0;j<height;j++){
				tempHeight=i-halfHeight;
				tempWidth=j-halfWidth;
				tempX=tempWidth/x;
				tempY=tempHeight/y;
				//在不同象限进行取整处理
				if(tempWidth>0){
					xz=Math.ceil(tempX);
					}
				else{
					xz=Math.ceil(tempX-1);
					}
				if(tempHeight>0){
					yz=Math.ceil(tempY);
					}
				else{
					yz=Math.ceil(tempY-1);
					}
				p=tempX-xz;
				q=tempY-yz;
				//坐标逆变换
				tempWidth=xz+halfWidth;
				tempHeight=yz+halfHeight;
				if(tempWidth<0||(tempWidth+1)>=width||tempHeight<0||(tempHeight+1)>=height){
					tempArray[i*width+j]=255;
					}
				else{
					tempArray[i*width+j]=(1-q)*((1-p)*grayValue[tempHeight*width+tempWidth]+p*grayValue[tempHeight*width+tempWidth+1])+q*((1-p)*grayValue[(tempHeight+1)*width+tempWidth]+p*grayValue[(tempHeight+1)*width+tempWidth+1]);
					}
				}
			}
	}
	return grayValues=tempArray;
	}
	}
//  图像旋转
function rotation(src,degree){
	if(src&&src.data)
	{
	var degree=degree*Math.PI/180;
	var sin=Math.sin(degree);
	var cos=Math.cos(degree);
	var width=src.width;
	var height=src.height;
	var halfWidth=Math.floor((+width)/2);
	var halfHeight=Math.floor((+height)/2);
	var xz=0,yz=0,tempWidth=0,tempHeight=0,tempArray=[],grayValue=[],tempX,tempY,p,q;
	grayValue=grayValues(src);
	//双线性插值旋转
	for(var i=0;i<width;i++){
		for(var j=0;j<height;j++){
			tempHeight=i-halfHeight;
			tempWidth=j-halfWidth;
			tempX=tempWidth*cos-tempHeight*sin;
			tempY=tempWidth*sin+tempHeight*cos;
			//在不同象限取整处理
			if(tempWidth>0){
				xz=Math.ceil(tempX);
				}
			else{
				xz=Math.ceil(tempX-1);
				}
			if(tempHeight>0){
				yz=Math.ceil(tempY);
				}
			else{
				yz=Math.ceil(tempY-1);
				}
			p=tempX-xz;
			q=tempY-yz;
			tempWidth=xz+halfWidth;
			tempHeight=yz+tempHeight;
			if(tempWidth<0||(tempWidth+1)>=width||tempHeight<0||(tempHeight+1)>=height){
				tempArray[i*width+j]=255;
				}
			else{
				tempArray[i*width+j]=(1-q)*((1-p)*grayValue[tempHeight*width+tempWidth]+p*grayValue[tempHeight*width+tempWidth+1])+q*((1-p)*grayValue[tempHeight*width+tempWidth]+p*grayValue[(tempHeight+1)*width+tempWidth+1]);
				}
			}
		}
		return grayValue=tempArray;
	}
}
// 图像腐蚀算法
function erode(src,type){
	if(src&&src.data){
		var width=src.width,height=src.height;
		var total=width*height,grayValue=grayValues(src),tempArray=[];
		if(!type&&type!==0){
			type=0;
			}
		switch(type){
			case 0:
			//3位水平方向的结构元素	
			for(var i=0;i<height;i++){
				for(j=1;j<width-1;j++){
					if(grayValue[i*width+j]==0&&grayValue[i*width+j+1]==0&&grayValue[i*width+j-1]==0){
						tempArray[i*width+j]=0;
						}
					}
				}
			
			
			break;
			case 1:
			//5位水平方向的结构元素
			for(var i=0;i<height;i++){
				for(j=2;j<width-2;j++){
					if(grayValue[i*width+j]==0&&grayValue[i*width+j+1]==0&&grayValue[i*width+j-1]==0&&grayValue[i*width+j+2]==0&&grayValue[i*width+j-2]==0){
						tempArray[i*width+j]=0;
						}
					}
				}
			break;
			case 2:
				//3位垂直方向的结构元素	
			for(var i=1;i<height-1;i++){
				for(var j=0;j<width;j++){
					if(grayValue[i*width+j]==0&&grayValue[(i+1)*width+j]==0&&grayValue[(i-1)*width+j]==0){
						tempArray[i*width+j]=0;
						}
					}
				}
				break;
				case 3:
				//3位垂直方向的结构元素	
				for(var i=2;i<height-2;i++){
					for(var j=0;j<width;j++){
						if(grayValue[i*width+j]==0&&grayValue[(i+1)*width+j]==0&&grayValue[(i-1)*width+j]==0&&grayValue[(i+2)*width+j]==0&&grayValue[(i-2)*width+j]==0){
							tempArray[i*width+j]=0;
							}
						}
					}
					break;
					case 4:
					//3位十字形状结构元素
					for(var i=1;i<height-1;i++){
						for(var j=1;j<width-1;j++){
							if(grayValue[i*width+j]==0&&grayValue[(i+1)*width+j]==0&&grayValue[(i-1)*width+j]==0&&grayValue[i*width+j-1]==0&&grayValue[i*width+j+1]==0){
								tempArray[i*width+j]=0;
								}
							}
						}
					break;
					case 5:
					//5位十字结构元素
					for(var i=2;i<height-2;i++){
						for(var j=2;j<width-2;j++){
							if(grayValue[i*width+j]==0&&grayValue[(i+1)*width+j]==0&&grayValue[(i-1)*width+j]==0&&grayValue[i*width+j-1]==0&&grayValue[i*width+j+1]==0&&grayValue[(i+2)*width+j]==0&&grayValue[(i-2)*width+j]==0&&grayValue[i*width+j-2]==0&&grayValue[i*width+j+2]==0){
								tempArray[i*width+j]=0;
								}
							}
						}
					case 6:
					//3位方形结构元素
					for(var i=1;i<height-1;i++){
						for(var j=1;j<width-1;j++){
							if(grayValue[i*width+j+1]==0&&grayValue[i*width+j-1]==0&&grayValue[(i-1)*width+j]==0&&grayValue[(i+1)*width+j]==0&&grayValue[(i-1)*width+j-1]==0&&grayValue[(i+1)*width+j+1]==0&&grayValue[(i+1)*width+j-1]==0&&grayValue[(i-1)*width+j+1]==0){
								tempArray[i*width+j]=0;
								}
							}
						}
						break;
					case 7:
					//3位方形结构元素
					for(var i=2;i<width-2;i++){
						for(var j=2;j<height-2;j++){
							if(grayValue[i*width+j+1]==0&&grayValue[i*width+j-1]==0&&grayValue[(i-1)*width+j]==0&&grayValue[(i+1)*width+j]==0&&grayValue[(i-1)*width+j-1]==0&&grayValue[(i+1)*width+j+1]==0&&grayValue[(i+1)*width+j-1]==0&&grayValue[(i-1)*width+j+1]==0&&grayValue[i*width+j+2]==0&&grayValue[i*width+j-2]==0&&grayValue[(i-2)*width+j]==0&&grayValue[(i+2)*width+j]==0&&grayValue[(i-2)*width+j-2]==0&&grayValue[(i+2)*width+j+2]==0&&grayValue[(i+2)*width+j-2]==0&&grayValue[(i-2)*width+j+2]==0&&grayValue[(i-2)*width+j+1]==0&&grayValue[(i-2)*width+j-1]==0&&grayValue[(i+2)*width+j+1]==0&&grayValue[(i+2)*width+j-1]==0&&grayValue[(i-1)*width+j+2]==0&&grayValue[(i-1)*width+j+2]==0&&grayValue[(i+1)*width+j-2]==0&&grayValue[(i+1)*width+j+2]==0){
								tempArray[i*width+j]=0;
								}
							}
						}
		}
		return (grayValue=tempArray);
		}
	}
//图像膨胀定理
function erode1(src,type){
	if(src&&src.data){
		if(!type&&type!=0){
			type=0;
			}
		var grayValue=grayValues(src),width=src.width,height=src.height,tempArray=[];
		switch(type){
			case 0:
			for(var i=0;i<height;i++){
				for(j=1;j<width-1;j++){
					if(grayValue[i*width+j]==0||grayValue[i*width+j+1]==0||grayValue[i*width+j-1]==0){
						tempArray[i*width+j]=0;
						}
					}
				}
			
			
			break;
		case 1:
			//5位水平方向的结构元素
			for(var i=0;i<height;i++){
				for(j=2;j<width-2;j++){
					if(grayValue[i*width+j]==0||grayValue[i*width+j+1]==0||grayValue[i*width+j-1]==0||grayValue[i*width+j+2]==0||grayValue[i*width+j-2]==0){
						tempArray[i*width+j]=0;
						}
					}
				}
			break;
			case 2:
				//3位垂直方向的结构元素	
			for(var i=1;i<height-1;i++){
				for(var j=0;j<width;j++){
					if(grayValue[i*width+j]==0||grayValue[(i+1)*width+j]==0||grayValue[(i-1)*width+j]==0){
						tempArray[i*width+j]=0;
						}
					}
				}
				break;
				case 3:
				//3位垂直方向的结构元素	
				for(var i=2;i<height-2;i++){
					for(var j=0;j<width;j++){
						if(grayValue[i*width+j]==0||grayValue[(i+1)*width+j]==0||grayValue[(i-1)*width+j]==0||grayValue[(i+2)*width+j]==0||grayValue[(i-2)*width+j]==0){
							tempArray[i*width+j]=0;
							}
						}
					}
					break;
				case 4:
					//3位十字形状结构元素
					for(var i=1;i<height-1;i++){
						for(var j=1;j<width-1;j++){
							if(grayValue[i*width+j]==0||grayValue[(i+1)*width+j]==0||grayValue[(i-1)*width+j]==0||grayValue[i*width+j-1]==0||grayValue[i*width+j+1]==0){
								tempArray[i*width+j]=0;
								}
							}
						}
					break;
					case 5:
					//5位十字结构元素
					for(var i=2;i<height-2;i++){
						for(var j=2;j<width-2;j++){
							if(grayValue[i*width+j]==0||grayValue[(i+1)*width+j]==0||grayValue[(i-1)*width+j]==0||grayValue[i*width+j-1]==0||grayValue[i*width+j+1]==0||grayValue[(i+2)*width+j]==0||grayValue[(i-2)*width+j]==0||grayValue[i*width+j-2]==0||grayValue[i*width+j+2]==0){
								tempArray[i*width+j]=0;
								}
							}
						}
					case 6:
					//3位方形结构元素
					for(var i=1;i<height-1;i++){
						for(var j=1;j<width-1;j++){
							if(grayValue[i*width+j+1]==0||grayValue[i*width+j-1]==0||grayValue[(i-1)*width+j]==0||grayValue[(i+1)*width+j]==0||grayValue[(i-1)*width+j-1]==0||grayValue[(i+1)*width+j+1]==0||grayValue[(i+1)*width+j-1]==0||grayValue[(i-1)*width+j+1]==0){
								tempArray[i*width+j]=0;
								}
							}
						}
						break;
					case 7:
					//3位方形结构元素
					for(var i=2;i<width-2;i++){
						for(var j=2;j<height-2;j++){
							if(grayValue[i*width+j+1]==0||grayValue[i*width+j-1]==0||grayValue[(i-1)*width+j]==0||grayValue[(i+1)*width+j]==0||grayValue[(i-1)*width+j-1]==0||grayValue[(i+1)*width+j+1]==0||grayValue[(i+1)*width+j-1]==0||grayValue[(i-1)*width+j+1]==0||grayValue[i*width+j+2]==0||grayValue[i*width+j-2]==0||grayValue[(i-2)*width+j]==0||grayValue[(i+2)*width+j]==0||grayValue[(i-2)*width+j-2]==0||grayValue[(i+2)*width+j+2]==0||grayValue[(i+2)*width+j-2]==0||grayValue[(i-2)*width+j+2]==0||grayValue[(i-2)*width+j+1]==0||grayValue[(i-2)*width+j-1]==0||grayValue[(i+2)*width+j+1]==0||grayValue[(i+2)*width+j-1]==0||grayValue[(i-1)*width+j+2]==0||grayValue[(i-1)*width+j+2]==0||grayValue[(i+1)*width+j-2]==0||grayValue[(i+1)*width+j+2]==0){
								tempArray[i*width+j]=0;
								}
							}
						}
			}
			return grayValue=tempArray;
		}
	}
function complex(real,imaginary){
	this.real=real||0;
	this.imaginary=imaginary||0;
	this.Real=function(real){
		if(real!=null){
			this.real=real;
			return this;
			}
		else{
			return this.real;
			}
		}
	this.Imaginary=function(imaginary){
		if(imaginary!=null){
			this.imaginary=imaginary;
			return this;
			}
		else{
			return this.imaginary;
			}
		}
	this.addSelf=function(src){
		if(src&&src.real!=null){
			this.real+=src.real;
			this.imaginary+=src.imaginary;
			}
		else if(!isNaN(src)){
			this.real+=src;
			this.imaginary+=src;
			}
		return this;
		}
	this.add=function(src){
		if(src&&src.real!=null){
			var x=this.real+src.real;
			var y=this.imaginary+src.imaginary;
			return new complex(x,y);
			}
		else if(!isNaN(src)){
			var x=this.real+src;
			var y=this.imaginary+src;
			return new complex(x,y);
			}
		else{
			return new complex(this.real,this.imaginary);
			}
		}
	this.subtractSelf=function(src){
		if(src&&src.real!=null){
			this.real-=src.real;
			this.imaginary-=src.imaginary;
			}
		else if(!isNaN(src)){
			this.real-=src;
			this.imaginary-=src;
			}
		return this;
		}
	this.subtract=function(src){
		var x,y;
		if(src&&src.real!=null){
			x=this.real-src.real;
			y=this.imaginary-src.imaginary;
			}
		else if(!isNaN(src)){
			x=this.real-src;
			y=this.imaginary-src;
			}
		else{
			x=this.real;
			y=this.imaginary;
			}
		return new complex(x,y);
		}
		this.multiplySelf=function(src){
			if(src&&src.real!=null){
				this.real*src.real;
				this.imaginary*src.imaginary;
				}
			else if(!isNaN(src)){
				this.real*=src;
				this.imaginary*=src;
				}
			return this;
			}
		this.multiply=function(src){
			var x,y;
			if(src&&src.real!=null){
				x=this.real*src.real;
				y=this.imaginary*src.imaginary;
				}
			else if(!isNaN(src)){
				x=this.real*src;
				y=this.imaginary*src;
				}
			else{
				x=this.real;
				y=this.imaginary;
				}
			return new complex(x,y);
			}
		this.Abs=function(src){
			//取得实部的绝对值
			var x=Math.abs(this.real);
			var y=Math.abs(this.imaginary);
			if(this.real==0){
				return y;
				}
			if(this.imaginary==0){
				return x;
				}
				
			if(x>y){
				return (x*Math.sqrt(1+(y/x)*(y/x)));
				}
			else{
				return (y*Math.sqrt(1+(x/y)*(x/y)));
				}
			}
		this.angle=function(){
			if(this.real==0&&this.imaginary==0){
				return 0;
				}
			if(this.real==0){
				if(this.imaginary>0){
					return Math.PI/2;
					}
				else{
					return -Math.PI/2;
					}
				}
			else{
				if(this.real>0){
					return Math.atan2(this.imaginary,this.real);
					}
				else{
					if(this.imaginary>0){
						return Math.atan2(this.imaginary,this.real)+Math.PI;
						}
					else{
						return Math.atan2(this.imaginary,this.real)-Math.PI;
						}
					}
				}
			}
		this.conjugate=function(){
			return new complex(this.real,-this.imaginary);
			}
		this.clone=function(){
			return new complex(this.real,this.imaginary);
			}
	}
function fft(sourceData,countN){
	if(sourceData&&sourceData.length>0)
	{
	var r=Math.round(Math.log(countN)/Math.LN2);
	var w=[],interVal1=[];interVal2=[];
	interVal1=sourceData.slice(0);
	//求加权系数w
	for(var i=0;i<countN/2;i++){
		var angle=-i*Math.PI*2/countN;
		w[i]=new complex(Math.cos(angle),Math.sin(angle))
		}
	//蝶形运算
	for(var i=0;i<r;i++){
		var interval=1<<i;
		var halfN=1<<(r-i);
		//对每一级的每一组点循环
		for(var j=0;j<interval;j++){
				var gap=j*halfN;
					for(var k=0;k<halfN/2;k++){
						// 进行蝶形运算
						interVal2[k+gap]=interVal1[k+gap]+interVal1[k+gap+halfN/2];
						interVal2[k+interVal2/2+gap]=(interVal1[k+gap]-interVal1[k+gap+halfN/2])*w[k*interval];
						}
			}
			interVal1=interVal2.slice(0);
		}
		for(var j=0;j<countN;j++){
			var rev=0;
			var num=j;
			for(var i=0;i<r;i++){
				rev<<=1;
				rev|=num&1;
				num>>=1;
				}
			interVal2[rev]=interVal1[j];
			}
			return interVal2;
	}
	}
function ifft(sourceData,countN){
	if(sourceData&&sourceData.length>0){
		//共轭变换
		for(var i=0;i<countN;i++){
			sourceData[i]=sourceData[i].conjugate();
			}
		var interVal=fft(sourceData,countN);
		// 共轭变换，并除以长度。
		for(var i=0;i<countN;i++){
			interVal[i]=new complex(interVal[i].real/countN,-interVal[i].imaginary/countN);
			}
		return interVal;
		}
	}
// 二位快速傅里叶变换
function fft2(imageDate,imageWidth,imageHeight,inv){
	var bytes=imageWidth*imageHeight;
	var bmpValues=[],tempCom1=[];
	bmpValues=imageDate.slice(0);
	//赋值：把实数变为复数，即虚部为0
	for(var i=0;i<bytes;i++){
		if(inv==true){
			//进行频域坐标位移
			if((i/imageWidth+i%imageWidth)%2==0){
				tempCom1[i]=new complex(bmpValues[i],0);
				}
			else{
				tempCom1[i]=new complex(-bmpValues[i],0);
				}
			}
			else{
				//不进行频域坐标位移
				tempCom1[i]=new complex(bmpValues[i],0);
				}
		}
		//水平方向进行傅里叶变换
		var tempCom2=[],tempCom3=[];
		for(var i=0;i<imageHeight;i++){
			//得到水平方向上的复数序列
			for(var j=0;j<imageWidth;j++){
				tempCom2[j]=tempCom1[i*imageWidth+j];
				}
			//调用以为傅里叶变换
			tempCom3=fft(tempCom2,imageWidth);
			//把结果赋值回去
			for(var j=0;j<imageWidth;j++){
				tempCom1[i*imageWidth+j]=tempCom3[j];
				}
			}
		tempCom4=[],tempCom5=[];
		for(var i=0;i<imageWidth;i++){
			//得到垂直方向复数序列
			for(var j=0;j<imageHeight;j++){
				tempCom4[j]=tempCom1[j*imageWidth+i];
				}
			//调用一维傅里叶变换
			tempCom5=fft(tempCom4,imageHeight);
			//把结果赋值回去
			for(var j=0;j<imageHeight;j++){
				tempCom1[j*imageHeight+i]=tempCom5[j];
				}
			}
		return tempCom1;
	}
//二维快速傅里叶变换
function ifft2(freData,imageWidth,imageHeight,inv){
	var bytes=imageWidth*imageHeight,bmpValues=[],tempCom1=freData.slice(0),bmpValues=[],tempCom2=[],tempCom3=[];
	for(var i=0;i<imageHeight;i++){
		//得到水平方向复数序列
		for(var j=0;j<imageWidth;j++){
			tempCom2[j]=tempCom1[i*imageWidth+j];
			}
		//调用一维傅里叶变换
		tempCom3=ifft(tempCom2,imageWidth);
		//把结果赋值回去
		for(var j=0;j<imageWidth;j++){
			tempCom1[i*imageWidth+j]=tempCom3[j];
			}
		}
		var tempCom4=[],tempCom5=[];
		for(var i=0;i<imageWidth;i++){
			//得到垂直方向复数序列
			for(var j=0;j<imageHeight;j++){
				tempCom4[j]=tempCom1[j*imageWidth+i];
				}
			//调用一维傅里叶变换
			tempCom5=ifft(tempCom4,imageHeight);
			//把结果赋值回去
			for(var j=0;j<imageHeight;j++){
				tempCom1[j*imageWidth+i]=tempCom5[j];
				}
			}
			// 赋值：把复数转换为实数，只保留复数的实数部分
			var tempDouble;
			for(var i=0;i<bytes;i++){
				if(inv==true){
					//进行坐标位移
					if((i/imageWidth+i%imageWidth)%2==0){
						tempDouble=tempCom1[i].real;
						}
					else{
						tempDouble=-tempCom1[i].real;
						}
					}
				else{
					//不进行坐标位移
					tempDouble=tempCom1[i].real;
					}
				if(tempDouble>255){
					bmpValues[i]=255;
					}
				else{
					if(tempDouble<0){
						bmpValues[i]=0;
						}
					else{
						bmpValues[i]=tempDouble;
						}
					}
				}
				return bmpValues;
	}
//幅度图像和相位图像
function amplitude(src){
	if(src&&src.data){
		var width=src.width,height=src.heigth;grayValue=grayValues(src),freDom=[],tempArray=[],bytes=width*height;
		//调用二维傅里叶变换，需要进行坐标位移。、
		freDom=fft2(grayValue,width,height,true);
		//变量变换，并取幅度系数
		for(var i=0;i<bytes;i++){
			tempArray[i]=Math.log(1+freDom[i].Abs())/Math.LN2;
			}
		//灰度拉伸,并取幅度系数
		var a=1000,b=0,p;
		//找到最大值和最小值
		for(var i=0;i<bytes;i++){
			if(a>tempArray[i]){
				a=tempArray[i];
				}
			if(b<tempArray[i]){
				b=tempArray[i];
				}
			}
		//得到比例系数
		p=255/(b-a);
		for(var i=0;i<bytes;i++){
			grayValue[i]=p*(tempArray[i]-a)+.5;
			}
		return grayValue;
		}
	}
//相位变换
function phase(src){
	if(src&&src.data){
		var width=src.width,height=src.height,bytes=width*height,grayValue=grayValues(src),freDom=fft2(grayValue,width,height,true),tempArray=[];
		for(var i=0;i<bytes;i++){
			tempArray[i]=Math.log(1+freDom(i).angle())+2*Math.PI;
			}
		//灰度拉伸
		var a=1000,b=0,p;
		//找到最大值和最小值
		for(var i=0;i<bytes;i++){
			if(a>tempArray[i]){
				a=tempArray[i];
				}
			if(b<tempArray[i]){
				b=tempArray[i];
				}
			}
		//得到比例系数
		p=255/(b-a);
		for(var i=0;i<bytes;i++){
			grayValue[i]=(p*tempArray[i]-a)+.5;
			}
		return grayValue;
		}
	}
function fft(dataArray) {
    // 复数乘法
    this.mul = function(a, b) {
        if(typeof(a)!=='object') {
            a = {real: a, imag: 0}
        }
        if(typeof(b)!=='object') {
            b = {real: b, imag: 0}
        }
        return {
            real: a.real*b.real-a.imag*b.imag,
            imag: a.real*b.imag+a.imag*b.real
        };
    };

    // 复数加法
    this.add = function(a, b) {
        if(typeof(a)!=='object') {
            a = {real: a, imag: 0}
        }
        if(typeof(b)!=='object') {
            b = {real: b, imag: 0}
        }
        return {
            real: a.real+b.real,
            imag: a.imag+b.imag
        };
    };

    // 复数减法
    this.sub = function(a, b) {
        if(typeof(a)!=='object') {
            a = {real: a, imag: 0}
        }
        if(typeof(b)!=='object') {
            b = {real: b, imag: 0}
        }
        return {
            real: a.real-b.real,
            imag: a.imag-b.imag
        };
    };

    // 倒位序排列
    this.sort = function(data, r) {
        if(data.length <=2) {
            return data;
        }
        var index = [0,1];
        for(var i=0; i<r-1; i++) {
            var tempIndex = [];
            for(var j=0; j<index.length; j++) {
                tempIndex[j] = index[j]*2;
                tempIndex[j+index.length] = index[j]*2+1;
            }
            index = tempIndex;
        }
        var datatemp = [];
        for(var i=0; i<index.length; i++) {
            datatemp.push(data[index[i]]);
        }
        return datatemp;
    };

    var dataLen = dataArray.length;
    var r = 1; // 迭代次数
    var i = 1;
    while(i*2 < dataLen) {
        i *= 2;
        r++;
    }
    var count = 1<<r; // 相当于count=2^r

    // 如果数据dataArray的长度不是2^N，则开始补0
    for(var i=dataLen; i<count; i++) {
        dataArray[i] = 0;
    }

    // 倒位序处理
    dataArray = this.sort(dataArray, r);

    // 计算加权系数w
    var w = [];
    for(var i=0; i<count/2; i++) {
        var angle = -i*Math.PI*2/count;
        w.push({real: Math.cos(angle), imag: Math.sin(angle)});
    }

    for(var i=0; i<r; i++) { // 级循环
        var group = 1<<(r-1-i);
        var distance = 1<<i;
        var unit = 1<<i;
        for(var j=0; j<group; j++) { // 组循环
            var step = 2*distance*j;
            for(var k=0; k<unit; k++) { // 计算单元循环
                var temp = this.mul(dataArray[step+k+distance], w[count*k/2/distance]);
                dataArray[step+k+distance] = this.sub(dataArray[step+k], temp);
                dataArray[step+k] = this.add(dataArray[step+k], temp);
            }
        }
    }
    return dataArray;
}
//上面是一维快速傅里叶的算法，快速傅里叶变换的逆变换用JavaScript实现的完整代码如下：

function ifft(dataArray) {
    for(var i=0, dataLen=dataArray.length; i<dataLen; i++) {
        if(typeof(dataArray[i])!='object'){
            dataArray[i] = {
                real: dataArray[i],
                imag: 0
            }
        }
        dataArray[i].imag *= -1;
    }
    dataArray = fft(dataArray);
    for(var i=0, dataLen=dataArray.length; i<dataLen; i++) {
        dataArray[i].real *= 1/dataLen;
        dataArray[i].imag *= -1/dataLen;
    }
    return dataArray;
}
function fft2(dataArray, width, height) {
    var r = 1;
    var i = 1;
    while(i*2 < width) {
        i *= 2;
        r++;
    }
    var width2 = 1<<r;
    var r = 1;
    var i = 1;
    while(i*2 < height) {
        i *= 2;
        r++;
    }
    var height2 = 1<<r;

    var dataArrayTemp = [];
    for(var i=0; i<height2; i++) {
        for(var j=0; j<width2; j++) {
            if(i>=height || j>=width) {
                dataArrayTemp.push(0);
            }
            else {
                dataArrayTemp.push(dataArray[i*width+j]);
            }
        }
    }

    dataArray = dataArrayTemp;
    width = width2;
    height = height2;

    var dataTemp = [];
    var dataArray2 = [];
    for(var i=0; i<height; i++) {
        dataTemp = [];
        for(var j=0; j<width; j++) {
            dataTemp.push(dataArray[i*width+j]);
        }
        dataTemp = fft(dataTemp);
        for(var j=0; j<width; j++) {
            dataArray2.push(dataTemp[j]);
        }
    }
    dataArray = dataArray2;
    dataArray2 = [];
    for(var i=0; i<width; i++) {
        var dataTemp = [];
        for(var j=0; j<height; j++) {
            dataTemp.push(dataArray[j*width+i]);
        }
        dataTemp = fft(dataTemp);
        for(var j=0; j<height; j++) {
            dataArray2.push(dataTemp[j]);
        }
    }
    dataArray = [];
    for(var i=0; i<height; i++) {
        for(var j=0; j<width; j++) {
            dataArray[j*height+i] = dataArray2[i*width+j];
        }
    }
    return dataArray;
}
//使用模板进行边缘检测
function mask(maskArray, dataArray, width, height) {
    var maskWidth = maskArray.length;
    var maskHeight = maskArray[0].length;
    var xStart = (maskWidth-1)/2;
    var xEnd = width-xStart;
    var yStart = (maskHeight-1)/2;
    var yEnd = height-yStart;
    var maskXStart = -(maskWidth-1)/2;
    var maskXEnd = -maskXStart;
    var maskYStart = -(maskHeight-1)/2;
    var maskYEnd = -maskYStart;
    var temp=[],tempSum,x,y,i,j,tempMaskArray,index=0;
    for(y=0; y<height; y++) {
        for(x=0; x<width; x++) {
            if(x>xStart && x<xEnd && y>yStart && y<yEnd) {
                tempSum  = 0;
                for(j=maskYStart; j<=maskYEnd; j++) {
                    tempMaskArray = maskArray[j-maskYStart];
                    for(i=maskXStart; i<=maskXEnd; i++) {
                        tempSum += dataArray[(j+y)*width+i+x]*
                                tempMaskArray[i-maskXStart];
                    }
                }
                temp[index] = Math.round(tempSum);
            }
            else {
                temp[index] = dataArray[index];
            }
            index++;
        }
    }
    return temp;
}
//中值滤波
function median(filterWidth, filterHeight, dataArray, width, height) {
    var temp = [];
    for(var i=0; i<dataArray.length; i++) {
        temp.push(dataArray[i]);
    }
    for(var x=(filterWidth-1)/2; x<width-(filterWidth-1)/2; x++) {
        for(var y=(filterHeight-1)/2; y<width-(filterHeight-1)/2; y++) {
            var tempArray = [];
            for(var i=-(filterWidth-1)/2; i<=(filterWidth-1)/2; i++) {
                for(var j=-(filterHeight-1)/2; j<=(filterHeight-1)/2; j++) {
                    tempArray.push(temp[(j+y)*width+i+x]);
                }
            }
            // 泡沫排序，找出中值
            do {
                var loop = 0;
                for(var i=0; i<tempArray.length-1; i++) {
                    if(tempArray[i]>tempArray[i+1]) {
                        var tempChange = tempArray[i];
                        tempArray[i] = tempArray[i+1];
                        tempArray[i+1] = tempChange;
                        loop = 1;
                    }
                }
            }while(loop);
            dataArray[y*width+x] = tempArray[Math.round(tempArray.length/2)];
        }
    }
    return dataArray;
}
//一维离散小波变换
function wavelet1D(scl0,p,q){
	var temp,sclLen=scl0.length,plen=p.length,scl1=[],wvl1=[];
	for(var i=0;i<sclLen/2;p++){
		scl1[i]=0;
		wvl1[i]=0;
		for(var j=0;j<plen;j++){
			temp=(j+i*2)%sclLen;
			scl1[i]+=p[j]*scl0[temp];
			wvl1[i]+=q[j]*scl0[temp];
			}
		}
	return [scl1,wvl1];
	}
function iwavelet1D(p,q,scl1,wvl1){
	var temp,sclLen=scl1.length,plen=p.length,scl0=[];
	for(var i=0;i<sclLen;i++){
		scl0[2*i+1]=0;
		scl0[2*i]=0;
		for(var j=0;j<plen/2;j++){
			temp=(i-j+sclLen)%sclLen;
			scl0[2*i+1]+=p[2*j+1]*scl1[temp]+q[2*j+1]*wvl1[temp];
			scl0[2*i]+=p[2*j]*scl1[temp]+q[2*j]*wvl1[temp];
			}
		}
		return scl0;
	}
function wavelet2D(input,w,h,p,q,series){
		var width=w,height=h,data=input,s,s1,w1,output;
		for(var i=0;i<height/series;i++){
			for(var j=0;j<width/series;j++){
				s[j]=data[i*width/series+j];
				}
			output=wavelet1D(s,p,q);
			s1=output[0],w1=output[1];
			for(var j=0;j<width/series;j++){
				if(j<width/(2*series)){
					data[i*width/series+j]=s1[j];
					}
				else{
					data[i*width/series+j]=w1[j-width/(2*series)];
					}
				}
			}
		for(var i=0;i<width/series;i++){
			for(var j=0;j<height/series;j++){
				s[j]=data[j*width/series+i];
				}
			output=wavelet1D(s,p,q);
			s1=output[0],w1=output[1];
			for(var j=0;j<height/series;j++){
				if(j<height/(2*series)){
					data[j*width/series+i]=s1[j];
					}
				else{
					data[j*width/series+i]=w1[j-height/(2*series)];
					}
				}
			}
		return data;
	}
function iwavelet2D(input,w,h,p,q,series){
		var width=w,height=h,s,s1,w1,output;
		for(var i=0;i<width/series;i++){
			for(var j=0;j<height/series;j++){
				if(j<height/(2*series)){
					s1[j]=input[j*width/series+i];
					}
				else{
					w1[j-height/(2*series)]=input[j*width/series+i];
					}
			}
		s=iwavelet1D(p,q,s1,w1);
		for(var j=0;j<height/series;j++){
			input[j*width/series+i]=s[j];
			}
		}
	for(var i=0;i<height/series;i++){
		for(var j=0;j<width/series;j++){
			if(j<width/(2*series)){
				s1[j]=input[i*width/series+j];
				}
			else{
				w1[j-width/(2*series)]=input[i*width/series+j];
				}
			}
		
		s=iwavelet1D(p,q,s1,w1);
		for(var j=0;j<width/series;j++){
			input[i*width/series+j]=s[j];
			}
		}
		return input;
	}
function wavelet(src,type,dwtSeries,thresholding){
	if(src&&src.data){
		if(!type&&type!=0){
			type=0;
			}
		var width=src.width,height=src.height,grayValue=grayValues(src),tempA=[],tempB=[],lowFilter=[],highFilter=[];
		for(var i=0;i<grayValue.length;i++){
			tempA[i]=grayValue[i];
			}
		switch(type){
			case 0:
			lowFilter=[.70710678118655,.70710678118655];
			break;
			case 1:
			lowFilter=[.48296291314452,.83651630373780,.22414386804201,-.12940952255126];
			break;
			case 2:
			lowFilter=[.33267055295008,.80689150931109,.45987750211849,-.13501102001025,-.08544127388203,.03522629188571];
			break;
			case 3:
			lowFilter=[.23037781330889,.71484657055291,.63088076792986,-.02798376941686,-.18703481171909,.03084138183556,.03288301166689,-.01059740178507];
			break;
			case 4:
			lowFilter=[.16010239797419,.60382926979719,.72430852843778,.13842814590132,-.24229488706638,-.03224486958464,.07757149384005,-.00624149021280,-.01258075199908,.00333572528547];
			break;
			case 5:
			lowFilter=[.11154074335011,.49462389039845,.75113390802110,.31525035170920,-.22626469396544,-.12976686756726,.09750160558732,.02752286553031,-.03158203931849,.00055384220116,.00477725751195,.00107730108531];
			break;
			default:
			break;
			}
		for(var i=0;i<lowFilter.length;i++){
			highFilter[i]=Math.pow(-1,i)*lowFilter[lowFilter.length-1-i];
			}
		for(var k=0;k<dwtSeries;k++){
			var coef=Math.floor(Math.pow(2,k));
			for(var i=0;i<height;i++){
				if(i<height/coef){
					for(var j=0;j<width;j++){
						if(j<width/coef){
							tempB[i*width/coef+j]=tempA[i*width+j];
							}
						}
					}
				}
			tempB=wavelet2D(tempB,width,height,lowFilter,highFilter,coef);
			for(var i=0;i<height;i++){
				if(i<height/coef){
					for(var j=0;j<width;j++){
						if(j<width/coef){
							tempA[i*width+j]=tempB[i*width/coef+j];
							}
						}
					}
				}
			if(type>2){
				for(var l=0,len=tempA.length;l<len;l++){
					if(tempA[l]<thresholding&&tempA[l]>-thresholding){
						tempA[l]=0;
						}
					}
				}
			else{
				for(var l=0,len=tempA.length;l<len;l++)
				{
				if(tempA[l]>=thresholding){
					tempA[l]=tempA[l]-thresholding;
					}
				else{
					if(tempA[l]<=-thresholding){
						tempA[l]=tempA[l]+thresholding;
						}
					else{
						tempA[l]=0;
						}
					}
				}
				}
			}
			//二维离散小波变换
			for(var k=dwtSeries-1;k>0;k--){
				var coef=Math.pow(2,k);
				for(var i=0;i<height;i++){
					if(i<height/coef){
						for(var j=0;j<width;j++){
							if(width/coef){
								tempB[i*width/coef+j]=tempA[i*width+j];
							}
						}
					}
				}
			//调用二维小波变换
			tempB=iwavelet2D(tempB,width,height,lowFilter,highFilter,coef);
			for(var i=0;i<height;i++){
				if(i<height/coef){
					for(var j=0;j<width;j++){
						if(j<width/coef){
							tempA[i*width+j]=tempB[i*width/coef+j];
							}
						}
					}
				}
			}
		
		for(var i=0,len=grayValue.length;i<len;i++){
			if(tempA[i]>255){
				tempA[i]=255;
				}
			if(tempA[i]<0){
				tempA[i]=0;
				}
			grayValue[i]=tempA[i];
			}
		
		return grayValue;
		}
	}
	//高斯低通滤波
	function gaussSmooth(inputImage,sigma){
		var std2=2*sigma*sigma,radius=Math.ceil(3*sigma),filterWidth=2*radius+1,filter=[],tempImage=[],out=[],sum=0,length=Math.floor(Math.sqrt(inputImage.length));
		for(var i=0;i<filterWidth;i++){
			var xx=(i-radius)*(i-radius);
			filter[i]=Math.exp(-xx/std2);
			sum+=filter[i];
			}
		//归一化
		for(var i=0;i<filterWidth;i++){
			filter[i]=filter[i]/sum;
			}
		//水平方向滤波
		for(var i=0;i<length;i++){
			for(var j=0;j<length;j++){
				var temp=0;
				for(var k=-radius;k<radius;k++){
					var rem=(Math.abs(j+k))%length;
					temp+=inputImage[i*length+rem]*filter[k+radius];
					}
				tempImage[i*length+j]=temp;
				}
			}
		//垂直方向滤波
		for(var j=0;j<length;j++){
			for(var i=0;i<length;i++){
				var temp=0;
				for(var k=-radius;k<radius;k++){
					var rem=(Math.abs(i+k))%length;
					temp+=tempImage[rem*length+j]*filter[k+radius];
					}
				out[i*length+j]=temp;
				}
			}
		return out;
		}
	function gauss(src,sigma){
		if(src&&src.data){
			var width=src.width,height=src.height,grayValue=grayValues(src),tempArray=[];
			tempArray=gaussSmooth(grayValue,sigma);
			for(var i=0,len=grayValue.length;i<len;i++){
				if(tempArray[i]>255){
					grayValue[i]=255;
					}
				else if(tempArray[i]<0){
					grayValue[i]=0;
					}
				else{
					grayValue[i]=Math.floor(tempArray[i]);
					}
				}
			return grayValue;
			}
		}
	//统计滤波
	function tongji(src,thresholding,type){
		if(src&&src.data){
			var width=src.width,height=src.height,grayValue=grayValues(src),tempArray=[];
			if(!type&&type!=0){
				type=0;
				}
			//3x3领域窗口
			if(type==0)
			{
			for(var i=0;i<height;i++){
				for(var j=0;j<width;j++){
					var mu=0,sigma=0;
					mu=(grayValue[i*width+j]+grayValue[(Math.abs(i-1)%height)*width+j]+grayValue[(Math.abs(i+1)%height)*width+j]+grayValue[i*width+(j+1)%width]+grayValue[i*width+Math.abs(j-1)%width]+grayValue[(Math.abs(i-1)%height)*width+(j-1)%width]+grayValue[(Math.abs(i+1)%height)*width+(j-1)%width]+grayValue[(Math.abs(i-1)%height)*width+(j+1)%width]+grayValue[(Math.abs(i+1)%height)*width+(j+1)%width])/9;
					sigma=Math.sqrt((Math.pow((grayValue[i*width+j])-mu,2)+Math.pow((grayValue[(Math.abs(i-1)%height)*width+j])-mu,2)+Math.pow((grayValue[(Math.abs(i+1)%height)*width+j])-mu,2)+Math.pow((grayValue[i*width+(j+1)%width])-mu,2)+Math.pow((grayValue[i*width+Math.abs(j-1)%width])-mu,2)+Math.pow((grayValue[(Math.abs(i-1)%height)*width+Math.abs(j-1)%width])-mu,2)+Math.pow((grayValue[(Math.abs(i+1)%height)*width+Math.abs(j-1)%width])-mu,2)+Math.pow((grayValue[(Math.abs(i-1)%height)*width+Math.abs(j+1)%width])-mu,2)+Math.pow((grayValue[(Math.abs(i+1)%height)*width+Math.abs(j+1)%width])-mu,2))/9);
					//计算公式
					if(Math.abs(grayValue[i*width+j]-mu)<sigma*thresholding){
						tempArray[i*width+j]=grayValue[i*width+j];
						}
						else
						tempArray[i*width+j]=Math.floor(mu);
					}
				}
			}
		}
		else if(type==1){
			for(var i=0;i<height;i++){
				for(var j=0;j<width;j++){
					var mu=0,sigma=0;
					mu=(grayValue[(Math.abs(i-2)%height)*width+Math.abs(j-2)%width]+grayValue[(Math.abs(i-2)%height)*width+Math.abs(j-1)%width]+grayValue[(Math.abs(i-2)%height)*width+j]+grayValue[(Math.abs(i-2)%height)*width+(j+1)%width]+grayValue[(Math.abs(i-2)%height)*width+(j+2)%width]+grayValue[(Math.abs(i-1)%height)*width+Math.abs(j-2)%width]+grayValue[(Math.abs(i-1)%height)*width+Math.abs(j-1)%width]+grayValue[(Math.abs(i-1)%height)*width+j]+grayValue[(Math.abs(i-1)%height)*width+(j+1)%width]+grayValue[(Math.abs(i-1)%height)*width+(j+2)%width]+grayValue[i*width+Math.abs(j-2)%width]+grayValue[i*width+Math.abs(j-1)%width]+grayValue[i*width+j]+grayValue[i*width+(j+1)%width]+grayValue[i*width+(j+2)%width]+grayValue[(i+1)%height*width+Math.abs(j-2)%width]+grayValue[(i+1)%height*width+Math.abs(j-1)%width]+grayValue[(i+1)%height*width+j]+grayValue[(i+1)%height*width+(j+1)%width]+grayValue[(i+1)%height*width+(j+2)%width]+grayValue[(i+2)%height*width+Math.abs(j-2)%width]+grayValue[(i+2)%height*width+Math.abs(j-1)%width]+grayValue[(i+2)%height*width+j]+grayValue[(i+2)%height*width+(j+1)%width]+grayValue[(i+2)%height*width+(j+2)%width])/25;
					sigma=Math.sqrt((Math.pow((grayValue[(Math.abs(i-2)%height)*width+Math.abs(j-2)%width]-mu),2)+Math.pow((grayValue[(Math.abs(i-2)%height)*width+Math.abs(j-1)%width]-mu),2)+Math.pow((grayValue[(Math.abs(i-2)%height)*width+j]-mu),2)+Math.pow((grayValue[(Math.abs(i-2)%height)*width+(j+1)%width]-mu),2)+Math.pow((grayValue[(Math.abs(i-2)%height)*width+(j+2)%width]-mu),2)+Math.pow((grayValue[(Math.abs(i-1)%height)*width+Math.abs(j-2)%width]-mu),2)+Math.pow((grayValue[(Math.abs(i-1)%height)*width+Math.abs(j-1)%width]-mu),2)+Math.pow((grayValue[(Math.abs(i-1)%height)*width+j]-mu),2)+Math.pow((grayValue[(Math.abs(i-1)%height)*width+(j+1)%width]-mu),2)+Math.pow((grayValue[(Math.abs(i-1)%height)*width+(j+2)%width]-mu),2)+Math.pow((grayValue[i*width+Math.abs(j-2)%width]-mu),2)+Math.pow((grayValue[i*width+Math.abs(j-1)%width]-mu),2)+Math.pow((grayValue[i*width+j]-mu),2)+Math.pow((grayValue[i*width+(j+1)%width]-mu),2)+Math.pow((grayValue[i*width+(j+2)%width]-mu),2)+Math.pow((grayValue[(i+1)%height*width+Math.abs(j-2)%width]-mu),2)+Math.pow((grayValue[(i+1)%height*width+Math.abs(j-1)%width]-mu),2)+Math.pow((grayValue[(i+1)%height*width+j]-mu),2)+Math.pow((grayValue[(i+1)%height*width+(j+1)%width]-mu),2)+Math.pow((grayValue[(i+1)%height*width+(j+2)%width]-mu),2)+Math.pow((grayValue[(i+2)%height*width+Math.abs(j-2)%width]-mu),2)+Math.pow((grayValue[(i+2)%height*width+Math.abs(j-1)%width]-mu),2)+Math.pow((grayValue[(i+2)%height*width+j]-mu),2)+Math.pow((grayValue[(i+2)%height*width+(j+1)%width]-mu),2)+Math.pow((grayValue[(i+2)%height*width+(j+2)%width]-mu),2))/25);
					if(Math.abs(grayValue[i*width+j]-mu)<sigma*thresholding){
						tempArray[i*width+j]=grayValue[i*width+j];
						}
					else
					tempArray[i*width+j]=Math.floor(mu);
					}
				}
			}
			return grayValue=tempArray;
		
		}
	//边缘检测
	function mask(src,thresholding,type){
		if(src&&src.data){
			var width=src.width,height=src.height,grayValue=grayValues(src),tempArray=[],gradX,gradY,grad;
			switch(type){
				case 0:
				///roberts
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						gradX=grayValue[Math.abs(i-1)%height*width+(j+1)%width]-grayValue[i*width+j];
						gradY=grayValue[Math.abs(i-1)%height*width+j]-grayValue[i*width+(j+1)%width];
						grad=Math.sqrt(gradX*gradX+gradY*gradY);
						tempArray[i*width+j]=grad;
						}
					}
				break;
				case 1:
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						gradX=grayValue[Math.abs(i-1)%height*width+(j+1)%width]+grayValue[i*width+(j+1)%width]+grayValue[(i+1)%height*width+(j+1)%width]-grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-grayValue[i*width+Math.abs(j-1)%width]-grayValue[(i+1)%height*width+Math.abs(j-1)%width];
						gradY=grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+grayValue[Math.abs(i-1)%height*width+j]+grayValue[Math.abs(i-1)%height*width+(j+1)%width]-grayValue[(i+1)%height*width+Math.abs(j-1)%width]-grayValue[(i+1)%height*width+j]-grayValue[(i+1)%height*width+(j+1)%width];
						grad=Math.sqrt(gradX*gradX+gradY*gradY);
						tempArray[i*width+j]=grad;
						}
					}
				break;
				case 2:
				//sobel
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						gradX=grayValue[Math.abs(i-1)%height*width+(j+1)%width]+2*grayValue[i*width+(j+1)%width]+grayValue[(i+1)%height*width+(j+1)%width]-grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-2*grayValue[i*width+Math.abs(j-1)%width]-grayValue[(i+1)%height*width+Math.abs(j-1)%width];
						gradY=grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+2*grayValue[Math.abs(i-1)%height*width+j]+grayValue[Math.abs(i-1)%height*width+(j+1)%width]-grayValue[(i+1)%height*width+Math.abs(j-1)%width]-2*grayValue[(i+1)%height*width+j]-grayValue[(i+1)%height*width+(j+1)%width];
						grad=Math.sqrt(gradX*gradX+gradY*gradY);
						tempArray[i*width+j]=grad;
						}
					}
				break;
				case 3:
				//拉普拉斯公式1
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						grad=grayValue[Math.abs(i-1)%height*width+j]+grayValue[i*width+Math.abs(j-1)%width]+grayValue[i*width+(j+1)%width]+grayValue[(i+1)%height*width+j]-4*grayValue[i*width+j];
						tempArray[i*width+j]=grad;
						}
					}
				break;
				case 4:
				//拉普拉斯公式2
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						grad=grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+grayValue[Math.abs(i-1)%height*width+j]+grayValue[Math.abs(i-1)%height*width+(j+1)%width]+grayValue[i*width+Math.abs(j-1)%width]+grayValue[i*width+(j+1)%width]+grayValue[(i+1)%height*width+Math.abs(j-1)%width]+grayValue[(i+1)%height*width+j]+grayValue[(i+1)%height*width+(j+1)%width]-8*grayValue[i*width+j];
						tempArray[i*width+j]=grad;
						}
					}
				break;
				case 5:
				//拉普拉斯公式3
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						grad=-1*grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+2*grayValue[Math.abs(i-1)%height*width+j]-grayValue[Math.abs(i-1)%height*width+(j+1)%width]+2*grayValue[i*width+Math.abs(j-1)%width]+2*grayValue[i*width+(j+1)%width]-grayValue[(i+1)%height*width+Math.abs(j-1)%width]+2*grayValue[(i+1)%height*width+j]-grayValue[(i+1)%height*width+(j+1)%width]-4*grayValue[i*width+j];
						tempArray[i*width+j]=grad;
						}
					}
				break;
				case 6:
				//kirsch
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						grad=0;
						gradX=-5*grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+3*grayValue[Math.abs(i-1)%height*width+j]+3*grayValue[Math.abs(i-1)%height*width+(j+1)%width]-5*grayValue[i*width+Math.abs(j-1)%width]+3*grayValue[i*width+(j+1)%width]-5*grayValue[(i+1)%height*width+Math.abs(j-1)%width]+3*grayValue[(i+1)%height*width+j]+3*grayValue[(i+1)%height*width+(j+1)%width];
						if(gradX>grad)
						grad=gradX;
						gradX=3*grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+3*grayValue[Math.abs(i-1)%height*width+j]+3*grayValue[Math.abs(i-1)%height*width+(j+1)%width]-5*grayValue[i*width+Math.abs(j-1)%width]+3*grayValue[i*width+(j+1)%width]-5*grayValue[(i+1)%height*width+Math.abs(j-1)%width]-5*grayValue[(i+1)%height*width+j]+3*grayValue[(i+1)%height*width+(j+1)%width];
						if(gradX>grad)
						grad=gradX;
						}
						gradX=3*grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+3*grayValue[Math.abs(i-1)%height*width+j]+3*grayValue[Math.abs(i-1)%height*width+(j+1)%width]+3*grayValue[i*width+Math.abs(j-1)%width]+3*grayValue[i*width+(j+1)%width]-5*grayValue[(i+1)%height*width+Math.abs(j-1)%width]-5*grayValue[(i+1)%height*width+j]-5*grayValue[(i+1)%height*width+(j+1)%width];
						if(gradX>grad)
						grad=gradX;
						
						gradX=3*grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+3*grayValue[Math.abs(i-1)%height*width+j]+3*grayValue[Math.abs(i-1)%height*width+(j+1)%width]+3*grayValue[i*width+Math.abs(j-1)%width]-5*grayValue[i*width+(j+1)%width]+3*grayValue[(i+1)%height*width+Math.abs(j-1)%width]-5*grayValue[(i+1)%height*width+j]-5*grayValue[(i+1)%height*width+(j+1)%width];
						if(gradX>grad)
						grad=gradX;
						
						gradX=3*grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+3*grayValue[Math.abs(i-1)%height*width+j]-5*grayValue[Math.abs(i-1)%height*width+(j+1)%width]+3*grayValue[i*width+Math.abs(j-1)%width]-5*grayValue[i*width+(j+1)%width]+3*grayValue[(i+1)%height*width+Math.abs(j-1)%width]+3*grayValue[(i+1)%height*width+j]-5*grayValue[(i+1)%height*width+(j+1)%width];
						if(gradX>grad)
						grad=gradX;
						gradX=3*grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-5*grayValue[Math.abs(i-1)%height*width+j]-5*grayValue[Math.abs(i-1)%height*width+(j+1)%width]+3*grayValue[i*width+Math.abs(j-1)%width]-5*grayValue[i*width+(j+1)%width]+3*grayValue[(i+1)%height*width+Math.abs(j-1)%width]+3*grayValue[(i+1)%height*width+j]+3*grayValue[(i+1)%height*width+(j+1)%width];
							if(gradX>grad)
						         grad=gradX;
						gradX=-5*grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-5*grayValue[Math.abs(i-1)%height*width+j]-5*grayValue[Math.abs(i-1)%height*width+(j+1)%width]+3*grayValue[i*width+Math.abs(j-1)%width]+3*grayValue[i*width+(j+1)%width]+3*grayValue[(i+1)%height*width+Math.abs(j-1)%width]+3*grayValue[(i+1)%height*width+j]+3*grayValue[(i+1)%height*width+(j+1)%width];
						if(gradX>grad)
						         grad=gradX;
						gradX=-5*grayValue[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-5*grayValue[Math.abs(i-1)%height*width+j]+3*grayValue[Math.abs(i-1)%height*width+(j+1)%width]-5*grayValue[i*width+Math.abs(j-1)%width]+3*grayValue[i*width+(j+1)%width]+3*grayValue[(i+1)%height*width+Math.abs(j-1)%width]+3*grayValue[(i+1)%height*width+j]+3*grayValue[(i+1)%height*width+(j+1)%width];
						if(gradX>grad)
						         grad=gradX;
						tempArray[i*width+j]=grad;
					}
				break;
				}
			if(thresholding==0){
				for(var i=0,len=grayValue.length;i<len;i++){
					if(tempArray[i]<0)
					grayValue[i]=0;
					else{
						if(tempArray[i]>255){
							grayValue[i]=255;
							}
						else{
							grayValue[i]=Math.floor(tempArray[i]);
							}
						}
					}
				}
				else{
					if(type==3||type==4||type==5){
						grayValue=zerocross(tempArray,thresholding);
						}
					else{
						for(var i=0,len=grayValue.length;i<len;i++){
							if(tempArray[i]>thresholding){
								grayValue[i]=255;
								}
							else{
								grayValue[i]=0;
								}
							}
						}
					}
			return grayValue;
			}
	}
//zerocross
function zerocross(tempArray,w,h,thresholding){
	if(tempArray instanceof Array&&tempArray.length>0){
		var width=w,height=h,out=[];
		for(var i=0;i<height;i++){
			for(var j=0;j<width;j++){
				if(tempArray[i*width+j]<0&&tempArray[(i+1)%height*width+j]>0&&Math.abs(tempArray[i*width+j]-tempArray[(i+1)%height*width+j])>thresholding){
					out[i*width+j]=255;
					}
				else if(tempArray[i*width+j]<0&&tempArray[Math.abs(i-1)%height*width+j]>0&&Math.abs(tempArray[i*width+j]-tempArray[Math.abs(i-1)%height*width+j])>thresholding){
					out[i*width+j]=255;
					}
				else if(tempArray[i*width+j]<0&&tempArray[i*width+(j+1)%width]>0&&Math.abs(tempArray[i*width+j]-tempArray[i*width+(j+1)%width])>thresholding){
					out[i*width+j]=255;
					}
				else if(tempArray[i*width+j]<0&&tempArray[i*width+Math.abs(j-1)%width]>0&&Math.abs(tempArray[i*width+j]-tempArray[i*width+Math.abs(j-1)%width])>thresholding){
					out[i*width+j]=255;
					}
				else if(tempArray[i*width+j]==0){
					if(tempArray[(i+1)%height*width+j]>0&&tempArray[Math.abs(i-1)%height*width+j]<0&&Math.abs(tempArray[(i+1)%height*width+j]-tempArray[Math.abs(i-1)%height*width+j]>2*thresholding)){
						out[i*width+j]=255;
						}
					else if(tempArray[(i+1)%height*width+j]<0&&tempArray[Math.abs(i-1)%height*width+j]>0&&Math.abs(tempArray[(i+1)%height*width+j]-tempArray[Math.abs(i-1)%height*width+j])>2*thresholding){
						out[i*width+j]=255;
						}
					else if(tempArray[i*width+(j+1)%width]>0&&tempArray[i*width+Math.abs(j-1)%width]<0&&Math.abs(tempArray[i*width+(j+1)%width]-tempArray[i*width+Math.abs(j-1)%width])>2*thresholding){
						out[i*width+j]=255;
						}
					else if(tempArray[i*width+(j+1)%width]<0&&tempArray[i*width+Math.abs(j-1)%width]>0&&Math.abs(tempArray[i*width+(j+1)%width]-tempArray[i*width+Math.abs(j-1)%width])>2*thresholding){
						out[i*width+j]=255;
						}
					else{
						out[i*width+j]=0;
						}
					}
				else{
					out[i*width+j]=0;
					}
				}
			}
		return out;
		}
	}
	//canny 
	function canny(src,thresholding,sigma){
		if(src&&src.data){
			var width=src.width,height=src.height,grayValue=grayValues(src),len=grayValue.length,tempArray=[],tempImage=[],grad=[],aLabel=[],edgeMap=[],gradX,gradY,angle,rad=Math.floor(3*sigma);
			for(var i=0;i<len;i++){
				tempImage[i]=grayValue[i];
				}
			//调用高斯平滑处理方法
			tempArray=gaussSmooth(tempImage,sigma);
			//sobel  一阶便导
			for(var i=0;i<height;i++){
				for(var j=0;j<width;j++){
					//水平面方向梯度
					gradX=tempArray[Math.abs(i-1)%height*width+(j+1)%width]+2*tempArray[i*width+(j+1)%width]+tempArray[(i+1)%height*width+(j+1)%width]-tempArray[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-2*tempArray[i*width+Math.abs(j-1)%width]+tempArray[(i+1)%height*width+Math.abs(j-1)%width];
					//垂直方向梯度
					gradY=tempArray[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+2*tempArray[Math.abs(i-1)%height*width+j]+tempArray[Math.abs(i-1)%height*width+(j+1)%width]-tempArray[(i+1)%height*width+Math.abs(j-1)%width]-2*tempArray[(i+1)%height*width+j]-tempArray[(i+1)%height*width+(j+1)%width];
					//梯度和
					grad[i*width+j]=Math.sqrt(gradX*gradX+gradY*gradY);
					angle=Math.atan2(gradY,gradX);
					if((angle>=-1.178097&&angle<1.178097)||(angle>=-2.748894&&angle<2.748894)){
						aLabel[i*width+j]=0;
						}
					else if((angle>=.392699&&angle<1.178097)||(angle>=-2.748894&&angle<-1.963495)){
						aLabel[i*width+j]=1;
						}
					else if((angle>=-1.178097&&angle<-.392699)||(angle>=1.963495&&angle<2.748894)){
						aLabel[i*width+j]=2;
						}
					else{
						aLabel[i*width+j]=3;
						}
					}
				}
			for(var i=0;i<height;i++){
				for(var j=0;j<width;i++){
					switch(aLabel[i*width+j]){
						case 3:
						if(grad[i*width+j]>grad[Math.abs(i-1)%height*width+j]&&grad[i*width+j]>grad[(i+1)%height*width+j]){
							edgeMap[i*width+j]=grad[i*width+j];
							}
						break;
						case 2:
						if(grad[i*width+j]>grad[Math.abs(i-1)%height*width+Math.abs(j-1)%width]&&grad[i*width+j]>grad[(i+1)%height*width+(j+1)%width]){
							edgeMap[i*width+j]=grad[i*width+j];
							}
						break;
						case 1:
						if(grad[i*width+j]>grad[Math.abs(i-1)%height*width+(j+1)%width]&&grad[i*width+j]>grad[(i+1)%height*width+Math.abs(j-1)%width]){
							edgeMap[i*width+j]=grad[i*width+j];
							}
						break;
						case 0:
						if(grad[i*width+j]>grad[i*width+Math.abs(j-1)%width]&&grad[i*width+j]>grad[i*width+(j+1)%width]){
							edgeMap[i*width+j]=grad[i*width+j];
							}
						break;
						default:
						return;
						}
					}
				}
			for(var i=0;i<height;i++){
				for(var j=0;j<width;j++){
					if(edgeMap[i*width+j]>thresholding[0]){
						grayValue[i*width+j]=255;
						grayValue=traceEdge(i,j,width,height,edgeMap,grayValue,thresholding[1]);
						}
					}
				}
			return grayValue;
			}
		}
  function traceEdge(k,l,w,h,inputImage,OutputImage,thrlow){
	  var kOffset=[l,l,0,-l,-l,-l,0,l],lOffset=[0,l,l,l,0,-l,-l,-l],width=w,height=h,kk,ll;
	  for(var p=0;p<8;p++){
		  kk=k+kOffset[p];
		  kk=Math.abs(kk)%height;
		  ll=l+lOffset[p];
		  ll=Math.abs(ll)%width;
		  if(OutputImage[ll*width+kk]!=255){
			  if(inputImage[ll*width+kk]>thrlow){
				  OutputImage[ll*width+kk]=255;
				  OutputImage=traceEdge(ll,kk,width,height,inputImage,OutputImage,thrlow);
				  }
			  }
		  }
		return OutputImage;
	  }
//小波变换边缘检测;
function wavelet(src,thresholding,scale){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src),tempArray1=[],tempArray2=[],tempArray3=[],gradX=[],gradY=[],multiscale=scale,len=grayValue.length;
		for(var i=0;i<len;i++){
			tempArray1[i]=grayValue[i];
			}
	    for(var z=0;z<multiscale;z++){
			var p=[],q=[];
			switch(z){
				case 0:
				p=[.125,.375,.375,.125];
				q=[-2,2];
				break;
				case 1:
				p=[.125,0,.375,0,.375,0,.125];
				q=[-2,0,2];
				break;
				case 2:
				p=[.125,0,0,0,.375,0,0,0,.375,0,0,0,.125];
				q=[-2,0,0,0,2];
				break;
				case 3:
				p=[.125,0,0,0,0,0,0,0,.375,0,0,0,0,0,0,0,.375,0,0,0,0,0,0,0,.125];
				q=[-2,0,0,0,0,0,0,0,2];
				break;
				}
			var coff=Math.floor(Math.pow(2,z)-1);
			//小波行变换
			for(var i=0;i<height;i++){
				for(var j=0;j<width;j++){
					var scl=[],wvl=[],temp;
					scl[j]=0,wvl[j]=0;
					//低通滤波
					for(var x=-2-2*coff;x<p.length-2-2*coff;x++){
						temp=(Math.abs(j+x))%width;
						scl[j]+=p[l+coff-x]*tempArray1[i*width+temp];
						}
					//高通滤波
					for(var x=-1-coff;x<q.length-1-coff;x++){
						temp=(Math.abs(j+x))%width;
						wvl[j]+=q[-x]*tempArray1[i*width+temp];
						}
					//平滑系数
					tempArray2[i*width+j]=scl[j];
					gradX[i*width+j]=wvl[j];
					}
				}
			// 小波列变换
			for(var i=0;i<width;i++){
				for(var j=0;j<height;j++){
					var scl=[],wvl=[],temp;
					scl[j]=0,wvl[j]=0;
					//低通滤波
					for(var x=-2-2*coff;x<p.length-2-2*coff;x++){
						temp=(Math.abs(j+x))%height;
						scl[j]+=p[1+coff-x]*tempArray2[temp*width+i];
						}
					//高通滤波
					for(var x=-1-coff;x<q.length-1-coff;x++){
						temp=(Math.abs(j+x))%height;
						wvl[j]+=q[-x]*tempArray1[temp*width+i];
						}
					//平滑系数
					tempArray3[j*width+i]=scl[j];
					gradY[j*width+i]=wvl[j];
					}
				}
			tempArray1=tempArray3.slice(0);
			}
		var angle;
		for(var i=0;i<height;i++){
			for(var j=0;j<width;j++){
				//梯度和
				tempArray1[i*width+j]=Math.sqrt(gradX[i*width+j]*gradX[i*width+j]+gradY[i*width+j]*gradY[i*width+j]);
				//梯度方向
				angle=Math.atan2(gradY[i*width+j],gradX[i*width+j]);
				if((angle>=-1.178097&&angle<1.178097)||(angle>=-2.748894&&angle<2.748894))
				tempArray2[i*width+j]=0;
				else if((angle>=.392699&&angle<1.178097)||(angle>=-2.748894&&angle<-1.963495))
				tempArray2[i*width+j]=1;
				else if((angle>=-1.178097&&angle<-.392699)||(angle>=1.963495&&angle<2.748894))
				tempArray2[i*width+j]=2;
				else
				tempArray2[i*width+j]=3	;
				}
			}
			for(var i=0;i<height;i++){
				for(var j=0;j<width;j++){
					switch(tempArray2[i*width+j]){
						case 3:
						if(tempArray1[i*width+j]>tempArray1[Math.abs(i-1)%height*width+j]&&tempArray1[i*width+j]>tempArray1[(i+1)%height*width+j])
						tempArray3[i*width+j]=tempArray1[i*width+j];
						break;
						case 1:
						if(tempArray1[i*width+j]>tempArray1[Math.abs(i-1)%height*width+Math.abs(j-1)%width]&&tempArray1[i*width+j]>tempArray1[(i+1)%height*width+(j+1)%width])
						tempArray3[i*width+j]=tempArray1[i*width+j];
						break;
						case 2:
						if(tempArray1[i*width+j]>tempArray1[Math.abs(i-1)%height*width+(j+1)%width]&&tempArray1[i*width+j]>tempArray1[(i+1)%height*width+Math.abs(j-1)%width])
						tempArray3[i*width+j]=tempArray1[i*width+j];
						break;
						case 0:
						if(tempArray1[i*width+j]>tempArray1[i*width+Math.abs(j-1)%width]&&tempArray1[i*width+j]>tempArray1[i*width+(j+1)%width])
						tempArray3[i*width+j]=tempArray1[i*width+j];
						break;
						default:
						return;
						}
					}
				}
				//
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						if(tempArray3[i*width+j]>thresholding[0]){
							grayValue[i*width+j]=255;
							grayValue=traceEdge(i,h,width,height,tempArray3,grayValue,thresholding[1]);
							}
						}
					}
				return grayValue;
		}
	}
	// 金字塔方法
	function pyramid(src,thresholding,level,sigma){
		if(src&&src.data){
			var width=src.width;
			var height=src.height,grayValue=grayValues(src),thresh=thresholding,pyramidImage=[],passImage=[];
			for(var k=0;k<level+1;k++){
				passImage[k]=[];
				pyramidImage[k]=[]
				}
			pyramidImage[0]=grayValue.slice(0);
			//高斯塔分解
			for(var k=0;k<level;k++){
				var tempImage=[];
				tempImage=gaussSmooth(pyramidImage[k],sigma);
				var coff=pyramidImage[k].length;
				for(var i=0;i<coff;i++){
					passImage[k][i]=pyramidImage[k][i]-tempImage[i];
					var div=i/Math.floor(Math.sqrt(coff));
					var rem=i%Math.floor(Math.sqrt(coff));
					//隔行隔列
					if(div%2==0&&rem%2==0){
						var j=Math.floor((div/2)*Math.sqrt(pyramidImage[k+1].length)+rem/2);
						pyramidImage[k+1][j]=tempImage[i];
						}
					}
				}
				//拉普拉斯塔重构
				for(var k=level-1;k>0;k--){
					var coff=pyramidImage[k].length;
					//内插采样点
					for(var i=0;i<coff;i++){
						var div=i/Math.floor(Math.sqrt(coff));
					    var rem=i%Math.floor(Math.sqrt(coff));
						var j=Math.floor((div/2)*Math.sqrt(pyramidImage[k+1].length)+rem/2);
						if(div%2==0&&rem%2==0){
							pyramidImage[k][i]=pyramidImage[k+1][j];
							}
						else{
							pyramidImage[k][i]=0;
							}
						}
						tempImage=null;
						tempImage=gaussSmooth(pyramidImage[k],1);
						for(var i=0;i<coff;i++){
							pyramidImage[k][i]=tempImage[i]+passImage[k][i];
							}
					}
					grayValue=zerocross(pyramidImage[0],width,height,thresh);
					return grayValue;
			}
		}
	// 图像分割
	function threshold(src,methodType){
		if(src&&src.data){
			var width=src.width,height=src.height,method=methodType,temp=0,maxGray=0,minGray=255,grayValue=grayValues(src),neighb=[],countPixel=[];
			//计算直方图
			for(var i=0;i<256;i++){
				countPixel[i]=0;
				}
			for(var i=0,len=grayValue.length;i<len;i++){
				temp=grayValue[i];
				countPixel[temp]++;
				if(temp>maxGray){
					//最大灰度值
					maxGray=temp;
					}
				if(temp<minGray){
					minGray=temp;
					}
				}
			var mu1,mu2,numerator,denominator,sigma,tempMax=0,S,T;
			switch(method){
				case 0:
				var oldT=T=Math.floor((minGray+maxGray)/2);
				//迭代过程
				do{
					oldT=T;
					numerator=denominator=0;
					for(var i=minGray;i<T;i++){	
					numerator+=i*countPixel[i];
					denominator+=countPixel[i];
						}
					mu1=numerator/denominator;
					numerator=denominator=0;
					for(var i=T;i<maxGray;i++){
						numerator+=i*countPixel[i];
					    denominator+=countPixel[i];
						}
					mu2=numerator/denominator;
					T=Math.floor((mu1+mu2)/2);
					}
				while(T!=oldT)
				break;
				case 1:
				var w1=0,w2=0,sum=0,numerator=0;
				for(var i=minGray;i<maxGray;i++){
					sum+=i*countPixel[i];
					}
				for(var i=minGray;i<maxGray;i++){
					w1+=countPixel[i];
					numerator+=i*countPixel[i];
					mu1=numerator/w1;
					w2=grayValue.length-w1;
					mu2=(sum-numerator)/w2;
					sigma=w1*w2*(mu1-mu2)*(mu1-mu2);
					if(sigma>tempMax){
						tempMax=sigma;
						T=i;
						}
					}
				break;
				case 2:
				//一维最大嫡法
				var Ht=0,Hl=0,p=0,pt=0;
				for(var i=minGray;i<maxGray;i++){
					p=countPixel[i]/grayValue.length;
					if(p<.000000000000001)
					continue;
					Hl+=-p*Math.log(p)/Math.LN10;
					}
				for(var i=minGray;i<maxGray;i++){
					p=countPixel[i]/grayValue.length;
					pt+=p;
					if(p<.000000000000001)
					continue;
					Hl+=-p*Math.log(p)/Math.LN10;
					sigma=Math.log(pt*(1-pt))/Math.LN10+Ht/pt+(Hl-Ht)/(1-pt);
					if(sigma>tempMax){
						tempMax=sigma;
						T=i;
						}
					}
				break;
				case 3:
				//二维最大嫡
				var pap=[],H12D=0,Pa=0,Ha=0;
				for(var i=0,len=grayValue.length;i<len;i++){
					neighb[i]=Math.floor((grayValue[(i+1)%len]+grayValue[Math.abs(i-1)%len]+grayValue[(i+width)%len]+grayValue[Math.abs(i-width)%len])/4);
					}
				//耗时严重
				for(var i=0;i<256;i++){
					for(var j=0;j<256;j++){
						pap[(i+","+j)]=0;
						}
					}
				for(var i=0,len=grayValue.length;i<len;i++){
					for(var j=0;j<len;j++){
						var ii=grayValue[i];
						var jj=neighb[j];
						pap[(ii+","+jj)]++;
						}
					}
				for(var i=0;i<256;i++){
					for(var j=0;j<256;j++){
						pap[(i+","+j)]=pap[(i+","+j)]/len/len;
						if(pap[(i+","+j)]<.000000000000001){
							continue;	
							}
							H12D+=-pap[(i+","+j)]*Math.log(pap[(i+","+j)])/Math.LN10;	
						}
					}
					for(var i=0;i<=255;i++){
						for(var j=0;j<=255;j++){
							Pa+=pap[(i+","+j)];
							if(pap[(i+","+j)]<.000000000000001){
								continue;
								}
							Ha+=-pap[(i+","+j)]*Math.log(pap[(i+","+j)])/Math.LN10;
							sigma=Math.log(Pa*(1-Pa))/Math.LN10+Ha/Pa+(H12D-Ha)/(1-pa);
							if(sigma>tempMax){
								tempMax=sigma;
								S=i;
								T=j;
								}
							}
						}
				break;
				case 4:
				// 简单统计法
				var ee=[],ex=0,ef=0,esum=0;
				for(var i=0,len=grayValue.length;i<len;i++){
					ex=Math.abs(grayValue[(i+1)%len]-grayValue[Math.abs(i-1)%len]);
					ey=Math.abs(grayValue[(i+width)%len]-grayValue[Math.abs(i-width)%len]);
					ee[i]=Math.max(ex,ey);
					ef+=ee[i]*grayValue[i];
					esum+=ee[i];
					}
				T=Math.floor(ef/esum);
				break;
				default:
				break;
				}
			//二值图像化
			for(var i=0,len=grayValue.length;i<len;i++){
				if(method==3){
					if(grayValue[i]<S&&neighb[i]<T){
						grayValue[i]=0;
						}
					else
					grayValue[i]=255;
				}
				else{
					if(grayValue[i]<T){
						grayValue[i]=0;	
						}
					else
					grayValue[i]=255;
					}
				}
			return grayValue;
			}
		}
//特征空间聚类法
function clus(src,method,num){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src),method=method,numbers=num;
		if(method==false){
			var kNum=[],kAver=[],kOldAver=[],kSum=[],kTemp=[],segmentMap=[];
			//初始化聚类均值
			for(var i=0;i<numbers;i++){
				kAver[i]=kOldAver[i]=Math.floor(i*255/(numbers-1));
				}
			while(true){
				var order=0;
				for(var i=0;i<numbers;i++){
					kAver[i]=kOldAver[i];
					kNum[i]=0;
					kSum[i]=0;
					}
				//样本归属聚类
					for(var i=0,len=grayValue.length;i<len;i++){
						for(var j=0;j<numbers;j++){
							kTemp[j]=Math.abs(grayValue[i]-kAver[j]);
							}
						var temp=255;
						for(var j=0;j<numbers;j++){
							if(kTemp[j]<temp){
								temp=kTemp[j];
								order=j;
								}
						}
						kNum[order]++;
						kSum[order]+=grayValue[i];
						segmentMap[i]=Math.floor(order);
							}
					
					for(var i=0;i<numbers;i++){
						if(kNum[i]!=0)
						kOldAver[i]=Math.floor(kSum[i]/kNum[i]);
						}
					//判断迭代结束条件
					var kkk=0;
					for(var i=0;i<numbers;i++){
						if(kAver[i]==kOldAver[i]){
							kkk++;
							}
					}
						//跳出循环
						if(kkk==numbers){
							break;
							}
					}
					//按聚类分割图像
				for(var i=0,len=grayValue.length;i<len;i++){
					for(var j=0;j<numbers;j++){
						if(segmentMap[i]==j){
							grayValue[i]=Math.floor(kAver[i]);
							}
						}
					}
				}
			else{
				var k=2*numbers,segmentMap=[],kTemp=[],kNum=[],kAver=[],kSum=[];
				//初始化聚类均值
				for(var i=0;i<k;i++){
					kAver[i]=Math.floor(i*255/(k-1));
					kNum[i]=0;
					kTemp[i]=0;
					kSum[i]=0;
					}
				while(true){
					var temp=0;
					for(var i=0,len=grayValue.length;i<len;i++){
						kTemp.length=0;
						var order=0;
						for(var j=0;j<k;j++){
							kTemp.push(Math.abs(grayValue[i]-kAver[j]));
							}
						temp=255;
						for(var i=0;j<k;j++){
							if(kTemp[j]<temp)
							{
							temp=kTemp[j];
							order=j;
							}
						}
						var num=kNum[order]+1;
						kNum.splice(order,1);
						kNum.splice(order,0,num);
						var sum=kSum[order]+grayValue[i];
						kSum.splice(order,1);
						kSum.splice(order,0,sum);
						segmentMap[i]=Math.floor(order);
						}
					//去除没有样本的聚类
						for(var i=0;i<k;i++){
							if(kNum[i]==0){
								kNum.splice(i,1);
								kAver.splice(i,1);
								kSum.splice(i,1);
								i--;
								k--;
								}
							}
						//更新聚类均值
						kAver.length=0;
						for(var i=0;i<k;i++){
							kAver.push(Math.floor(kSum[i]/kNum[i]));
							}
						if(k<numbers)
						break;
						//相似聚类合并
						temp=255;
						var removeI=0,removeJ=0;
						for(var i=0;i<k;i++){
							for(var j=i+1;j<k;j++){
								var distanceIJ=Math.abs(kAver[i]-kAver[j]);
								if(distanceIJ<temp){
									temp=distanceIJ;
									removeI=i;
									removeJ=j;
									}
								}
							}
							k--;
							kNum.push(kNum[removeI]+kNum[removeJ]);
							kAver.push(Math.floor(kNum[removeI]*kAver[removeI]+kNum[removeJ]*kAver[removeJ])/(kNum[removeI]+kNum[removeJ]));
							kSum.push(kNum[removeI]*kAver[removeI]+kNum[removeJ]*kAver[removeJ]);
							kNum.splice(removeI,1);
							kNum.splice(removeJ,1);
							kAver.splice(removeI,1);
							kAver.splice(removeJ,1);
							kSum.splice(removeI,1);
							kSum.splice(removeJ,1);
							//按聚类分割图像
							for(var i=0,len=grayValue.length;i<len;i++){
								for(var j=0;j<numbers;j++){
									if(segmentMap[i]==j){
										grayValue[i]=Math.floor(kAver[j]);
										}
									}
								}
					}
				}
				
			return grayValue;
		}
	}
//松弛迭代法
function overRelax(src,seg,iter){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src),segNumber=seg,iterNumber=iter;
		//类总和
		var kSum=[],kAver=[],kVar=[],imageMap=[];
		//计算类的总和均值和方差
		for(var i=0,len=grayValue.length;i<len;i++){
			for(var j=0;j<segNumber;j++){
				if(grayValue[i]<Math.floor(255*j/segNumber)){
					imageMap[i]=j-1;
					kAver[j-1]+=grayValue[i];
					kSum[j-1]+=1;
					break;
					}
				}
			}
		for(var i=0;i<segNumber;i++){
			if(kSum[i]!=0){
				kAver[i]/=kSum[i];
				}
			}
		for(var i=0,len=grayValue.length;i<len;i++){
			kAver[imageMap[i]]+=Math.floor(Math.pow(grayValue[i]-kAver[imageMap[i]],2));
			}
		for(var i=0;i<segNumber;i++){
			if(kSum[i]!=0)
			kAver[i]/=kSum[i];
			}
		var d=[],kprob=[]
		//计算马氏距离
		for(var i=0,len=grayValue.length;i<len;i++){
			for(var j=0;j<segNumber;j++){
				if(kAver[j]==0){
					kAver[j]=.00000005;
					}
				d[i*segNumber+j]=Math.pow(kAver[j]-grayValue[i],2)/kAver[j];
				if(d[i*segNumber+j]==0)
				d[i*segNumber+j]=.00000005;
				}
			}
		var tempSum=0;
		for(var i=0,len=grayValue.length;i<len;i++){
			tempSum=0;
			for(var j=0;j<segNumber;j++){
				tempSum+=1/d[i*segNumber+j];
				for(var j=0;j<segNumber;j++){
					kprob[i*segNumber+j]=1/(tempSum*d[i*segNumber+j]);
					}
				}
		//迭代循环
		while(iterNumber!=0){
			iterNumber--;
			for(var i=0,len=grayValue.length;i<len;i++){
				for(var j=0;j<segNumber;j++){
					//8个领域的概率总和
					tempSum=kprob[(Math.abs(i+1-width)%len)*segNumber+j]+kprob[(Math.abs(i-width)%len)*segNumber+j]+kprob[(Math.abs(i-1-width)%len)*segNumber+j]+kprob[(Math.abs(i-1)%len)*segNumber+j]+kprob[(Math.abs(i-1+width)%len)*segNumber+j]+kprob[(Math.abs(i+width)%len)*segNumber+j]+kprob[(Math.abs(i+1+width)%len)*segNumber+j]+kprob[(Math.abs(i+1)%len)*segNumber+j];
					//更新每个类的概率
					d[i*segNumber+j]=tempSum/8;
					tempSum=0;
					for(var k=0;k<segNumber;k++){
						tempSum+=kprob[i*segNumber+k]*(1+d[i*segNumber+k]);
						kprob[i*segNumber+k]*=(1+d[i*segNumber+k])/tempSum;
						}
					}
				}
			}
			//得到分割后的灰度值
			for(var i=0,len=grayValue.length;i<len;i++){
				var tempMax=0,m=0;
				for(var j=0;j<segNumber;j++){
					if(kprob[i*segNumber+j]>tempMax){
						tempMax=kprob[i*segNumber+j];
						m=j;
						}
					}
				grayValue[i]=Math.floor(m*255/segNumber);
				}
			}
	  return grayValue;
		}
	}
	// 彩色图像处理
	function adjust(src,changTab,numCom1,numCom2,numCom3){
		if(src&&src.data){
			var width=src.width,height=src.height,tempArray=[],rgbValues=src.data,bytes=width*height;
			//初始化tempArray 数组
			if(changTab==255){
				tempArray=rgbValues.slice(0);
				return tempArray;
				}
			var valueCom1=numCom1/100;
			var valueCom1=numCom2/100;
			var valueCom3=numCom3/100;
			var r,g,b;
			if(changTab==0){
				//rgb空间
				for(var i=0;i<bytes;i++){
					//调整红色分量
					}
				}
			}
		}
	//伪彩色处理
	function pseudo(src,method,seg){
		if(src&&src.data){
			var width=src.width,height=src.height,tempArray=[],grayValue=grayValues(src),bytes=width*height,method=method,seg=seg,rgbValues=[],bytes=width*height,tempB;
			if(method==false){
				//强度分层法
				for(var i=0;i<bytes;i++){
					var ser=Math.floor(256/bytes);
					tempB=Math.floor(grayValue[i]/ser);
					//分配任意一种指定颜色
					rgbValues[i*4+1]=Math.floor(tempB*ser);
					rgbValues[i*4]=Math.floor((seg-1-tempB)*ser);
					rgbValues[i*4+2]=0;
					rgbValues[i*4+3]=1;
					}
				}
				else{
					//废度级-彩色变换法
					for(var i=0;i<bytes;i++){
						if(grayValue[i]<64){
							//小于L/4
							rgbValues[i*4+2]=0;
							rgbValues[i*4+1]=Math.floor(4*rgbValues[i]);
							rgbValues[i*4]=255;
							rgbValues[i*4+3]=1;
							}
						else if(grayValue[i]<128){
							//大于L/4，而小于L/2
							rgbValues[i*4+2]=0;
							rgbValues[i*4+1]=255;
							rgbValues[i*4]=Math.floor(-4*rgbValues[i]+2*255);
							rgbValues[i*4+3]=1;
							}
						else if(grayValue[i]<192){
							//大于L/2，而小于3L/4
							rgbValues[i*4+2]=Math.floor(4*rgbValues[i]-2*255);
							rgbValues[i*4+1]=255;
							rgbValues[i*4]=0;
							rgbValues[i*4+3]=1;
							}
						else{
							//大于3L/4
							rgbValues[i*4+2]=255;
							rgbValues[i*4+1]=Math.floor(-4*rgbValues[i]+4*255);
							rgbValues[i*4]=0;
							rgbValues[i*4+3]=1;
							}
						}
					}
				return rgbValues;
			}
		}
//直方图均衡
function equc(src,method){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src),bytes=width*height,rgbValues=src.data;
		if(method==false){
			//RGB分量
			var rValues=[],gValues=[],bValues=[];
			//取值
			for(var i=0;i<bytes;i++){
				rValues[i]=rgbValues[i*4];
				gValues[i]=rgbValues[i*4+1];
				bValues[i]=rgbValuesp[i*4+2];
				}
			//调用灰度图像均衡话
			rValues=equalization(rValues);
			gValues=equalization(gValues);
			bValues=equalization(bValues);
			//赋值
			for(var i=0;i<bytes;i++){
				rgbValues[i*4]=rValues[i];
				rgbValues[i*4+1]=gValues[i];
				rgbValues[i*4+2]=bValues[i];
				}
			}
		else{
			//亮度法
			var hue=[],sat=[],inten=[],r,g,b;
			//RGB空间转换为HSI空间
			for(var i=0;i<bytes;i++){
				r=rgbValues[i*4];
				g=rgbValues[i*4+1];
				b=rgbValues[i*4+2];
				var theta=Math.acos(.5*((r-g)+(r-b))/Math.sqrt((r-g)*(r-g)+(r-b)*(g-b)+1))/(2*Math.PI);
				hue[i]=((b<=g)?theta:(1-theta));
				sat[i]=1-3*Math.min(Math.min(r,g),b)/(r+g+b);
				inten[i]=Math.floor((r+g+b)/3);
				}
			//仅对亮度进行均衡化处理
			inten=equalization(inten);
			//HSI空间转化为RGB空间
			for(var i=0;i<bytes;i++){
				r=rgbValues[i*4];
				g=rgbValues[i*4+1];
				b=rgbValues[i*4+2];
				hue[i]=hue[i]*2*Math.PI;
				if(hue[i]>=0&&hue[i]<2*Math.PI/3){
					b=inten[i]*(1-sat[i]);
					r=inten[i]*(1+sat[i]*Math.cos(hue[i])/Math.cos(Math.PI/3-hue[i]));
					g=3*inten[i]-(r+b);
					}
				else if(hue[i]>=2*Math.PI/3&&hue[i]<4*Math.PI/3){
					r=inten[i]*(1-sat[i]);
					g=inten[i]*(1+sat[i]*Math.cos(hue[i]-2*Math.PI/3)/Math.cos(Math.PI-hue[i]));
					b=3*inten[i]-(r+g);
					}
				else{
					g=inten[i]*(1-sat[i]);
					b=inten[i]*(1+sat[i]*Math.cos(hue[i]-4*Math.PI/3)/Math.cos(5*Math.PI/3-hue[i]));
					r=3*inten[i]-(g+b);
					}
				if(r>255)
				r=255;
				if(g>255)
				g=255;
				if(b>255)
				b=255;
				rgbValues[i*4]=r;
				rgbValues[i*4+1]=g;
				rgbValues[i*4+2]=b;
				}
			}
		return rgbValues;
		}
	}
//灰度图像均衡化方法
function equalization(colorArray){
	var comValues=colorArray.slice(0),countPixel=[],temp,tempArray=[],pixelMap=[];
	for(var i=0;i<comValues.length;i++){
		temp=comValues[i];
		countPixel[temp]++;
		}
	//计算各灰度级的累积分布函数
	for(var i=0;i<256;i++){
		if(i!=0){
			tempArray[i]=tempArray[i-1]+countPixel[i];
			}
		else{
			tempArray[0]=countPixel[0];
			}
		pixelMap[i]=Math.floor(255*tempArray[i]/comValues.length+.5);
		}
	for(var i=0,len=comValues.length;i<len;i++){
		temp=comValues[i];
		comValues[i]=pixelMap[temp];
		}
	}
//彩色图像平滑处理原理
function smoc(src,method,side){
	if(src&&src.data){
		var width=src.width,height=src.height,bytes=width*height,rgbValues=src.data,method=method,sideL=side;
		if(method==false){
			//RGB空间
			rValues=[],gValues=[],bValues=[];
			for(var i=0;i<bytes;i++){
				rValues[i]=rgbValues[i*4];
				gValues[i]=rgbValues[i*4+1];
				bValues[i]=rgbValues[i*4+2];
				}
			//RGB 空间
			rValues=smooth(rValues,sideL,width,height);
			gValues=smooth(gValues,sideL,width,height);
			bValues=smooth(bValues,sideL,width,height);
			for(var i=0;i<bytes;i++){
				rgbValues[i*4]=rValues[i];
				rgbValues[i*4+1]=gValues[i];
				rgbValues[i*4+2]=bValues[i];
				}
			}
		else{
			//HSI 空间
			var hue=[],sat=[],inten=[],r,g,a;
			//RGB空间转换为HSI空间
			for(var i=0;i<bytes;i++){
				r=rgbValues[i*4];
				g=rgbValues[i*4+1];
				b=rgbValues[i*4+2];
				var theta=Math.acos(.5*(r-g)+(r-b)/Math.sqrt((r-g)*(r-g)+(r-b)*(g-b)+1))/(2*Math.PI);
				hue[i]=(b<=g)?theta:(1-theta);
				sat[i]=1-3*Math.min(Math.min(r,g),b)/(r+g+b+1);
				inten[i]=Math.floor((r+g+b)/3);
				}
			//亮度调用平滑方法
			inten=smooth(inten,sideL,width,height);
			for(var i=0;i<bytes;i++){
				r=rgbValues[i*4];
				g=rgbValues[i*4+1];
				b=rgbValues[i*4+2];
				hue[i]=hue[i]*2*Math.PI;
				if(hue[i]>=0&&hue[i]<2*Math.PI/3){
					b=inten[i]*(1-sat[i]);
					r=inten[i]*(1+sat[i]*Math.cos(hue[i])/Math.cos(Math.PI/3-hue[i]));
					g=3*inten[i]-(r+b);
					}
				else if(hue[i]>=2*Math.PI/3&&hue[i]<4*Math.PI/3){
					r=inten[i]*(1-sat[i]);
					g=inten[i]*(1+sat[i]*Math.cos(hue[i]-2*Math.PI/3)/Math.cos(Math.PI-hue[i]));
					b=3*inten[i]-(r+g);
					}
				else{
					g=inten[i]*(1-sat[i]);
					b=inten[i]*(1+sat[i]*Math.cos(hue[i]-4*Math.PI/3)/Math.cos(5*Math.PI/3-hue[i]));
					r=3*inten[i]-(g+b);
					}
				if(r>255)
				r=255;
				if(g>255)
				g=255;
				if(b>255)
				b=255;
				rgbValues[i*4]=Math.floor(r);
				rgbValues[i*4+1]=Math.floor(g);
				rgbValues[i*4+2]=Math.floor(b);
				}
			}
			return rgbValues;
		}
	}
//灰度值平滑函数
function smooth(comValues,sideLength,w,h){
	var halfLength=[],comS=comValues.slice(0),comD=[],width=w,height=h;
	switch(sideLength){
		case 3:
		//3x3的模板
		for(var i=0;i<height;i++){
			for(var j=0;j<width;i++){
				comD[i*width+j]=Math.floor((comS[i*width+j]+comS[Math.abs(i-1)%height*width+j]+comS[(i+1)%height*width+j]+comS[i*width+(j+1)%width]+comS[i*width+Math.abs(j-1)%width]+comS[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+comS[(i+1)%height*width+Math.abs(j-1)%width]+comS[Math.abs(i-1)%height*width+(j+1)%width]+comS[(i+1)%height*width+(j+1)%width])/9);
				}
			}
		break;
		case 5:
		//5x5模板
		for(var i=0;i<height;i++){
			for(var j=0;j<width;i++){
				comD[i*width+j]=Math.floor((comS[Math.abs(i-2)%height*width+Math.abs(j-2)%width]+comS[Math.abs(i-2)%height*width+Math.abs(j-1)%width]+comS[Math.abs(i-2)%height*width+j]+comS[Math.abs(i-2)%height*width+(j+1)%width]+comS[Math.abs(i-2)%height*width+(j+2)%width]+comS[Math.abs(i-1)%height*width+Math.abs(j-2)%width]+comS[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+comS[Math.abs(i-1)%height*width+j]+comS[Math.abs(i-1)%height*width+(j+1)%width]+comS[Math.abs(i-1)%height*width+(j+2)%width]+comS[i*width+Math.abs(j-2)%width]+comS[i*width+Math.abs(j-1)%width]+comS[i*width+j]+comS[i*width+(j+1)%width]+comS[i*width+(j+2)%width]+comS[(i+1)%height*width+Math.abs(j-2)%width]+comS[(i+1)%height*width+Math.abs(j-1)%width]+comS[(i+1)%height*width+j%width]+comS[(i+1)%height*width+(j+1)%width]+comS[(i+1)%height*width+(j+2)%width]+comS[(i+2)%height*width+Math.abs(j-2)%width]+comS[(i+2)%height*width+Math.abs(j-1)%width]+comS[(i+2)%height*width+j%width]+comS[(i+2)%height*width+Math.abs(j+1)%width]+comS[(i+2)%height*width+(j+2)%width])/25);
				}
			}
		break;
		case 7:
		//7x7 模板
		for(var i=0;i<height;i++){
			for(var j=0;j<width;j++){
				comD[i*width+j]=Math.floor((comS[Math.abs(i-2)%height*width+Math.abs(j-2)%width]+comS[Math.abs(i-2)%height*width+Math.abs(j-1)%width]+comS[Math.abs(i-2)%height*width+j]+comS[Math.abs(i-2)%height*width+(j+1)%width]+comS[Math.abs(i-2)%height*width+(j+2)%width]+comS[Math.abs(i-1)%height*width+Math.abs(j-2)%width]+comS[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+comS[Math.abs(i-1)%height*width+j]+comS[Math.abs(i-1)%height*width+(j+1)%width]+comS[Math.abs(i-1)%height*width+(j+2)%width]+comS[i*width+Math.abs(j-2)%width]+comS[i*width+Math.abs(j-1)%width]+comS[i*width+j]+comS[i*width+(j+1)%width]+comS[i*width+(j+2)%width]+comS[(i+1)%height*width+Math.abs(j-2)%width]+comS[(i+1)%height*width+Math.abs(j-1)%width]+comS[(i+1)%height*width+j%width]+comS[(i+1)%height*width+(j+1)%width]+comS[(i+1)%height*width+(j+2)%width]+comS[(i+2)%height*width+Math.abs(j-2)%width]+comS[(i+2)%height*width+Math.abs(j-1)%width]+comS[(i+2)%height*width+j%width]+comS[(i+2)%height*width+Math.abs(j+1)%width]+comS[(i+2)%height*width+(j+2)%width]+comS[Math.abs(i-3)%height*width+Math.abs(j-3)%width]+comS[Math.abs(i-3)%height*width+Math.abs(j-2)%width]+comS[Math.abs(i-3)%height*width+Math.abs(j-1)%width]+comS[Math.abs(i-3)%height*width+j]+comS[Math.abs(i-3)%height*width+(j+1)%width]+comS[Math.abs(i-3)%height*width+(j+2)%width]+comS[Math.abs(i-3)%height*width+(j+3)%width]+comS[(i+3)%height*width+Math.abs(j-3)%width]+comS[(i+3)%height*width+Math.abs(j-2)%width]+comS[(i+3)%height*width+Math.abs(j-1)%width]+comS[(i+3)%height*width+j]+comS[(i+3)%height*width+Math.abs(j+2)%width]+comS[(i+3)%height*width+(j+3)%width]+comS[(i+2)%height*width+Math.abs(j-3)%width]+comS[(i+1)%height*width+Math.abs(j-3)%width]+comS[i*width+Math.abs(j-3)%width]+comS[Math.abs(i-1)%height*width+Math.abs(j-3)%width]+comS[Math.abs(i-2)%height*width+Math.abs(j-3)%width]+comS[(i+2)%height*width+(j+3)%width]+comS[(i+1)%height*width+(j+3)%width]+comS[i*width+(j+3)%width]+comS[Math.abs(i-1)%height*width+(j+3)%width]+comS[Math.abs(i-2)%height*width+(j+3)%width])/49)
				}
			}
		break;
		//彩色图像锐化
		function shac(src,method){
			if(src&&src.data){
				var width=src.width,height=src.height,rgbValues=src.data,bytes=width*height,method=method;
				if(method==false){
					//RGB空间
					var rValues=[],gValues=[],bValues=[];
					for(var i=0;i<bytes;i++){
						rValues[i]=rgbValues[i*4];
						gValues[i]=rgbValues[i*4+1];
						bValues[i]=rgbValues[i*4+2];
						}
					rValues=sharp(rValues,width,height);
					gValues=sharp(gValues,width,height);
					bValues=sharp(bValues,width,height);
					for(var i=0;i<bytes;i++){
						rgbValues[i*4]=rValues[i];
						rgbValues[i*4+1]=gValues[i];
						rgbValues[i*4+2]=bValues[i];
						}
					}
					else{
						//HSI 空间
						var hue=[],sat=[],inten=[],r,g,b;
						//RGB空间转化为HSI空间
						for(var i=0;i<bytes;i++){
							r=rgbValues[i*4];
							g=rgbValues[i*4+1];
							b=rgbValues[i*4+2];
							var theta=Math.abs(.5*((r-g)+(r-b))/Math.sqrt((r-g)*(r-g)+(r-b)*(g-b)+1))/(2*Math.PI);
							hue[i]=(b<g)?theta:(1-theta);
							sat[i]=1-3*Math.min(Math.min(r,g),b)/(r+g+b+1);
							inten[i]=Math.floor((r+g+b)/3);
							}
						//调用锐化函数
						inten=sharp(inten,width,height);
						//HSI空间转换为RGB空间
						for(var i=0;i<bytes;i++){
							r=rgbValues[i*4];
							g=rgbValues[i*4+1];
							b=rgbValues[i*4+2];
							hue[i]=hue[i]*2*Math.PI;
							if(hue[i]>=0&&hue[i]<2*Math.PI/3){
								b=inten[i]*(1-sat[i]);
								r=inten[i]*(1+sat[i]*Math.cos(hue[i])/Math.cos(Math.PI/3-hue[i]));
								g=3*inten[i]-(r+b);
								}
							else if(hue[i]>=2*Math.PI/3&&hue[i]<4*Math.PI/3){
								r=inten[i]*(1-sat[i]);
								g=inten[i]*(1+sat[i]*Math.cos(hue[i]-2*Math.PI/3)/Math.cos(Math.PI-hue[i]));
								b=3*inten[i]-(r+g);
								}
							else{
								g=inten[i]*(1-sat[i]);
								b=inten[i]*(1+sat[i]*Math.cos(hue[i]-4*Math.PI/3)/Math.cos(5*Math.PI/3-hue[i]));
								r=3*inten[i]-(g+b);
								}
							if(r>255)
							r=255;
							if(g>255)
							g=255;
							if(b>255)
							b=255;	
							rgbValues[i*4]=Math.floor(r);
							rgbValues[i*4+1]=Math.floor(g);
							rgbValues[i*4+2]=Math.floor(b);
							}
						}
				}
			}
			return rgbValues;
		}
	}
	//灰度值锐化函数
	function sharp(comArray,w,h){
		var comValues=[],width=w,height=h;
		for(var i=0;i<height;i++){
			for(var j=0;j<width;j++){
				comValues[i*width+j]=(5*comArray[i*width+j]-(comArray[Math.abs(i-1)%height*width+j]+comArray[(i+1)%height*width+j]+comArray[i*width+(j+1)%width]+comArray[i*width+Math.abs(j-1)%width]));
				}
			}
			return comArray;
		}
	//彩色图像边缘检测
	function edgeC(src,method,thresh){
		if(src&&src.data){
			var width=src.width,height=src.height,rgbValues=src.data,bytes=width*height,method=method,thresh=thresh,grayValue=[],tempArray=[],rValues=[],gValues=[],bValues=[];
			for(var i=0;i<bytes;i++){
				rValues[i]=rgbValues[i*4];
				gValues[i]=rgbValues[i*4+1];
				bValues[i]=rgbValues[i*4+2];
				}
			var maxV=0,minV=1000;
			switch(method){
				case 0:
				var grh,ggh,gbh,grv,ggv,gbv,gxx,gyy,gxy,ge1,ge2,theta;
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						//利用sobel求便导
						grh=rValues[Math.abs(i-1)%height*width+(j+1)%width]+2*rValues[i*width+(j+1)%width]+rValues[(i+1)%height*width+(j+1)%width]-rValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-2*rValues[i*width+Math.abs(j-1)%width]-rValues[(i+1)%height*width+Math.abs(j-1)%width];
						ggh=gValues[Math.abs(i-1)%height*width+(j+1)%width]+2*gValues[i*width+(j+1)%width]+gValues[(i+1)%height*width+(j+1)%width]-gValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-2*gValues[i*width+Math.abs(j-1)%width]-gValues[(i+1)%height*width+Math.abs(j-1)%width];
						gbh=bValues[Math.abs(i-1)%height*width+(j+1)%width]+2*bValues[i*width+(j+1)%width]+bValues[(i+1)%height*width+(j+1)%width]-bValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-2*bValues[i*width+Math.abs(j-1)%width]-bValues[(i+1)%height*width+Math.abs(j-1)%width];
						grv=rValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+2*rValues[Math.abs(i-1)%height*width+j]+rValuesp[Math.abs(i-1)%height*width+(j+1)%width]-rValues[(i+1)%height*width+Math.abs(j-1)%width]-2*rValues[(i+1)%height*width+j]-rValues[(i+1)%height*width+(j+1)%width];
						ggv=gValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+2*gValues[Math.abs(i-1)%height*width+j]+gValues[Math.abs(i-1)%height*width+(j+1)%width]-gValues[(i+1)%height*width+Math.abs(j-1)%width]-2*gValues[(i+1)%height*width+j]-gValues[(i+1)%height*width+(j+1)%width];
						gbv=bValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+2*bValues[Math.abs(i-1)%height*width+j]+bValues[Math.abs(i-1)%height*width+(j+1)%width]-bValues[(i+1)%height*width+Math.abs(j-1)%width]-2*bValues[(i+1)%height*width+j]-bValues[(i+1)%height*width+(j+1)%width];
						//向量点积
						gxx=grh*grh+ggh*ggh+gbh*gbh;
						gyy=grv*grv+ggv*ggv+gbv*gbv;
						gxy=grh*grv+ggh*ggv+gbh*gbv;
						//最大变化率的方向角度
						theta=Math.atan(2*gxy/(gxx-gyy+.000000001))/2;
						//梯度
						ge1=((gxx+gyy)+(gxx-gyy)*Math.cos(2*theta)+2*gxy*Math.sin(2*theta))/2;
						theta=theta+Math.PI/2;
						ge2=((gxx+gyy)+(gxx-gyy)*Math.cos(2*theta)+2*gxy*Math.sin(2*theta))/2;
						//最终的梯度值
						tempArray[i*width+j]=Math.max(Math.sqrt(ge1),Math.sqrt(ge2));
						//确定灰度范围
						if(tempArray[i*width+j]>maxV)
						maxV=tempArray[i*width+j];
						else if(tempArray[i*width+j]<minV)
						minV=tempArray[i*width+j];
						}
					}
					//灰度值拉伸到[0,255]
					for(var i=0;i<bytes;i++){
						grayValue[i]=Math.floor(tempArray[i]-minV)*255/(maxV-minV);
						}
				break;
				case 1:
				//向量法II
				var gr,gg,gb,de1,de2;
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						//结合sobel法，计算欧式距离
						gr=rValues[Math.abs(i-1)%height*width+(j+1)%width]+2*rValues[i*width+(j+1)%width]+rValues[(i+1)%height*width+(j+1)%width]-rValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-2*rValues[i*width+Math.abs(j-1)%width]-rValues[(i+1)%height*width+Math.abs(j-1)%width]
						gg=gValues[(i-1)%height*width+(j+1)%width]+2*gValues[i*width+(j+1)%width]+gValues[(i+1)%height*width+(j+1)%width]-gValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-2*gValues[i*width+Math.abs(j-1)%height*width]-gValues[(i+1)%height*width+Math.abs(j-1)%width];
						gb=bValues[(i-1)%height*width+(j+1)%width]+2*bValues[i*width+(j+1)%width]+bValues[(i+1)%height*width+(j+1)%width]-bValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-2*bValues[i*width+Math.abs(j-1)%height*width]-bValues[(i+1)%height*width+Math.abs(j-1)%width];
						de1=Math.sqrt(gr*gr+gg*gg+gb*gb);
						gr=rValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+2*rValues[Math.abs(i-1)%height*width+j]+rValues[Math.abs(i-1)%height*width+(j+1)%width]-rValues[(i+1)%height*width+Math.abs(j-1)%width]-2*rValues[(i+1)%height*width+j]-rValues[(i+1)%height*width+(j+1)%width];
						gg=gValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+2*gValues[Math.abs(i-1)%height*width+j]+gValues[Math.abs(i-1)%height*width+(j+1)%width]-gValues[(i+1)%height*width+Math.abs(j-1)%width]-2*gValues[(i+1)%height*width+j]-gValues[(i+1)%height*width+(j+1)%width];
						gb=bValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]+2*bValues[Math.abs(i-1)%height*width+j]+bValues[Math.abs(i-1)%height*width+(j+1)%width]-bValues[(i+1)%height*width+Math.abs(j-1)%width]-2*bValues[(i+1)%height*width+j]-bValues[(i+1)%height*width+(j+1)%width];
						de2=Math.sqrt(gr*gr+gg*gg+gb*gb);
						//最终梯度值
						tempArray[i*width+j]=Math.abs(de1,de2);
						//确定范围
						if(tempArray[i*width+j]>maxV)
						maxV=tempArray[i*width+j];
						else if(tempArray[i*width+j]<minV)
						minV=tempArray[i*width+j];
					}
				}
				//灰度值拉伸到[0,255]
				for(var i=0;i<bytes;i++){
					grayValue[i]=Math.floor(tempArray[i]-minV)*255/(maxV-minV);
					}
				break;
				case 2:
				//RGB分量直接梯度法
				var rvg=[],gvg=[],bvg=[],gh,gv,maxValue=[0,0,0],minValue=[1000,1000,1000];
				for(var i=0;i<height;i++){
					for(var j=0;j<width;j++){
						//红色分量的sobel
						gh=rValues[Math.abs(i-1)%height*width+(j+1)%width]+2*rValues[i*width+(j+1)%width]+rValues[(i+1)%height*width+(j+1)%width]-rValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-2*rValues[i*width+Math.abs(j-1)%width]-rValues[(i+1)%height*width+Math.abs(j-1)%width];
						gv=rValues[Math.abs(i-1)%height*width+Math.abs(j-1)]+2*rValues[Math.abs(i-1)%height*width+j]+rValues[Math.abs(i-1)%height*width+(j+1)%width]-rValues[(i+1)%height*width+Math.abs(j-1)%width]-2*rValues[(i+1)%height*width+j]-rValues[(i+1)%height*width+(j+1)%width];
						rvg[i*width+j]=Math.sqrt(gh*gh+gv*gv);
						if(rvg[i*width+j]>maxValue[0])
						maxValue[0]=rvg[i*width+j];
						else if(rvg[i*width+j]<minValue[0])
						minValue[0]=rvg[i*width+j];
						//绿色分量的sobel
						gh=gValues[Math.abs(i-1)%height*width+(j+1)%width]+2*gValues[i*width+(j+1)%width]+gValues[(i+1)%height*width+(j+1)%width]-gValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-2*gValues[i*width+Math.abs(j-1)%width]-gValues[(i+1)%height*width+Math.abs(j-1)%width];
						gv=gValues[Math.abs(i-1)%height*width+Math.abs(j-1)]+2*gValues[Math.abs(i-1)%height*width+j]+gValues[Math.abs(i-1)%height*width+(j+1)%width]-gValues[(i+1)%height*width+Math.abs(j-1)%width]-2*gValues[(i+1)%height*width+j]-gValues[(i+1)%height*width+(j+1)%width];
						gvg[i*width+j]=Math.sqrt(gh*gh+gv*gv);
						if(gvg[i*width+j]>maxValue[1])
						maxValue[1]=gvg[i*width+j];
						else if(gvg[i*width+j]<minValue[1])
						minValue[1]=gvg[i*width+j];
						//蓝色分量的sobel
						gh=bValues[Math.abs(i-1)%height*width+(j+1)%width]+2*bValues[i*width+(j+1)%width]+bValues[(i+1)%height*width+(j+1)%width]-bValues[Math.abs(i-1)%height*width+Math.abs(j-1)%width]-2*bValues[i*width+Math.abs(j-1)%width]-bValues[(i+1)%height*width+Math.abs(j-1)%width];
						gv=bValues[Math.abs(i-1)%height*width+Math.abs(j-1)]+2*bValues[Math.abs(i-1)%height*width+j]+bValues[Math.abs(i-1)%height*width+(j+1)%width]-bValues[(i+1)%height*width+Math.abs(j-1)%width]-2*bValues[(i+1)%height*width+j]-bValues[(i+1)%height*width+(j+1)%width];
						bvg[i*width+j]=Math.sqrt(gh*gh+gv*gv);
						if(bvg[i*width+j]>maxValue[1])
						maxValue[2]=bvg[i*width+j];
						else if(bvg[i*width+j]<minValue[1])
						minValue[2]=bvg[i*width+j];
						}
					}
					//灰度值拉伸到[0,255]
					for(var i=0;i<bytes;i++){
						rgbValues[i*4]=Math.floor(rvg[i]-minValue[0])*255/(maxValue[0]-minValue[0]);
						rgbValues[i*4+1]=Math.floor(gvg[i]-minValue[1])*255/(maxValue[1]-minValue[1]);
						rgbValues[i*4+2]=Math.floor(bvg[i]-minValue[2])*255/(maxValue[2]-minValue[2]);
						gh=Math.max(rvg[i]-minValue[0])*255/(maxValue[0]-minValue[0],gvg[i]-minValue[1])*255/(maxValue[1]-minValue[1]);
						gv=Math.max(gh,bvg[i]-minValue[2])*255/(maxValue[2]-minValue[2]);
						grayValue[i]=Math.floor(gv);
						}
						break;
						default:
						break;
				}
				//阈值处理成二维边缘图像,如果为0,则保留为灰度边缘图像
				if(thresh!=0){
					for(var i=0;i<bytes;i++){
						if(grayValue[i]>thresh)
						grayValue[i]=255;
						else
						grayValue[i]=0;
						}
					}
				return grayValue;
			}
		}
//彩色图像分割
function segC(src,num){
	if(src&&src.data){
		var width=src.width,height=src.height,rgbValues=src.data,bytes=width*height,numbers=num;
		var kNum=[],kAver=[],kOldAver=[],kSum=[],kTemp=[],segmentMap=[];
		//初始化聚类均值
		for(var i=0;i<numbers;i++){
			kAver[i*4]=kOldAver[i*4]=Math.floor(i*255/(numbers-1));
			kAver[i*4+1]=kOldAver[i*4+1]=Math.floor(i*255/(numbers-1));
			kAver[i*4+2]=kOldAver[i*4+2]=Math.floor(i*255/(numbers-1));
			}
			var count=0;
			while(true){
				var order=0;
				for(var i=0;i<numbers;i++){
					kNum[i]=0;
					kSum[i*4]=kSum[i*4+1]=kSum[i*4+2]=0;
					kAver[i*4+2]=kOldAver[i*4+2];
					kAver[i*4+1]=kOldAver[i*4+1];
					kAver[i*4]=kOldAver[i*4];
					}
					//归属聚类
				for(var i=0;i<bytes;i++){
					for(var j=0;j<numbers;j++){
						//计算欧式距离
					kTemp[j]=Math.pow(rgbValues[i*4+2]-kAver[i*4+2],2)+Math.pow(rgbValues[i*4+1]-kAver[i*4+1],2)+Math.pow(rgbValues[i*4]-kAver[i*4],2);
					}
					var temp=1000000;
					for(var j=0;j<numbers;j++){
						if(kTemp[i]<temp){
							temp=kTemp[i];
							order=j;
							}
						}
					kNum[order]++;
					kSum[order*4+2]+=rgbValues[order*4+2];
					kSum[order*4+1]+=rgbValues[order*4+1];
					kSum[order*4]+=rgbValues[order*4];
					segmentMap[i]=Math.floor(order);
					}
				//更新聚类
					for(var i=0;i<numbers;i++){
						if(kNum[i]!=0){
							kOldAver[i*4+2]=Math.floor(kSum[i*4+2]/kNum[i]);
							kOldAver[i*4+1]=Math.floor(kSum[i*4+1]/kNum[i]);
							kOldAver[i*4]=Math.floor(kSum[i*4]/kNum[i]);
							}
						}
					//终止迭代
					var kkk=0;
					count++;
					for(var i=0;i<numbers;i++){
						if(kAver[i*4+2]==kOldAver[i*4+2]&&kAver[i*4+1]==kOldAver[i*4+1]&&kAver[i*4]==kOldAver[i*4]){
							kkk++;
							}
						if(kkk==numbers||count==100)
						break;
						}
					//聚类赋值
					for(var i=0;i<bytes;i++){
						for(var j=0;j<numbers;j++){
							if(segmentMap[i]==j){
								rgbValues[i*4+2]=Math.floor(kAver[i*4+2]);
								rgbValues[i*4+1]=Math.floor(kAver[i*4+1]);
								rgbValues[i*4]=Math.floor(kAver[i*4]);
								}
							}
						}
				}
				return rgbValues;
		}
	}
//雕刻效果函数
function emboss(src){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,r,g,b;
		for(var i=0;i<height-1;i++){
			for(var j=0;i<(width-1)*4;i++){
				b=Math.abs(data[i*width*4+j]-data[i*width*4+j+4]+128);
				g=Math.abs(data[i*width*4+j+1]-data[i*width*4+j+5]+128);
				r=Math.abs(data[i*width*4+j+2]-data[i*width*4+j+6]+128);
				if(r>255)
				r=255;
				if(g>255)
				g=255;
				if(b>255)
				b=255;
				data[i*width*4+j]=Math.floor(r);
				data[i*width*4+j+1]=Math.floor(g);
				data[i*width*4+j+2]=Math.floor(b);
				}
			}
			for(var k=width*4*(height-1);k<width*4*height;k+=4){
				data[k]=128;
				data[k+1]=128;
				data[k+2]=128;
				}
			for(var l=(width-1)*4;l<width*4*height;l+=width*4){
				data[l]=128;
				data[l+1]=128;
				data[l+2]=128;
				}
		return data;
		}
	}
//黑白效果的函数
function colorToBW(src){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,sum=data.length;
		for(var i=0;i<sum;i+=4){
			//平均值法
			data[i]=(data[i]+data[i+1]+data[i+2])/3;
			data[i+1]=data[i];
			data[i+2]=data[i];
			//最大值法
			/*
			data[i]=data[i]>data[i+1]?data[i]:data[i+1];
			data[i]=data[i]>data[i+2]?data[i]:data[i+2];
			data[i+1]=data[i];
			data[i+2]=data[i];
			*/
			//加权平均值
			/*
			data[i]=Math.floor(data[i]*.5)+Math.floor(data[i+1]*.3)+Math.floor(data[i+2]*.2);
			data[i+1]=data[i];
			data[i+2]=data[i];
			*/
			}
		}
	}
//水平方式雾化效果函数
function horFog(src,f){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,k,n,out=[];
		for(var i=0;i<height;i++){
			for(var j=0;j<width*4;j+=4){
				k=Math.abs(Math.round(Math.random()*f));
				n=j+k*4;
				if(n>(width-1)*4)
				n=(width-1)*4
				out[i*width*4+j]=data[i*width*4+n];
				out[i*width*4+j+1]=data[i*width*4+n+1];
				out[i*width*4+j+2]=data[i*width*4+n+2];
				out[i*width*4+j+3]=data[i*width*4+n+3];
				}
			}
		}
	}
//垂直方式雾化效果函数
function verFog(src,f){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,k,m,out=[];
		for(var i=0;i<height;i++){
			for(var j=0;j<width*4;j+=4){
				k=Math.abs(Math.round(Math.random()*f));
				m=i+k;
				if(m>height-1)
				m=height-1;
				out[i*width*4+j]=data[m*width*4+j];
				out[i*width*4+j+1]=data[m*width*4+j+1];
				out[i*width*4+j+2]=data[m*width*4+j+2];
				out[i*width*4+j+3]=data[m*width*4+j+3];
				}
				}
		}
	}
//复合方式的雾化函数
function comFog(src,f){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,k,m,n,out=[];
		for(var i=0;i<height;i++){
			for(var j=0;j<width*4;j+=4){
				k=Math.abs(Math.round(Math.random()*f));
				m=i+k;
				n=j+k*4;
				if(m>height-1)
				m=height-1;
				if(n>(width-1)*4)
				n=(width-1)*4;
				out[i*width*4+j]=data[m*width*4+n];
				out[i*width*4+j+1]=data[m*width*4+n+1];
				out[i*width*4+j+2]=data[m*width*4+n+2];
				out[i*width*4+j+3]=data[m*width*4+n+3];
				}
			}
		}
	}
//使用模板对彩色图领域进行运算
function templtExcutecl(src,width,height,templt,tw,x,y){
	var i,j,m=0,px,py;
	for(var i=0;i<tw;i++){
		for(var j=0;j<tw;j++){
			py=Math.floor(Math.abs(y-tw/2+i));
			px=Math.floor(Math.abs(x-tw/2+j));
			m+=src[py*width+px]*templt[i*tw+j];
			}
		}
		return m;
	}
//实现图像的素描效果
function laplacianB(src){
	if(src&&src.data){
		var width=src.width,height=src.height,data=grayValues(src),tempImage=[],out=[],scale=2,templt=[1,1,1,1,-8,1,1,1,1],templtTest1=[1,1,-1,1,0,-1,1,-1,-1],templtTest2=[1,1,1,-1,0,1,-1,-1,-1],templtAve=[1,1,1,1,4,1,1,1,1],x,y,a,b,b1,b2;
		//依次对原图像的每个像素进行处理
		for(var y=1;y<height-1;y++){
			for(var x=1;x<width-1;x++){
				a=templtExcutecl(data,templt,3,x,y);
				b1=Math.abs(templtExcutecl(data,width,height,templtTest1,3,x,y));
				b2=Math.abs(templtExcutecl(data,width,height,templtTest2,3,x,y));
				b=b1>b2?b1:b2;
				if(b<25)
				a=0;
				else{
					a=Math.abs(a*scale);
					if(a>255)
					a=255;
					else if(a<32)
					a=0;
					}
				a=255-a;//反色处理
				tempImage[(y*width+x)*4]=a;
				tempImage[(y*width+x)*4+1]=a;
				tempImage[(y*width+x)*4+2]=a;
				}
			}
			for(var y=1;y<height-1;y++){
				for(var x=1;x<width-1;x++){
					a=Math.floor(templtExcutecl(tempImage,width,height,templtAve,3,x,y)/12);
					out[(y*width+x)*4]=a;
					out[(y*width+x)*4+1]=a;
					out[(y*width+x)*4+2]=a;
					}
				}
		return out;	
		}
	}
	//颜色空间RGB转换为HSV
	function rgbToHsv(r,g,b){
		var h,s,v;
		h=Math.acos(r-g+r-b)/(2*Math.sqrt(r-g)*(r-g)+(r-b)*(g-b));
		if(b>g)
		h=2*Math.PI-h;
		s=Math.max(r,g,b)-Math.min(r,g,b)/Math.max(r,g,b);
		v=Math.max(r,g,b)/255;
		return [h,s,v];
		}
//颜色直方图提取函数
function general(src,mode){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,totalNum=height*width,m_graph=[],feature_color=[],feature_color_1=[];
		for(var i=0;i<3;i++){
			m_graph[i]=[];
			feature_color[i]=[];
			feature_color_1[i]=[];
			for(var j=0;j<12;j++){
				m_graph[i][j]=0;
				if(mode==1)
				feature_color[i][j]=0;
				else
				feature_color_1[i][j]=0
				}
			var h=0,s=0,v=0,hsv;
			//计算颜色直方图
			for(var y=0;y<height;y++){
				for(var x=0;x<width;x++){
					var r,g,b;
					r=data[(y*width+x)*4];
					g=data[(y*width+x)*4+1];
					b=data[(y*width+x)*4+2];
					hsv=rgbToHsv[r,g,b];
					h=hsv[0],v=hsv[1],v=hsv[2];
					var result_h=Math.floor(6*h/Math.PI);
					if(result_h==12)
					m_graph[0][11]++;
					else
					m_graph[0][result_h]++;
					var result_s=Math.floor(s*12);
					if(result_s==12)
					m_graph[1][11]++;
					else
					m_graph[1][result_s]++;
					var result_v=Math.floor(s*12);
					if(result_v==12)
					m_graph[2][11]++;
					else
					m_graph[2][result_v]++;
					}
				}
				//保存颜色直方图
				if(mode==1){
					for(var i=0;i<3;i++){
						for(var j=0;j<12;j++){
							feature_color[i][j]=m_graph[i][j]/totalNum;
							}
						}
					return feature_color;
					}
				else{
					for(var i=0;i<3;i++){
						for(var j=0;j<12;j++){
							feature_color_1[i][j]=m_graph[i][j]/totalNum;
							}
						}
					return feature_color_1;
					}
			}
		}
	}
function centerM(src){
	var width=src.width,height=src.height,totalnum=width*height,data=src.data,grayValue=grayValues(src),hsv,r,g,b,h,s,v;
	for(var y=0;y<height;y++){
		for(var x=0;x<width;x++){
			r=data[(y*width+x)*4];
			g=data[(y*width+x)*4+1];
			b=data[(y*width+x)*4+2];
			hsv=rgbToHsv(r,g,b);
			h=hsv[0],s=hsv[1],v=hsv[2];
			var result_h=Math.floor(6*h/Math.PI);
			if(result_h==12)
			m_graph[0][11]++
			else
			m_graph[0][result_h]++;
			var result_s=Math.floor(s*12);
			if(result_s==12)
			m_graph[1][11]++;
			else
			m_graph[1][result_s]++;
			var result_v=Math.floor(v*12);
			if(result_v==12)
			m_graph[2][11]++;
			else
			m_graph[2][result_v]++;
			}
		}
		for(var i=0;i<3;i++){
			for(var j=0;j<12;j++){
				m_graph[i][j]=m_graph[i][j]/totalnum;
				}
		var m1=[],m2=[],m3=[];
		for(var i=0;i<3;i++){
			m1[i]=0;
			m2[i]=0;
			m3[i]=0;
			}
			for(var i=0;i<3;i++){
				for(var j=0;j<12;j++){
					m1[i]+=m_graph[i][j]/12;
					}
				}
				for(var i=0;i<3;i++){
					for(var j=0;j<12;j++){
						m2[i]+=(m_graph[i][j]-m1[i])*(m_graph[i][j]-m1[i])/12;
						m3[i]+=(m_graph[i][j]-m1[i])*(m_graph[i][j]-m1[i])*(m_graph[i][j]-m1[i])/12;
						}
					}
				var zz=1/3;
				for(var i=0;i<3;i++){
					m2[i]=Math.sqrt(m2[i]);
					m3[i]=Math.pow(m3[i],zz);
					}
			}
	}
//	函数
function torque(src,mode){
	if(src&&src.data){
		var width=src.width,height=src.height,totalnum=width*height,data=src.data,grayValue=grayValues(src);
		var index_max,g_max=0;
		for(var index=0;index<256;index++){
			var c0=c1=sum_0=sum_1=w0=w1=u0=u1=g=0;
			for(var x=0;x<width;x++){
				for(var y=0;y<height;y++){
					if(grayValue[y*width+x]<index){
						sum_0=sum_0+grayValue[y*width+x];
						c0++;
						}
					else{
						sum_1=sum_1+grayValue[y*width+x];
						c1++;
						}
					}
				}
			w0=c0/(c0+c1);
			w1=c1/(c0+c1);
			if(c0==0)
			u0=0;
			else
			u0=sum_0/c0;
			if(c1==0)
			u1=0;
			else
			u1=sum_1/c1;
			g=w0*w1*(u0-u1)*(u0-u1);
			if(g>g_max){
				g_max=g;
				index_max=index;
				}
			}
		//根据所求阈值进行阈值分割
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				if(grayValue[y*width+x]<index_max)
				grayValue[y*width+x]=0;
				else
				grayValue[y*width+x]=1;
				}
			}
		//对分割后的区域进行不变矩的提取
		var m00=0;
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				m00+=grayValue[y*width+x];
				}
			}
		var m10=0;
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				m10+=(x+1)*grayValue[y*width+x];
				}
			}
		var m01=0;
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				m01+=(y+1)*grayValue[y*width+x];
				}
			}
		var m11=0;
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				m11+=(y+1)*(x+1)*grayValue[y*width+x];
				}
			}
		var m20=0;
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				m20+=(y+1)*(x+1)*grayValue[y*width+x];
				}
			}
		var m02=0;
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				m02=(y+1)*(y+1)*grayValue[y*width+x];
				}
			}
		var m30=0;
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				m30=(x+1)*(x+1)*(x+1)*grayValue[y*width+x];
				}
			}
		var m03=0;
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				m03=(y+1)*(y+1)*(y+1)*grayValue[y*width+x];
				}
			}
		var m12=0;
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				m12=(x+1)*(y+1)*(y+1)*grayValue[y*width+x];
				}
			}
		var m21=0;
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				m21=(x+1)*(x+1)*(y+1)*grayValue[y*width+x];
				}
			}
		//求图像的区域重心
		var xbar,ybar;
		xbar=m10/m00;
		ybar=m01/m00;
		//求中心矩
		var eta11,eta20,eta02,eta30,eta03,eta21,eta12;
		eta11=(m11-ybar*m10)/(m00*m00);
		eta20=(m20-xbar*m10)/(m00*m00);
		eta02=(m02-ybar*m01)/(m00*m00);
		eta30=(m30-3*xbar*m20+2*xbar*xbar*m10)/(m00*m00*Math.sqrt(m00));
		eta03=(m03-3*ybar*m02+2*ybar*ybar*m01)/(m00*m00*Math.sqrt(m00));
		eta21=(m21-2*xbar*m11-ybar*m20+2*xbar*xbar*m01)/(m00*m00*Math.sqrt(m00));
		eta12=(m12-2*ybar*m11-xbar*m02+2*ybar*ybar*m10)/(m00*m00*Math.sqrt(m00));
		//HU不变矩
		var phi=[],feature_shape=[],feature_shape_1=[];
		phi[0]=eta20+eta02;
		phi[1]=(eta20-eta02)*(eta20-eta02)+(4*eta11*eta11);
		phi[2]=(eta30-3*eta12)*(eta30-3*eta12)+((3*eta21-eta03)*(3*eta21-eta03));
		phi[3]=(eta30+eta12)*(eta30+eta12)+((eta21+eta03)*(eta21+eta03));
		phi[4]=(eta30-3*eta12)*(eta30+eta12)*((eta30+eta12)*(eta30+eta12)-3*(eta21+eta03)*(eta21+eta03)+(3*eta21-eta03)*(eta21+eta03)*(3*(eta30+eta12)*(eta30+eta12)-(eta21+eta03)*(eta21+eta03)));
		phi[5]=(eta20-eta02)*((eta30+eta12)*(eta30+eta12)-(eta21+eta03)*(eta21+eta03))+4*eta11*(eta30+eta12)*(eta21+eta03);
		phi[6]=(3*eta21-eta03)*(eta30+eta12)*((eta30+eta12)*(eta30+eta12)-3*(eta21+eta03)*(eta21+eta03))+(3*eta12-eta30)*(eta21+eta03)*(3*(eta30+eta12)*(eta30+eta12)-(eta21+eta03)*(eta21+eta03));
		phi[7]=((eta20-eta02)*(eta20-eta02)+4*eta11*eta11)/((eta20+eta02)*(eta20+eta02));
		if(mode==1)
		for(var i=0;i<8;i++){
			phi[i]=Math.abs(Math.log(Math.abs(phi[i])));
			feature_shape[i]=phi[i];
			return feature_shape;
			}
		else{
			for(var i=0;i<8;i++){
				phi[i]=Math.abs(Math.log(Math.abs(phi[i])));
				feature_shape_1[i]=phi[i];
				return feature_shape_1;
				}
			}
		}
	}
// js方法
//图像平滑处理
function resetColor(src){
	if(src&&src.length>0){
		var len=src.length,out=[];
		for(var i=0,j=0;i<len;i++,j+=4){
			out[j]=src[i];
			out[j+1]=src[i];
			out[j+2]=src[i];
			out[j+3]=255;
			}
		return out;
		}
	}
</script>
<script type="text/javascript">
//hex to rgb
function hexToRGB(hex){
	var b, g, r;
      if (hex.charAt(0) === "#") {
        hex = hex.substr(1);
      }
      r = parseInt(hex.substr(0, 2), 16);
      g = parseInt(hex.substr(2, 2), 16);
      b = parseInt(hex.substr(4, 2), 16);
      return [
         r,
         g,
         b
      ];
	}
// rgb to  HSL
function rgbToHSL(r,g,b){
	  var d, h, l, max, min, s;
      if (typeof r === "object") {
        g = r.g;
        b = r.b;
        r = r.r;
      }
      r /= 255;
      g /= 255;
      b /= 255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = (function() {
          switch (max) {
            case r:
              return (g - b) / d + (g < b ? 6 : 0);
            case g:
              return (b - r) / d + 2;
            case b:
              return (r - g) / d + 4;
          }
        })();
        h /= 6;
      }
      return [
        h,
        s,
        l
      ];
	}
//hsl To  RGB
function  hslToRGB(h, s, l) {
      var b, g, p, q, r;
      if (typeof h === "object") {
        s = h.s;
        l = h.l;
        h = h.h;
      }
      if (s === 0) {
        r = g = b = l;
      } else {
        q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        p = 2 * l - q;
        r = this.hueToRGB(p, q, h + 1 / 3);
        g = this.hueToRGB(p, q, h);
        b = this.hueToRGB(p, q, h - 1 / 3);
      }
      return [
        r * 255,
        g * 255,
        b * 255
      ];
    }
//hue To RGB
function  hueToRGB(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    }
//rgb To HSV
function rgbToHSV(r, g, b) {
      var d, h, max, min, s, v;
      r /= 255;
      g /= 255;
      b /= 255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      v = max;
      d = max - min;
      s = max === 0 ? 0 : d / max;
      if (max === min) {
        h = 0;
      } else {
        h = (function() {
          switch (max) {
            case r:
              return (g - b) / d + (g < b ? 6 : 0);
            case g:
              return (b - r) / d + 2;
            case b:
              return (r - g) / d + 4;
          }
        })();
        h /= 6;
      }
      return [
        h,
        s,
        v
      ];
    }
//hsv To RGB
function hsvToRGB(h, s, v) {
      var b, f, g, i, p, q, r, t;
      i = Math.floor(h * 6);
      f = h * 6 - i;
      p = v * (1 - s);
      q = v * (1 - f * s);
      t = v * (1 - (1 - f) * s);
      switch (i % 6) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
      }
      return [
        Math.floor(r * 255),
        Math.floor(g * 255),
        Math.floor(b * 255)
      ];
    }
//rgb To  XYZ
function rgbToXYZ(r, g, b) {
      var x, y, z;
      r /= 255;
      g /= 255;
      b /= 255;
      if (r > 0.04045) {
        r = Math.pow((r + 0.055) / 1.055, 2.4);
      } else {
        r /= 12.92;
      }
      if (g > 0.04045) {
        g = Math.pow((g + 0.055) / 1.055, 2.4);
      } else {
        g /= 12.92;
      }
      if (b > 0.04045) {
        b = Math.pow((b + 0.055) / 1.055, 2.4);
      } else {
        b /= 12.92;
      }
      x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return {
        x: x * 100,
        y: y * 100,
        z: z * 100
      };
    }
//xyz To RGB
function xyzToRGB(x, y, z) {
      var b, g, r;
      x /= 100;
      y /= 100;
      z /= 100;
      r = (3.2406 * x) + (-1.5372 * y) + (-0.4986 * z);
      g = (-0.9689 * x) + (1.8758 * y) + (0.0415 * z);
      b = (0.0557 * x) + (-0.2040 * y) + (1.0570 * z);
      if (r > 0.0031308) {
        r = (1.055 * Math.pow(r, 0.4166666667)) - 0.055;
      } else {
        r *= 12.92;
      }
      if (g > 0.0031308) {
        g = (1.055 * Math.pow(g, 0.4166666667)) - 0.055;
      } else {
        g *= 12.92;
      }
      if (b > 0.0031308) {
        b = (1.055 * Math.pow(b, 0.4166666667)) - 0.055;
      } else {
        b *= 12.92;
      }
      return {
        r: r * 255,
        g: g * 255,
        b: b * 255
      };
    }
//xyz To Lab
function xyzToLab(x, y, z) {
      var a, b, l, whiteX, whiteY, whiteZ;
      if (typeof x === "object") {
        y = x.y;
        z = x.z;
        x = x.x;
      }
      whiteX = 95.047;
      whiteY = 100.0;
      whiteZ = 108.883;
      x /= whiteX;
      y /= whiteY;
      z /= whiteZ;
      if (x > 0.008856451679) {
        x = Math.pow(x, 0.3333333333);
      } else {
        x = (7.787037037 * x) + 0.1379310345;
      }
      if (y > 0.008856451679) {
        y = Math.pow(y, 0.3333333333);
      } else {
        y = (7.787037037 * y) + 0.1379310345;
      }
      if (z > 0.008856451679) {
        z = Math.pow(z, 0.3333333333);
      } else {
        z = (7.787037037 * z) + 0.1379310345;
      }
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return {
        l: l,
        a: a,
        b: b
      };
    }
//lab To XYZ
function labToXYZ(l, a, b) {
      var x, y, z;
      if (typeof l === "object") {
        a = l.a;
        b = l.b;
        l = l.l;
      }
      y = (l + 16) / 116;
      x = y + (a / 500);
      z = y - (b / 200);
      if (x > 0.2068965517) {
        x = x * x * x;
      } else {
        x = 0.1284185493 * (x - 0.1379310345);
      }
      if (y > 0.2068965517) {
        y = y * y * y;
      } else {
        y = 0.1284185493 * (y - 0.1379310345);
      }
      if (z > 0.2068965517) {
        z = z * z * z;
      } else {
        z = 0.1284185493 * (z - 0.1379310345);
      }
      return {
        x: x * 95.047,
        y: y * 100.0,
        z: z * 108.883
      };
    }
//convert1Dto2D
function convert1Dto2D(src){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,image_2d =[],grayValue=grayValues(src);
		for(var y=0;y<height;y++){
			image_2d[y]=[];
			for(var x=0;x<width;x++){
				image_2d[y][x]=grayValue[y*width+x];
				}
			}
		return image_2d;
		}
	}
//clamp
function clamp(value){
	if(value<0)
	value=0;
	else if(value>255)
	value=255
	return value;
	}
//houghTransform
/*function houghTransform(src,threshold,scale,offset){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,grayValue=grayValues(src),centerX=width/2,centerY=height/2,hough_space=500,hough_interval=Math.PI/hough_space,max=Math.max(width,height),max_length =Math.floor(Math.sqrt(2.0)*max),hough_1d=[],hough_2d=[],out=[],threshold=threshold||.5,scale=scale||1,offset=offset||0;
		for(var i=0;i<hough_space;i++){
			hough_2d[i]=[];
			for(var j=0;j<2*max_length;j++){
				hough_2d[i][j]=0;
				}
			}
		// start hough transform now....
		var image_2d=convert1Dto2D(src);
		for(var y=0;y<height;y++){
			for(var x=0;x<width;x++){
				var p=image_2d[y][x]&0xff;
				if(p==0)
				continue;
				for(var cell=0;cell<hough_space;cell++){
					max=Math.floor((col - centerX)*Math.cos(cell * hough_interval)+(row-centerY)*Math.sin(cell * hough_interval));
					max+=max_length;// start from zero, not (-max_length) 
					if(max<0||(max>=2*max_length)){
						 continue;
						}
					hough_2d[cell][max]+=1;
					}
				}
			}
		        // find the max hough value 
			var max_hough =0;
			for(var i=0;i<hough_space;i++){
				for(var j=0;j=2*max_length;j++){
					hough_1d[i+j*hough_space]=hough_2d[i][j];
					if(hough_2d[i][j]>max_hough){
						max_hough=hough_2d[i][j];
						}
					}
				}
			var hough_threshold=Math.floor(threshold * max_hough);
			for(var row=0;row<hough_space;row++){
				for(var col=0;col<2*max_length;col++){
					if(hough_2d[row][col]<hough_threshold)
					continue;
					var hough_value=hough_2d[row][col];
					var isLine=true;
					for(var i=-1;i<2;i++){
						for(var j=-1;j<2;j++){
							if(i!=0||j!=0){
								var yf=row+i;
								var xf=col+j;
								if(xf<0)continue; 
								if(xf < 2*max_length){
									if(yf<0){
										yf += hough_space; 
										}
									if(yf >= hough_space){
										 yf -= hough_space;
										}
									if(hough_2d[yf][xf] <= hough_value){
										continue;
										}
									 isLine = false;
									  break;
									}
								}
							}
						}
					if(!isLine)continue;
					var dy=Math.sin(row * hough_interval),dx=Math.cos(row * hough_interval);
					if(row<=hough_space/4||row>=3*hough_space/4){
						for(var subrow=0;subrow<height;subrow++){
							var subcol=Math.floor((col-max_length-((subrow-centerY) * dy))/dx)+centerX;
							 if ((subcol<width)&&(subcol>= 0)){
								  image_2d[subrow][subcol]=-16776961; 
								 }
							}
						}
					else{
						for(var subcol=0;subcol<width;subcol++){
							var subrow=Math.floor((col-max_length-((subcol-centerX)*dx))/dy)+centerY;
							 if((subrow<height)&&(subrow>=0)){
								 image_2d[subrow][subcol]= -16776961;
								 } 
							}
						}
					}
				}
		// convert to hough 1D and return result
		for(var i=0,len=hough_1d.length;i<len;i++){
			var value=clamp(Math.floor(scale*this.hough_1d[i]+offset));
			hough_1d[i]=(0xFF000000|value+(value<<16)+(value<<8));
			}
		  // convert to image 1D and return  
		  for(var row=0;row<height;row++){
			  for(var col=0;col<width;col++){
				  out[col+row*width]=image_2d[row][col];
				  }
			  }
		return out;
		}
	}*/
</script>
<script type="text/javascript">
function thinningProcess(src){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src),out=[];
		out=thinning(grayValue,width,height);
		//把结果扩展到[0,255]之间
		for(var i=0,len=out.length;i<len;i++){
			out[i]=out[i]*255;
			}
		return out;
		}
	}
function thinning(src,w,h){
	if(src instanceof Array)
	{
	var srcTemp=[],countNumber,width=w,height=h;
	do{
		countNumber=0;
		for(var y=1;y<h-1;y++){
			for(var x=1;x<w-1;x++){
				srcTemp.push(src[y*width+x],src[(y-1)*width+(x-1)],src[(y-1)*width+x],src[(y-1)*width+(x+1)],src[y*width+x+1],src[(y+1)*width+(x+1)],src[(y+1)*width+x],src[(y+1)*width+(x-1)],src[y*width+(x-1)]);
				if(src[y*width+x]!==1){
					if(countN(srcTemp)>=2&&countN(srcTemp)<=6){
						if(CountT(srcTemp)==1){
							if(src[y*width+(x-1)]*src[y*width+(x+1)]*src[(y+1)*width+x]==0){
								src[y*width+x]=1;
								countNumber++;
								}
							}
							else{
								if(src[(y-1)*width+x]*src[y*width+(x+1)]*src[y*width+(x-1)]==0){
									if(src[(y-1)*width+x]*src[(y+1)*width+x]*src[y*width+(x-1)]==0){
										src[y*width+x]=1;
										countNumber++;
										}
									}
								}
						}
					}
				}
			}
		}while(countNumber!=0)
		return src;
	}
}
function countN(src){
	if(src instanceof Array){
		var count=0;
		for(var i=0,len=src.length;i<len;i++){
			if(src[i]==0)
			count++;
			}
		return count;
		}
	}
function countT(src){
	if(src instanceof Array){
		var count=0;
		for(var i=0,len=src.length;i<len;i++){
			if(src[i]==1&&src[i-1]==0){
				count++;
				}
			}
		if(src[src.length-1]==0&&src[0]==1)
		count++;
		return count;
		}
	}
//细化前的处理
function before(src){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src);
	    for(var y=0;y<height;y++){
			for(var x=0;x<width;x++){
				if(grayValue[y*width+x]>0)
				grayValue[y*width+x]=1;
				else
				grayValue[y*width+x]=0;
				}
			}
		}
	}
//Hilditch细化算法
function ThinnerHilditch(src){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src),counter,k,shori,xx,nrn,kk,kk11,kk12,kk13,kk21,kk22,kk23,kk31,kk32,kk33,size=width*height,out=[],n;
		for(var y=0;y<height;y++){
			for(var x=0;x<width;x++){
				kk=y*width+x;
				if(grayValue[kk]!=0){
					grayValue[kk]=1;
					out[kk]=grayValue[kk];
					}
				}
			}
		counter=1;
		do{
			counter++;
			shori=0;
			for(var i=0;i<height;i++){
				for(var j=0;j<width;j++){
					kk=i*width+j;
					if(grayValue[kk]<0)
					grayValue[kk]=0;
					out[kk]=grayValue[kk];
					}
				}
			for(var i=1;i<height-1;i++){
				for(var j=1;j<width-1;j++){
					kk=i*width+j;
					if(grayValue[kk]!=1)
					continue;
					kk11=(i-1)*width+(j-1);
					kk12=kk11+1;
					kk13=kk12+1;
					kk21=i*width+(j-1);
					kk22=kk21+1;
					kk23=kk22+1;
					kk31=(i+1)*width+(j-1);
					kk32=kk31+1;
					kk33=kk32+1;
					if((out[kk12]&&out[kk21]&&out[kk23]&&out[kk32])!=0){
						continue;
						}
					nrn=out[kk11]+out[kk12]+out[kk13]+out[kk21]+out[kk23]+out[kk31]+out[kk32]+out[kk33];
					if(nrn<1){
						grayValue[kk22]=2;
						continue;
						}
					n[4]=grayValue[kk11];
					n[3]=grayValue[kk12];
					n[2]=grayValue[kk13];
					n[5]=grayValue[kk21];
					n[1]=grayValue[kk23];
					n[6]=grayValue[kk31];
					n[7]=grayValue[kk32];
					n[8]=grayValue[kk33];
					n[9]=n[1];
					xx=0;
					for(var k=1;k<8;k=k+2){
						if((!n[k])&&(n[k+1]||n[k+2]))
						xx++;
						}
					if(xx!=1){
						grayValue[kk22]=2;
						continue;
						}
					if(grayValue[kk12]==-1){
						grayValue[kk12]=0;
						n[3]=0;
						xx=0;
						for(var k=0;k<8;k+=2){
							if(!n[k]&&(n[k+1]||n[k+2])){
								xx++;
								}
						if(xx!=1){
							grayValue[kk12]=-1;
							continue;
							}
						grayValue[kk12]=-1;
						n[3]=-1;
							}
					if(grayValue[kk21]!=-1){
						grayValue[kk22]=-1;
						shori=1;
						continue;
						}
					grayValue[kk21]=0;
					n[5]=0;
					xx=0;
					for(var k=0;k<8;k+=2){
						if((!n[k])&&(n[k+1]||n[k+2])){
							xx++;
							}
						}
					if(xx==1){
						grayValue[kk21]=-1;
						grayValue[kk22]=-1;
						shori=1;
						}
					else
					grayValue[kk21]=-1;
						}
					}
				}
			}while(shori)
		return grayValue;
		}	
	}
// pavlidis 细化算法
function ThinnerPavlidis(src){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src),erase,n=[],bdr1,bdr2,bdr4,bdr5,c,k,b,kk,kk1,kk2,kk3;
		for(var i=1;i<height-1;i++){
			for(var j=1;j<width-1;j++){
				kk=i*width+j;
				if(grayValue[kk])
				grayValue[kk]=1;
				}
			}
		for(var i=0,kk1=0,kk2=height-1;i<width;i++,kk1+=height,kk2+=height){
			grayValue[kk1]=0;
			grayValue[kk2]=0;
			}
		for(var j=0,kk=(width-1)*height;j<height;j++,kk++){
			grayValue[j]=0;
			grayValue[kk]=0;
			}
		c=5,erase=1;
		while(erase){
			c++;
			for(var i=0;i<width-1;i++){
				for(var j=0;j<height-1;j++){
					kk=i*height+j;
					if(grayValue[kk]!=1)
					continue;
					kk1=kk-height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[3]=grayValue[kk1];
					n[2]=grayValue[kk2];
					n[1]=grayValue[kk3];
					kk1=kk-1;
					kk3=kk+1;
					n[4]=grayValue[kk1];
					n[0]=grayValue[kk3];
					kk1=kk+height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[5]=grayValue[kk1];
					n[6]=grayValue[kk2];
					n[7]=grayValue[kk3];
					bdr1=0;
					for(k=0;k<8;k++){
						if(n[k]>=1)
						bdr1|=0x80>>k;
						}
					if((bdr1&0252)==0252)
					continue;
					grayValue[kk]=2;
					b=0;
					for(k=0;k<=7;k++){
						b+=bdr1&(0x80>>k);
						}
					if(b<=1)
					grayValue[kk]=3;
					if((bdr1&0106)!=0&&(bdr1&07)!=0&&(bdr1&0210)==0)
					grayValue[kk]=3;
					else if((bdr1&&0301)!=0&&(bdr1&034)!=0&&(bdr1&042)==0)
					grayValue[kk]=3;
					else if((bdr1&0202)==0&&(bdr1&01)!=0)
					grayValue[kk]=3;
					else if((brd1&0240)==0&&(bdr1&0100)!=0)
					grayValue[kk]=3;
					else if((bdr1&050)==0&&(bdr1&020)!=0)
					grayValue[kk]=3;
					else if((bdr1&012)==0&&(bdr1&04)!=0)
					grayValue[kk]=3;	
					}
				}
			for(var i=1;i<width-1;i++){
				for(var j=1;j<height-1;j++){
					kk=i*height+j;
					if(!grayValue[kk])
					continue;
					kk1=kk-height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[3]=grayValue[kk1];
					n[2]=grayValue[kk2];
					n[1]=grayValue[kk3];
					kk1=kk-1;
					kk2=kk+1;
					n[4]=grayValue[kk1];
					n[0]=grayValue[kk3];
					kk1=kk+height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[5]=grayValue[kk1];
					n[6]=grayValue[kk2];
					n[7]=grayValue[kk3];
					bdr1=bdr2=0;
					for(var k=0;k<=7;k++){
						if(n[k]>=1)
						bdr1|=0x80>>k;
						if(n[k]>=2)
						bdr2|=0x80>>k;
						}
					if(brd1==bdr2){
						grayValue[kk]=4;
						continue;
						}
					if(grayValue[kk]!=2)
					continue;
					if((bdr2&0200)!=0(bdr1&010)==0&&((bdr1&0100)!=0&&(bdr1&001)!=0||((bdr1&0100)!=0||(bdr1&001)!=0)&&(bdr1&060)!=0&&(bdr1&06)!=0)){
						grayValue[kk]=4;
						}
					else if((bdr2&040)!=0&&(bdr1&02)==0&((bdr1&020)!=0&&(bdr1&0100)!=0||((bdr1&020)!=0||(bdr1&0100)!=0)&&(bdr1&014)!=0&&(bdr1&0201)!=0))
					grayValue[kk]=0;
					else if((bdr2&010)!=0&&(bdr1&0200)==0&&((bdr1&04)!=0&&(bdr1&020)!=0||((bdr1&04)!=0||(bdr1&020)!=0)&&(bdr1&03)!=0&&(bdr1&0140)!=0))
					grayValue[kk]=4;
					else if((bdr2&02)!=0&&(bdr1&040)==0&&((bdr1&01)!=0&&(bdr1&01)!=0&&(bdr1&04)!=0||((bdr1&01)!=0||(bdr1&04)!=0)&&(bdr1&0300)!=0&&(bdr1&030)!=0))
					grayValue[kk]=4;
					}
				}
			for(var i=1;i<width-1;i++){
				for(var j=1;j<height-1;j++){
					kk=i*height+j;
					if(grayValue[kk]!=2)
					continue;
					kk1=kk-height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[3]=grayValue[kk1];
					n[2]=grayValue[kk2];
					n[1]=grayValue[kk3];
					kk1=kk-1;
					kk2=kk+1;
					n[4]=grayValue[kk1];
					n[0]=grayValue[kk3];
					kk1=kk+height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[5]=grayValue[kk1];
					n[6]=grayValue[kk2];
					n[7]=grayValue[kk3];
					bdr4=bdr5=0;
					for(var k=0;k<=7;k++){
						if(n[k]>=4)
						bdr4|=0x80>>k;
						if(n[k]>5)
						bdr5|=0x80>>k;
						}
				if((bdr4&010)==0){
					grayValue[kk]=5;
					continue;
					}
				if((bdr4&040)==0&&bdr5==0){
					grayValue[kk]=5;
					continue;
					}
				if(grayValue[kk]==3||grayValue[kk]==4)
				grayValue[kk]=c;
					}
				}
			erase=0;
			for(var i=1;i<width-1;i++){
				for(var j=1;j<height-1;j++){
					kk=i*height+j;
					if(grayValue[kk]==2||grayValue[kk]==5){
						erase=1;
						grayValue[kk]=0;
						}
					}
				}
			}
		return grayValue;
		}
	}
//Rosenfeld细化算法
function thinnerRosenfeld(src){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src),n=[],a=[0,-1,1,0,0],b=[0,0,0,1,-1],nrnd,cond,n48,n26,n24,n46,n68,n82,n123,n345,n567,n781,k,shori,ii,jj,kk,kk1,kk2,kk3,size=width*height,out=[];
		for(var kk=0;kk<size;kk++){
			out[kk]=grayValue[kk];
			do{
				shori=0;
				for(var k=1;k<=4;k++){
					for(var i=1;i<width-1;i++){
						ii=i+a[k];
						for(var j=0;j<height-1;j++){
							kk=i*height+j;
							if(!grayValue[kk])
							continue;
							jj=j+b[k];
							kk1=ii*height+jj;
							if(grayValue[kk1])
							continue;
							kk1=kk-height-1;
							kk2=kk1+1;
							kk3=kk2+1;
							n[3]=grayValue[kk1];
							n[2]=grayValue[kk2];
							n[1]=grayValue[kk3];
							kk1=kk-1;
							kk3=kk+1;
							n[4]=grayValue[kk1];
							n[8]=grayValue[kk3];
							kk1=kk+height-1;
							kk2=kk1+1;
							kk3=kk2+1;
							n[5]=grayValue[kk1];
							n[6]=grayValue[kk2];
							n[7]=grayValue[kk3];
							nrnd=n[1]+n[2]+n[3]+n[4]+n[5]+n[6]+n[7]+n[8];
							if(nrnd<=1)
							continue;
							cond=0;
							n48=n[4]+n[8];
							n26=n[2]+n[6];
							n24=n[2]+n[4];
							n46=n[4]+n[6];
							n68=n[6]+n[8];
							n82=n[8]+n[2];
							n123=n[1]+n[2]+n[3];
							n345=n[3]+n[4]+n[5];
							n567=n[5]+n[6]+n[7];
							n781=n[7]+n[8]+n[1];
							if(n[2]==1&&n48==0&&n567>0){
								if(!cond)
								continue;
								out[kk]=0;
								shori=1;
								continue;
								}
							if(n[6]==1&&n48==0&&n123>0){
								if(!cond)
								continue;
								out[kk]=0;
								shori=1;
								continue;
								}
							if(n[8]==1&&n26==0&&n345>0){
								if(!cond)
								continue;
								out[kk]=0;
								shori=1;
								continue;
								}
							if(n[4]==1&&n26==0&&n781>0){
								if(!cond)
								continue;
								out[kk]=0;
								shori=1;
								continue;
								}
							if(n[5]==1&&n46==0){
								if(!cond)
								continue;
								out[kk]=0;
								shori=1;
								continue;
								}
							if(n[7]==1&&n68==0){
								if(!cond)
								continue;
								out[kk]=0;
								shori=1;
								continue;
								}
							if(n[1]==1&&n82==0){
								if(!cond)
								continue;
								out[kk]=0;
								shori=1;
								continue;
								}
							if(n[3]==1&&n24==0){
								if(!cond)
								continue;
								out[kk]=0;
								shori=1;
								continue;
								}
							cond=1;
							if(!cond)
							continue;
							out[kk]=0;
							shori=1;
							}
						}
					for(var i=0;i<width;i++){
						for(var j=0;j<height;j++){
							kk=i*height+j;
							grayValue[kk]=out[kk];
							}
						}
					}
				}while(shori)
			}
		return grayValue;
		}
	}
//基于索引表的细化算法
function thinnerDIBSkeleton(src){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src);
		var deletemark=[
		0,0,0,0,0,0,0,1,    0,0,1,1,0,0,1,1,
		0,0,0,0,0,0,0,0,    0,0,1,1,1,0,1,1,
		0,0,0,0,0,0,0,0,    1,0,0,0,1,0,1,1,
		0,0,0,0,0,0,0,0,    1,0,1,1,1,0,1,1,
		0,0,0,0,0,0,0,0,    0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,    1,0,0,0,1,0,1,1,
		1,0,0,0,0,0,0,0,    1,0,1,1,1,0,1,1,
		0,0,1,1,0,0,1,1,    0,0,0,1,0,0,1,1,
		0,0,0,0,0,0,0,0,    0,0,0,1,0,0,1,1,
		1,1,0,1,0,0,0,1,    0,0,0,0,0,0,0,0,
		1,1,0,1,0,0,0,1,    1,1,0,0,1,0,0,0,
		0,1,1,1,0,0,1,1,    0,0,0,1,0,0,1,1,
		0,0,0,0,0,0,0,0,    0,0,0,0,0,1,1,1,
		1,1,1,1,0,0,1,1,    1,1,0,0,1,1,0,0,
		1,1,1,1,0,0,1,1,    1,1,0,0,1,1,0,0
		],p0,p1,p2,p3,p4,p5,p6,p7,pmid,pmidtemp,sum,changed,bstart=true,lLenght=width*height,pTemp=[];
		for(var i=0,len=grayValue.length;i<len;i++){
			pTemp[i]=0;
			}
		while(bstart){
			bstart=false;
			changed=0;
			//求边缘点
			pmid=width+1;
			pmidtemp=width+1;
			for(var i=1;i<height-1;i++){
				for(var j=1;j<width-1;j++){
					if(grayValue[pmid]==0){
						pmid++;
						pmidtemp++;
						continue;
						}
					p3=grayValue[pmid+1];
					p2=grayValue[(pmid+1-width)]
					p1=grayValue[pmid-width];
					p0=grayValue[pmid-width-1];
					p7=grayValue[pmid-1];
					p6=grayValue[pmid+width-1];
					p5=grayValue[pmid+width];
					p4=grayValue[pmid+width+1];
					sum=p0&p1&p2&p3&p4&p5&p6&p7;
					if(sum==0){
						}
					}
				}
			}
		}
	}
//二值化
function binaryDigit(src,thre){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src);
		for(var y=0;x<height;x++){
			for(var x=0;x<width;x++){
				if(grayValue[y*width+x]>thre){
					grayValue[y*width+x]=1;
					}
				else
				grayValue[y*width+x]=0;
				}
			}	
		}
	}
//thinnerHilditch 细化算法
function thinnerHilditch(src,w,h){
	if(src instanceof Array){
		var width=w,height=h,n=[],counter,k,shori,xx,nrn,kk,kk11,kk12,kk13,kk21,kk22,kk23,kk31,kk32,kk33,size=width*height,out=[];
		for(var i=0;i<width;i++){
			for(var j=0;j<height;j++){
				kk=i*height+j;
				if(src[kk]!=0){
					src[kk]=1;
					out[kk]=src[kk];
					}
				}
			}
		counter=1;
		do{
			counter++;
			shori=0;
			for(var i=0;i<width;i++){
				for(var j=0;j<height;j++){
					kk=i*height+j;
					if(src[kk]<0)
					src[kk]=0;
					out[kk]=src[kk];
					}
				}
			for(var i=1;i<width-1;i++){
				for(var j=1;j<height-1;j++){
					kk=i*height+j;
					if(src[kk]!=1)
					continue;
					kk11=(i-1)*height+j-1;
					kk12=kk11+1;
					kk13=kk12+1;
					kk21=i*height+j-1;
					kk22=kk21+1;
					kk23=kk22+1;
					kk31=(i+1)*height+j-1;
					kk32=kk31+1;
					kk33=kk32+1;
					if((out[kk12]&&out[kk21]&&out[kk23]&&out[kk32])!=0){
						continue;
						}
					nrn=out[kk11]+out[kk12]+out[kk13]+out[kk21]+out[kk23]+out[kk31]+out[kk32]+out[kk33];
					if(nrn<=1){
						src[kk22]=2;
						continue;
						}
					n[4]=src[kk11];
					n[3]=src[kk12];
					n[2]=src[kk13];
					n[5]=src[kk21];
					n[1]=src[kk23];
					n[6]=src[kk31];
					n[7]=src[kk32];
					n[8]=src[kk33];
					n[9]=n[1];
					xx=0;
					for(var k=1;k<8;k+=2){
						if((!n[k])&&(n[k+1]||n[k+2]))
						xx++;
						}
					if(xx!=1){
						src[kk22]=2;
						continue;
						}
				if(src[kk12]==-1){
					src[kk12]=0;
					n[3]=0;
					xx=0;
					for(var k=1;k<8;k+=2){
						if((!n[k])&&(n[k+1]||n[k+2]))
						xx++;
						}
					if(xx!=1){
						src[kk12]=-1;
						continue;
						}
					src[kk12]=-1;
					n[3]=-1;
					}
				if(src[kk21]!=-1){
					src[kk22]=-1;
					shori=1;
					continue;
					}
				src[kk21]=0;
				n[5]=0;
				xx=0;
				for(var k=1;k<8;k+=2){
					if((!n[k])&&(n[k+1]||n[k+2])){
						xx++;
						}
					}
				if(xx=1){
					src[kk21]=-1;
					src[kk22]=-1;
					shori=1;
					}
				else
				src[kk21]=-1;
					}
				}
			}while(true)
		return src;
		}
	}
// thinnerPavlidis  细化算法
function thinnerPavlidis(src,w,h){
	if(src instanceof Array){
		var width=w,height=h,grayValue=src.slice(0),erase,n=[],bdr1,bdr2,bdr4,bdr5,c,k,b,kk,kk1,kk2,kk3;
		for(var i=1;i<height-1;i++){
			for(var j=1;j<width-1;j++){
				kk=i*width+j;
				if(grayValue[kk])
				grayValue[kk]=1;
				}
			}
		for(var i=0,kk1=0,kk2=height-1;i<width;i++,kk1+=height,kk2+=height){
			grayValue[kk1]=0;
			grayValue[kk2]=0;
			}
		for(var j=0,kk=(width-1)*height;j<height;j++,kk++){
			grayValue[j]=0;
			grayValue[kk]=0;
			}
		c=5,erase=1;
		while(erase){
			c++;
			for(var i=0;i<width-1;i++){
				for(var j=0;j<height-1;j++){
					kk=i*height+j;
					if(grayValue[kk]!=1)
					continue;
					kk1=kk-height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[3]=grayValue[kk1];
					n[2]=grayValue[kk2];
					n[1]=grayValue[kk3];
					kk1=kk-1;
					kk3=kk+1;
					n[4]=grayValue[kk1];
					n[0]=grayValue[kk3];
					kk1=kk+height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[5]=grayValue[kk1];
					n[6]=grayValue[kk2];
					n[7]=grayValue[kk3];
					bdr1=0;
					for(k=0;k<8;k++){
						if(n[k]>=1)
						bdr1|=0x80>>k;
						}
					if((bdr1&0252)==0252)
					continue;
					grayValue[kk]=2;
					b=0;
					for(k=0;k<=7;k++){
						b+=bdr1&(0x80>>k);
						}
					if(b<=1)
					grayValue[kk]=3;
					if((bdr1&0106)!=0&&(bdr1&07)!=0&&(bdr1&0210)==0)
					grayValue[kk]=3;
					else if((bdr1&&0301)!=0&&(bdr1&034)!=0&&(bdr1&042)==0)
					grayValue[kk]=3;
					else if((bdr1&0202)==0&&(bdr1&01)!=0)
					grayValue[kk]=3;
					else if((brd1&0240)==0&&(bdr1&0100)!=0)
					grayValue[kk]=3;
					else if((bdr1&050)==0&&(bdr1&020)!=0)
					grayValue[kk]=3;
					else if((bdr1&012)==0&&(bdr1&04)!=0)
					grayValue[kk]=3;	
					}
				}
			for(var i=1;i<width-1;i++){
				for(var j=1;j<height-1;j++){
					kk=i*height+j;
					if(!grayValue[kk])
					continue;
					kk1=kk-height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[3]=grayValue[kk1];
					n[2]=grayValue[kk2];
					n[1]=grayValue[kk3];
					kk1=kk-1;
					kk2=kk+1;
					n[4]=grayValue[kk1];
					n[0]=grayValue[kk3];
					kk1=kk+height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[5]=grayValue[kk1];
					n[6]=grayValue[kk2];
					n[7]=grayValue[kk3];
					bdr1=bdr2=0;
					for(var k=0;k<=7;k++){
						if(n[k]>=1)
						bdr1|=0x80>>k;
						if(n[k]>=2)
						bdr2|=0x80>>k;
						}
					if(brd1==bdr2){
						grayValue[kk]=4;
						continue;
						}
					if(grayValue[kk]!=2)
					continue;
					if((bdr2&0200)!=0(bdr1&010)==0&&((bdr1&0100)!=0&&(bdr1&001)!=0||((bdr1&0100)!=0||(bdr1&001)!=0)&&(bdr1&060)!=0&&(bdr1&06)!=0)){
						grayValue[kk]=4;
						}
					else if((bdr2&040)!=0&&(bdr1&02)==0&((bdr1&020)!=0&&(bdr1&0100)!=0||((bdr1&020)!=0||(bdr1&0100)!=0)&&(bdr1&014)!=0&&(bdr1&0201)!=0))
					grayValue[kk]=0;
					else if((bdr2&010)!=0&&(bdr1&0200)==0&&((bdr1&04)!=0&&(bdr1&020)!=0||((bdr1&04)!=0||(bdr1&020)!=0)&&(bdr1&03)!=0&&(bdr1&0140)!=0))
					grayValue[kk]=4;
					else if((bdr2&02)!=0&&(bdr1&040)==0&&((bdr1&01)!=0&&(bdr1&01)!=0&&(bdr1&04)!=0||((bdr1&01)!=0||(bdr1&04)!=0)&&(bdr1&0300)!=0&&(bdr1&030)!=0))
					grayValue[kk]=4;
					}
				}
			for(var i=1;i<width-1;i++){
				for(var j=1;j<height-1;j++){
					kk=i*height+j;
					if(grayValue[kk]!=2)
					continue;
					kk1=kk-height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[3]=grayValue[kk1];
					n[2]=grayValue[kk2];
					n[1]=grayValue[kk3];
					kk1=kk-1;
					kk2=kk+1;
					n[4]=grayValue[kk1];
					n[0]=grayValue[kk3];
					kk1=kk+height-1;
					kk2=kk1+1;
					kk3=kk2+1;
					n[5]=grayValue[kk1];
					n[6]=grayValue[kk2];
					n[7]=grayValue[kk3];
					bdr4=bdr5=0;
					for(var k=0;k<=7;k++){
						if(n[k]>=4)
						bdr4|=0x80>>k;
						if(n[k]>5)
						bdr5|=0x80>>k;
						}
				if((bdr4&010)==0){
					grayValue[kk]=5;
					continue;
					}
				if((bdr4&040)==0&&bdr5==0){
					grayValue[kk]=5;
					continue;
					}
				if(grayValue[kk]==3||grayValue[kk]==4)
				grayValue[kk]=c;
					}
				}
			erase=0;
			for(var i=1;i<width-1;i++){
				for(var j=1;j<height-1;j++){
					kk=i*height+j;
					if(grayValue[kk]==2||grayValue[kk]==5){
						erase=1;
						grayValue[kk]=0;
						}
					}
				}
			}
		return grayValue;
		}
	}
//细化算法
function thinDigit(src){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src);
		for(var x=0;x<width;x++){
			grayValue[0*width+x]=0;
			grayValue[(height-1)*width+x]=0;
			}
		for(var y=0;y<height;y++){
			grayValue[y*width+0]=0;
			grayValue[y*width+width-1]=0;
			}
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				if(grayValue[y*width+x]!=0)
				grayValue[y*width+x]=1;
				}
			}
		grayValue=thinnerHilditch(grayValue,width,height);
		return grayValue;
		}
	}
//细化算法2
function thinDigit1(src){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src);
		for(var x=0;x<width;x++){
			grayValue[0*width+x]=0;
			grayValue[(height-1)*width+x]=0;
			}
		for(var y=0;y<height;y++){
			grayValue[y*width+0]=0;
			grayValue[y*width+width-1]=0;
			}
		for(var x=0;x<width;x++){
			for(var y=0;y<height;y++){
				if(grayValue[y*width+x]!=0)
				grayValue[y*width+x]=1;
				}
			}
		grayValue=thinnerPavlidis(src,width,height);
		return grayValue;
		}
	}
//hough变换检测直线
function houghTransform(src){
	if(src&&src.data){
		var width=src.width,height=src.height,grayValue=grayValues(src),out=[];
		for(var i=0;i<height;i++){
			for(var j=0;j<width;j++){
				out[i*width+j]=0;
				}
			}
		var tempR,tempA;
		//遍历图像数据
		}
	}
//  移动图像
function moveImage(src,px,type,w,h){
	if((src&&src.data)||src instanceof Array){
		var data=src.data||src,width=src.width||w,height=src.height||h,newY=0,newX=0,newData=[],type=Math.floor(Math.abs(parseInt(type)));
		if(!type&&type!=0){
			type=0;
			}
		switch(type)
	         {
	    case 0:
		for(var y=0;y<height;y++){
			for(var x=0;x<width;x++){
				newY=y+(px>0?px:-px);
				if(newY<=height&&newY>=0){
				newData[(y*width+x)*4]=data[(newY*width+x)*4];
				newData[(y*width+x)*4+1]=data[(newY*width+x)*4+1];
				newData[(y*width+x)*4+2]=data[(newY*width+x)*4+2];
				newData[(y*width+x)*4+3]=data[(newY*width+x)*4+3];
				}
				else{
				newData[(y*width+x)*4]=255;
				newData[(y*width+x)*4+1]=255;
				newData[(y*width+x)*4+2]=255;
				newData[(y*width+x)*4+3]=255;
					}
				}
			}
		break;
		case 1:
		for(var y=0;y<height;y++){
			for(var x=0;x<width;x++){
				newX=x-(px>0?px:-px);
				if(newX<=width&&newX>=0){
					newData[(y*width+x)*4]=data[(y*width+newX)*4];
					newData[(y*width+x)*4+1]=data[(y*width+newX)*4+1];
					newData[(y*width+x)*4+2]=data[(y*width+newX)*4+2];
					newData[(y*width+x)*4+3]=data[(y*width+newX)*4+3];
					}
				else{
					newData[(y*width+x)*4]=255;
					newData[(y*width+x)*4+1]=255;
					newData[(y*width+x)*4+2]=255;
					newData[(y*width+x)*4+3]=255;
					}
				}
			}
		break;
		case 2:
		for(var y=0;y<height;y++){
			for(var x=0;x<width;x++){
				newY=y-(px>0?px:-px);
				if(newY<=height&&newY>=0){
				newData[(y*width+x)*4]=data[(newY*width+x)*4];
				newData[(y*width+x)*4+1]=data[(newY*width+x)*4+1];
				newData[(y*width+x)*4+2]=data[(newY*width+x)*4+2];
				newData[(y*width+x)*4+3]=data[(newY*width+x)*4+3];
				}
				else{
				newData[(y*width+x)*4]=255;
				newData[(y*width+x)*4+1]=255;
				newData[(y*width+x)*4+2]=255;
				newData[(y*width+x)*4+3]=255;
					}
				}
			}
		break;
		case 3:
		for(var y=0;y<height;y++){
			for(var x=0;x<width;x++){
				newX=x+(px>0?px:-px);
				if(newX<width&&newX>=0){
					newData[(y*width+x)*4]=data[(y*width+newX)*4];
					newData[(y*width+x)*4+1]=data[(y*width+newX)*4+1];
					newData[(y*width+x)*4+2]=data[(y*width+newX)*4+2];
					newData[(y*width+x)*4+3]=data[(y*width+newX)*4+3];
					}
				else{
					newData[(y*width+x)*4]=255;
					newData[(y*width+x)*4+1]=255;
					newData[(y*width+x)*4+2]=255;
					newData[(y*width+x)*4+3]=255;
					}
				}
			}
		break;
		}
	return newData;
	}
	}
</script>
<script type="text/javascript">
var atan2_p1=0.9997878412794807*(180/Math.PI),atan2_p3=-0.3258083974640975*(180/Math.PI),atan2_p5=.1555786518463281*(180/Math.PI),atan2_p7=-0.04432655554792128*(180/Math.PI);
var DBL_EPSILON=Math.pow(10,-15);
function fastAtan2(y,x){
	var ax=Math.abs(x),ay=Math.abs(y),a,c,c2;
	if(ax>=ay){
		c=ay/(ax+DBL_EPSILON);
		c2=c*c;
		a=(((atan2_p7*c2+atan2_p5)*c2+atan2_p3)*c2+atan2_p1)*c;
		}
	else{
		c=ax/(ay+DBL_EPSILON);
		c2=c*c;
		a=90-(((atan2_p7*c2 + atan2_p5)*c2 + atan2_p3)*c2 + atan2_p1)*c;
		}
	if(x<0)
	a=180-a;
	if(y<0)
	a=360-a;
	return a;
	}
function fastAtan2Arr(arr){
	if(arr&&arr.length>0){
		for(var i=0,len=arr.length;i<len;i++){
			arr[i]=fastAtan2(arr[i]);
			}
		return arr;
		}
	}

</script>
<script type="text/javascript">
function feature(){
	this.x=0;
	this.y=0;
	this.a=0;
	this.b=0;
	this.c=0;
	this.scl=0;
	this.ori=0;
	this.d=0;
	this.descr=[];
	this.type=0;
	this.category=0;
	this.fwd_match=null;//matching feature from forward image
	this.bck_match=null;//matching feature from backmward image
	this.mdl_match=null;//matching feature from model
	this.img_pt={};
	this.mdl_pt={};
	}
/* 
Draws a single Oxford-type feature 
 
@param img image on which to draw 
@param feat feature to be drawn 
@param color color in which to draw 
*/  
function draw_oxfd_feature(src,feat,color ){
	if(src&&src.data){
		if(feat){
		var m=[feat.a,feat.b,feat.b,feat.c],v=[],e=[];
			}
		}
	}
//奖惩算法  分类器设计
function jiangcheng(feature){
	var w=[];//权值
	var d=0;//迭代计算结果权矢量
	var x=[];//增一样品
	var hx=[];//判别函数
	var flag,n,i,j,k,c=0;
	for(var i=0;i<26;i++){
		w[i]=0;//权值初始化
		}
	do{
		flag=true;
		
		for(var i=0,len=feature.length;i<len;i++){
			//取已知样品
			for(var j=0;j<25;j++){
				x[j]=feature[i][j];
				}
			x[25]=1;//最后一个位置
			//计算结果权矢量
			for(var k=0;k<26;k++){
				d+=w[k]*x[k];
				}
			
			}
		}while(!flag)
	}
//  颜色分类器
function end(src){
	if(src&&src.data){
		var width=src.width,height=src.height,data=src.data,redList=[],greenList=[],yellowList=[],reaTarget=[255,0,0],greenTarget=[65,158,41],yellowTarget=[255,229,0];
		for(var y=0;y<height;y++){
			for(var x=0;x<width;x++){
				if(Math.abs(data[(y*width+x)*4]-reaTarget[0])<=20&&Math.abs(data[(y*width+x)*4+1]-reaTarget[1])<=20&&Math.abs(data[(y*width+x)*4+2]-reaTarget[2])<=20){
					//先要去找节点的父节点，找不到就新建一个
					var pp=null;
					for(var i=0,len=redList.length;i<redList.length;i++){
						var p=redList[i];
						if(Math.abs(p.x-x)*Math.abs(p.x-x)+Math.abs(p.y-y)*Math.abs(p.y-y)<=40*40*2){
							//找到了组头链表,将新的节点插入链表
							pp=p.parent;
							}
						}
					if(!pp){
						pp={}//没有找到父亲节点，新建一个父节点；
						}
					var temp={};
					temp.x=x;
					temp.y=y;
					temp.next=null;
					temp.parent=pp;//子节点指向父节点
					if(!pp.first&&!pp.last){
						pp.first=pp.last=temp;
						redList.push(pp.first);
						}
					else{
						pp.last.next=temp;
						pp.last=temp;
						}
					}
			else if(Math.abs(data[(y*width+x)*4]-greenTarget[0])<=50&&Math.abs(data[(y*width+x)*4+1]-greenTarget[1])<=50&&Math.abs(data[(y*width+x)*4+2]-greenTarget[2])<=50){
				//先要去找节点的父节点，找不到就新建一个
				var pp=null;
					for(var i=0,len=greenList.length;i<len;i++){
						var p=greenList[i];
						if(Math.abs(p.x-x)*Math.abs(p.x-x)+Math.abs(p.y-y)*Math.abs(p.y-y)<=40*40*2){
							//找到了组头链表,将新的节点插入链表
							pp=p.parent;
							}
						}
				if(!pp){
						pp={}//没有找到父亲节点，新建一个父节点；
						}
					var temp={};
					temp.x=x;
					temp.y=y;
					temp.next=null;
					temp.parent=pp;//子节点指向父节点
					if(!pp.first&&!pp.last){
						pp.first=pp.last=temp;
						greenList.push(pp.first);
						}
					else{
						pp.last.next=temp;
						pp.last=temp;
						}
				}
			else if(Math.abs(data[(y*width+x)*4]-yellowTarget[0])<=30&&Math.abs(data[(y*width+x)*4+1]-yellowTarget[1])<=30&&Math.abs(data[(y*width+x)*4+2]-yellowTarget[2])<=30){
				//先要去找节点的父节点，找不到就新建一个
				var pp=null;
					for(var i=0,len=yellowList.length;i<len;i++){
						var p=yellowList[i];
						if(Math.abs(p.x-x)*Math.abs(p.x-x)+Math.abs(p.y-y)*Math.abs(p.y-y)<=40*40*2){
							//找到了组头链表,将新的节点插入链表
							pp=p.parent;
							}
						}
				if(!pp){
						pp={}//没有找到父亲节点，新建一个父节点；
						}
					var temp={};
					temp.x=x;
					temp.y=y;
					temp.next=null;
					temp.parent=pp;//子节点指向父节点
					if(!pp.first&&!pp.last){
						pp.first=pp.last=temp;
						yellowList.push(pp.first);
						}
					else{
						pp.last.next=temp;
						pp.last=temp;
						}
				}
				}
			}
	//颜色聚集统计
	//红色聚集统计
	//alert(redList.length+", "+greenList.length+", "+yellowList.length);
	var redResult=[],greenResult=[],yellowResult=[];
	if(redList&&redList.length>0){
		for(var i=0,len=redList.length;i<len;i++){
			var firstNode=redList[i],p=firstNode.parent,num=0,sumX=0,sumY=0;
			while(firstNode){
				sumX+=firstNode.x;
				sumY+=firstNode.y;
				num++;
				firstNode=firstNode.next;
				}
			var x=sumX/num,y=sumY/num;
			if(num>=500)
			redResult.push({x:x,y:y});
			}
		}
	//绿色聚集统计
	if(greenList&&greenList.length>0){
		for(var i=0,len=greenList.length;i<len;i++){
			var firstNode=greenList[i],p=firstNode.parent,num=0,sumX=0,sumY=0;
			while(firstNode){
				sumX+=firstNode.x;
				sumY+=firstNode.y;
				num++;
				firstNode=firstNode.next;
				}
			var x=sumX/num,y=sumY/num;
			if(num>=500)
			greenResult.push({x:x,y:y});
			}
		}
	//黄色聚集统计
	if(yellowList&&yellowList.length>0){
		for(var i=0,len=yellowList.length;i<len;i++){
			var firstNode=yellowList[i],p=firstNode.parent,num=0,sumX=0,sumY=0;
			while(firstNode){
				sumX+=firstNode.x;
				sumY+=firstNode.y;
				num++;
				firstNode=firstNode.next;
				}
			var x=sumX/num,y=sumY/num;
			if(num>=500)
			yellowResult.push({x:x,y:y});
			}
		}
		return  {r:redResult,g:greenResult,y:yellowResult};
		}
	}
function resetGrayValue(src,g,w,h){
	if(src instanceof Array&&src.length>0){
		var width=w,height=h,oldGrayValue=g,grayValue=[];
		for(var y=0;y<height;y++){
			for(var x=0;x<width;x++){
			grayValue[y*width+x]=255;
				}
			}
	for(var i in src){
		grayValue[i]=0;
		}
	return grayValue;
	}
	}
</script>
<script type="text/javascript" src="lib/wPaint-master/lib/jquery.1.10.2.min.js"></script>
<script type="text/javascript" src="lib/dist/drawingboard.js"></script>
<link rel="stylesheet" type="text/css" href="lib/dist/drawingboard.css"/>
<link rel="stylesheet" type="text/css" href="lib/tooltip/darktooltip.css" />
<script type="text/javascript" src="lib/tooltip/jquery.darktooltip.js"></script>
<script type="text/javascript" src="lib/core.js"></script>
<script type="text/javascript" src="lib/jquery.facedetection.js"></script>
<script type="text/javascript" src="lib/jquery.noty.packaged.js"></script>
<script type="text/javascript" src="lib/jquery.vintage.js"></script>
<script type="text/javascript" src="lib/vintage.presets.js"></script>
</head>

<body>
<div id="zbeubeu"></div>

<style>
    #zbeubeu {
        width: 600px;
        height: 600px;
    }
</style>

<script>
//显示提示信息
    function generate(type,content){
	 var n = noty({
            text        : content,
            type        : type,
            dismissQueue: true,
            layout      : 'topCenter',
            theme       : 'defaultTheme',
			timeout     :500
        });
	}
    var myBoard = new DrawingBoard.Board('zbeubeu',{
		droppable:true,
		});
	$(".drawing-board-controls").append($("<div></div>").css({
		"height":"26px",
		"margin-left":"10px",
		"text-align":"center",
		"line-height":"26px",
		"font-size":"12px",
		"text-align":"center",
		"padding":"0px 10px 0px 10px",
		"color":"#666",
		"border":"1px solid #ccc",
		"cursor":"pointer",
		"font-family":"Times New Roman,Georgia,Serif",
		"font-weight":"700",
		"background-color":"#eee"
		}).text("处理").hover(function (e){
			$(this).css({
				"background-color":"#ddd"
				});
			},function(e){
				$(this).css({
					"background-color":"#eee"
					});
				}).click(function (e){
					var data=myBoard.getImageData(),out=[];
					var rgb=end(data);
					console.log(rgb);
					myBoard.drawCircle(rgb);
					//Effects.findedges(data.data,out,data.width,data.height);
					//Filters.Emboss(data);
					//data=laplacianB(data);
					//data=emboss(data);
					//data=resetColor(data);
					//myBoard.putImg(out);
			}));
		//生成工具栏并且隐藏
		poffset=$(myBoard.canvas).offset();
		//边缘触摸工具
		var $tools=$("<div id='tools'></div>").css({
			"position":"absolute",
			"left":(poffset.left)+"px",
			"top":poffset.top+20+"px",
			"border":"1px solid #ccc",
			"z-index":"1000",
			"background-color":"#fff"
			}).append("<div id='row1'></div>").find("#row1").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
				}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("反色").data("name","effect1").attr("data-tooltip","反色").darkTooltip().end().eq(1).text("变暗").data("name","effect2").attr("data-tooltip","变暗").darkTooltip().end().eq(2).text("曝光").data("name","effect3").attr("data-tooltip","过度曝光").darkTooltip({gravity:'west'}).css({"border-right":"none"}).end().end().end().append("<div id='row2'></div>").find("#row2").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("加亮").data("name","effect4").attr("data-tooltip","加亮").darkTooltip().end().eq(1).text("去色").attr("data-tooltip","去色").darkTooltip().data("name","effect5").end().eq(2).text("变亮").attr("data-tooltip","变亮").darkTooltip().data("name","effect6").css({"border-right":"none"}).end().end().end().append("<div id='row3'></div>").find("#row3").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("噪点").data("name","effect7").attr("data-tooltip","增加噪点").darkTooltip().end().eq(1).text("垂直翻转").attr("data-tooltip","垂直翻转").darkTooltip().data("name","effect8").end().eq(2).text("水平翻转").attr("data-tooltip","水平翻转").darkTooltip().data("name","effect9").css({"border-right":"none"}).end().end().end().append("<div id='row4'></div>").find("#row4").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("模糊").data("name","effect10").attr("data-tooltip","高斯模糊").darkTooltip().end().eq(1).text("光晕").attr("data-tooltip","光晕").darkTooltip().data("name","effect11").end().eq(2).text("锐化1").attr("data-tooltip","锐化3x3").darkTooltip().data("name","effect12").css({"border-right":"none"}).end().end().end().append("<div id='row5'></div>").find("#row5").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("锐化2").data("name","effect13").attr("data-tooltip","锐化5x5").darkTooltip().end().eq(1).text("柔化1").attr("data-tooltip","柔化3x3").darkTooltip().data("name","effect14").end().eq(2).text("柔化2").attr("data-tooltip","柔化5x5").darkTooltip().data("name","effect15").css({"border-right":"none"}).end().end().end().append("<div id='row6'></div>").find("#row6").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("边缘检测").data("name","effect16").attr("data-tooltip","边缘检测").darkTooltip().end().eq(1).text("浮雕").attr("data-tooltip","浮雕").darkTooltip().data("name","effect17").end().eq(2).text("边缘检测").attr("data-tooltip","边缘检测").darkTooltip().data("name","effect18").css({"border-right":"none"}).end().end().end().append("<div id='row7'></div>").find("#row7").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("增强边缘检测").data("name","effect19").attr("data-tooltip","增强边缘检测3x3").darkTooltip().end().eq(1).text("增强边缘检测").attr("data-tooltip","增强边缘检测5x5").darkTooltip().data("name","effect20").end().eq(2).text("拉普拉斯").attr("data-tooltip","拉普拉斯3x3").darkTooltip().data("name","effect21").css({"border-right":"none"}).end().end().end().append("<div id='row8'></div>").find("#row8").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("拉普拉斯").data("name","effect22").attr("data-tooltip","拉普拉斯5x5").darkTooltip().end().eq(1).text("色调分离").attr("data-tooltip","色调分离").darkTooltip().data("name","effect23").end().eq(2).text("去除噪点").attr("data-tooltip","去除噪点").darkTooltip().data("name","effect24").css({"border-right":"none"}).end().end().end().append("<div id='row9'></div>").find("#row9").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("马赛克").data("name","effect25").attr("data-tooltip","马赛克").darkTooltip().end().eq(1).text("颜色均衡").attr("data-tooltip","颜色均衡").darkTooltip().data("name","effect26").end().eq(2).text("腐蚀1").attr("data-tooltip","腐蚀算法1").darkTooltip().data("name","effect27").css({"border-right":"none"}).end().end().end().append("<div id='row10'></div>").find("#row10").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("腐蚀2").data("name","effect28").attr("data-tooltip","腐蚀算法2").darkTooltip().end().eq(1).text("腐蚀3").attr("data-tooltip","腐蚀算法3").darkTooltip().data("name","effect29").end().eq(2).text("腐蚀4").attr("data-tooltip","腐蚀算法4").darkTooltip().data("name","effect30").css({"border-right":"none"}).end().end().end().append("<div id='row11'></div>").find("#row11").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("膨胀").data("name","effect31").attr("data-tooltip","膨胀算法").darkTooltip().end().eq(1).text("中值滤波").attr("data-tooltip","中值滤波").darkTooltip().data("name","effect32").end().eq(2).text("人脸检测").attr("data-tooltip","人脸检测").darkTooltip().data("name","effect33").css({"border-right":"none"}).end().end().end().append("<div id='row12'></div>").find("#row12").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("向上移动").data("name","effect34").attr("data-tooltip","向上移动50像素").darkTooltip().end().eq(1).text("向右移动").attr("data-tooltip","向右移动50像素").darkTooltip().data("name","effect35").end().eq(2).text("向下移动").attr("data-tooltip","向下移动50像素").darkTooltip().data("name","effect36").css({"border-right":"none"}).end().end().end().append("<div id='row13'></div>").find("#row13").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this);
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					var name=$this.data("name");
					},function(e){
						var $this=$(this);
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}).eq(0).text("向左移动").data("name","effect37").attr("data-tooltip","向左移动50像素").darkTooltip().end().eq(1).text("向右下移动").attr("data-tooltip","向右下移动各50像素").darkTooltip().data("name","effect38").end().eq(2).text("向左上移动").attr("data-tooltip","向左上移动各50像素").darkTooltip().data("name","effect39").css({"border-right":"none"}).end().end().end().append("<div id='row14'></div>").find("#row14").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this),name=$this.data("name");
					if(name!="effect41")
					{
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					}
					},function(e){
						var $this=$(this),name=$this.data("name");
						if(name!="effect41")
						{
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}
						}).eq(0).text("混合模糊").data("name","effect40").attr("data-tooltip","混合模糊").darkTooltip().end().eq(1).text("颜色选取").attr("data-tooltip","颜色拾取器").darkTooltip().data("name","effect41").end().eq(2).text("二值化").attr("data-tooltip","彩色图像二值化").darkTooltip().data("name","effect42").css({"border-right":"none"}).end().end().end().append("<div id='row15'></div>").find("#row15").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this),name=$this.data("name");
					if(name!="effect41")
					{
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					}
					},function(e){
						var $this=$(this),name=$this.data("name");
						if(name!="effect41")
						{
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}
						}).eq(0).text("美肤").data("name","effect46").attr("data-tooltip","美肤效果").darkTooltip().end().eq(1).text("素描").attr("data-tooltip","素描效果").darkTooltip().data("name","effect47").end().eq(2).text("复古").attr("data-tooltip","复古效果").darkTooltip().data("name","effect50").css({"border-right":"none"}).end().end().end().append("<div id='row16'></div>").find("#row16").append("<span></span><span></span><span></span>").find("span").css({
				"width":"40px",
				"height":"30px",
				"font-size":"10px",
				"line-height":"30px",
				"text-align":"center",
				"overflow":"hidden",
				"color":"#666",
				"cursor":"pointer",
				"padding-right":"5px",
				"padding-left":"5px",
				"border-right":"1px solid #ccc",
				"display":"inline-block",
				"background-color":"#fff"
							}).hover(function(e){
					var $this=$(this),name=$this.data("name");
					if(name!="effect41")
					{
					$this.css({
						"color":"#fff",
						"background-color":"rgb(40,206,210)"
						});
					}
					},function(e){
						var $this=$(this),name=$this.data("name");
						if(name!="effect41")
						{
						$this.css({
							"color":"#666",
							"background-color":"#fff"
							});
						}
						}).eq(0).text("仿lomo").data("name","effect52").attr("data-tooltip","仿lomo效果").darkTooltip().end().eq(1).text("暖秋").attr("data-tooltip","暖秋效果").darkTooltip().data("name","effect56").end().eq(2).text("粗糙").attr("data-tooltip","粗糙效果").darkTooltip().data("name","effect58").css({"border-right":"none"}).end().end().end().appendTo($("body")).mouseover(function(e){
							var $this=$(this);
							$this.data("mouseover",1);
							}).mouseout(function(e){
								var $this=$(this);
								$this.data("mouseover",0);
								}).append("<div id='oc'><div>").find("#oc").css({
									"width":"20px",
									"height":"15px",
									"line-height":"15px",
									"text-align":"center",
									"position":"absolute",
									"right":"-1px",
									"top":"-17px",
									"border":"1px solid #ccc",
									"font-size":"10px",
									"color":"#666",
									"cursor":"pointer",
									"background-color":"#fff"
									}).hover(function(e){
										$(this).css({
											"color":"#fff",
						                    "background-color":"rgb(40,206,210)"
											});
										},function(e){
											$(this).css({
												"color":"#666",
							                    "background-color":"#fff"
												});
											}).data("open",1).click(function(e){
												if($(this).data("open")==1){
													 if( $tools){
														  $tools.animate({"left":-$tools.outerWidth()},100);
														  $(this).data("open",0).css({
															  "right":-20-poffset.left-2
															  }).text(">");
														 }
													}
												else if($(this).data("open")==0){
													if($tools){
														$tools.animate({
															"left":poffset.left
															},100);
														$(this).data("open",1).css({
															 "right":"-1px"
															}).text("<");
														}
													}
												}).text("<").end();
		$tools.find("span").click(function(e){
			var name=$(this).data("name");
			if(name=="effect1"){
				//这里是反色效果
				var data=myBoard.getImageData(),out=[];
					Effects.invert(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect2"){
				//这里是变暗效果
				var data=myBoard.getImageData(),out=[];
					Effects.sepia(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect3"){
				//这里是过度曝光效果
				var data=myBoard.getImageData(),out=[];
					Effects.solarize(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect4"){
				//这里是加亮效果
				var data=myBoard.getImageData(),out=[];
					Effects.brightness(data.data,out,data.width,data.height,{"contrast":.5,"brightness":.5});
					myBoard.putImg(out);
				}
			else if(name=="effect5"){
				//这里是去色效果
				var data=myBoard.getImageData(),out=[];
					Effects.desaturate(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect6"){
				//这里是变亮效果
				var data=myBoard.getImageData(),out=[];
					Effects.lighten(data.data,out,data.width,data.height,{"amount":.5});
					myBoard.putImg(out);
				}
			else if(name=="effect7"){
				//这里是加噪点效果
				var data=myBoard.getImageData(),out=[];
					Effects.noise(data.data,out,data.width,data.height,{"strength":.5,"amount":.5});
					myBoard.putImg(out);
				}
			else if(name=="effect8"){
				//这里是垂直翻转效果
				var data=myBoard.getImageData(),out=[];
					Effects.flipv(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect9"){
				//这里是水平翻转效果
				var data=myBoard.getImageData(),out=[];
					Effects.fliph(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect10"){
				//这里是模糊效果
				var data=myBoard.getImageData(),out=[];
					Effects.blur(data.data,out,data.width,data.height,{"kernelSize":5});
					myBoard.putImg(out);
				}
			else if(name=="effect11"){
				//这里是光晕效果
				var data=myBoard.getImageData(),out=[];
					Effects.glow(data.data,out,data.width,data.height,{"amount":.5},{"kernelSize":5});
					myBoard.putImg(out);
				}
			else if(name=="effect12"){
				//这里是3X3锐化效果
				var data=myBoard.getImageData(),out=[];
					Effects.sharpen3x3(data.data,out,data.width,data.height,{"strength":.5});
					myBoard.putImg(out);
				}
			else if(name=="effect13"){
					//这里是5X5锐化效果
				var data=myBoard.getImageData(),out=[];
					Effects.sharpen5x5(data.data,out,data.width,data.height,{"strength":.5});
					myBoard.putImg(out);
				}
			else if(name=="effect14"){
					//这里是3X3柔化效果
				var data=myBoard.getImageData(),out=[];
					Effects.soften3x3(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect15"){
				//这里是5X5柔化效果
				var data=myBoard.getImageData(),out=[];
					Effects.soften5x5(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect16"){
				//这里是边缘检测效果
				var data=myBoard.getImageData(),out=[];
					Effects.crossedges(data.data,out,data.width,data.height,{"strength":.5});
					myBoard.putImg(out);
				}
			else if(name=="effect17"){
				//这里是浮雕效果
				var data=myBoard.getImageData(),out=[];
					Effects.emboss(data.data,out,data.width,data.height,{"amount":.5,"angle":45});
					myBoard.putImg(out);
				}
			else if(name=="effect18"){
				//这里是边缘检测效果
				var data=myBoard.getImageData(),out=[];
					Effects.findedges(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect19"){
				//这里是增强3x3效果果
				var data=myBoard.getImageData(),out=[];
					Effects.edgeenhance3x3(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect20"){
				//这里是增强5x5效果
				var data=myBoard.getImageData(),out=[];
					Effects.edgeenhance5x5(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect21"){
				//这里是拉普拉斯3x3边缘检测效果
				var data=myBoard.getImageData(),out=[];
					Effects.laplace3x3(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect22"){
				//这里是拉普拉斯5x5边缘检测效果
				var data=myBoard.getImageData(),out=[];
					Effects.laplace5x5(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect23"){
				//这里是色调分离效果
				var data=myBoard.getImageData(),out=[];
					Effects.posterize(data.data,out,data.width,data.height,{"levels":10});
					myBoard.putImg(out);
				}
			else if(name=="effect24"){
				//这里是去除噪点效果
				var data=myBoard.getImageData(),out=[];
					Effects.removenoise(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
				else if(name=="effect25"){
				//这里是mosaic效果
				var data=myBoard.getImageData(),out=[];
					Effects.mosaic(data.data,out,data.width,data.height,{"blockSize":20});
					myBoard.putImg(out);
				}
			else if(name=="effect26"){
				//这里是颜色均衡效果
				var data=myBoard.getImageData(),out=[];
					Effects.equalize(data.data,out,data.width,data.height);
					myBoard.putImg(out);
				}
			else if(name=="effect27"){
				//这里是图像腐蚀算法1效果
				var data=myBoard.getImageData(),out=[],grayValue=grayValues(data);
					out=erode(data,0);
					out=resetGrayValue(out,grayValue,data.width,data.height);
					out=resetColor(out);
					myBoard.putImg(out);
				}
			else if(name=="effect28"){
				//这里是图像腐蚀算法2效果
			var data=myBoard.getImageData(),out=[],grayValue=grayValues(data);
					out=erode(data,1);
					out=resetGrayValue(out,grayValue,data.width,data.height);
					out=resetColor(out);
					myBoard.putImg(out);
				}
			else if(name=="effect29"){
				//这里是图像腐蚀算法3效果
				var data=myBoard.getImageData(),out=[],grayValue=grayValues(data);
					out=erode(data,2);
					out=resetGrayValue(out,grayValue,data.width,data.height);
					out=resetColor(out);
					myBoard.putImg(out);
				}
			else if(name=="effect30"){
				//这里是图像腐蚀算法4效果
				var data=myBoard.getImageData(),out=[],grayValue=grayValues(data);
					out=erode(data,3);
					out=resetGrayValue(out,grayValue,data.width,data.height);
					out=resetColor(out);
					myBoard.putImg(out);
				}
			else if(name=="effect31"){
				//这里是图像膨胀算法1效果
				var data=myBoard.getImageData(),out=[],grayValue=grayValues(data);
					out=erode1(data,0);
					out=resetGrayValue(out,grayValue,data.width,data.height);
					out=resetColor(out);
					myBoard.putImg(out);
				}
			else  if(name=="effect32"){
				//中值滤波
				var data=myBoard.getImageData(),out;
					out=cv.imread(data);
					out=cv.medianBlur(out,3,3,0x05);
					myBoard.putImg(out);
				}
			else if(name=="effect33"){
				$(myBoard.canvas).faceDetection({
                complete: function (faces) {
                myBoard.drawFace(faces);
        }
    });
				}
			else if(name=="effect34"){
				//向上移动50像素
				var data=myBoard.getImageData(),out;
				window.currentOffsetY-=50;
				if(window.currentOffsetY>=0)
				out=moveImage(data,50,0);
				else{
					out=moveImage(data,50+window.currentOffsetY,0);
					window.currentOffsetY=0;
					}
				myBoard.putImg(out);
				}
			else if(name=="effect35"){
				//向右移动50像素
				var data=myBoard.getImageData(),out;
				window.currentOffsetX+=50
				if(window.currentOffsetX+window.currentWidth<=myBoard.ctx.canvas.width)
				out=moveImage(data,50,1);
				else{
					out=moveImage(data,50-(window.currentOffsetX+window.currentWidth-myBoard.ctx.canvas.width),1);
					window.currentOffsetX=myBoard.ctx.canvas.width-window.currentWidth;
					}
				myBoard.putImg(out);
				}
			else if(name=="effect36"){
				//向下移动50像素
				var data=myBoard.getImageData(),out;
				window.currentOffsetY+=50;
				if(window.currentOffsetY+window.currentHeight<=myBoard.ctx.canvas.height)
				out=moveImage(data,50,2);
				else{
					out=moveImage(data,50-(window.currentOffsetY+window.currentHeight-myBoard.ctx.canvas.height),2);
					window.currentOffsetY=myBoard.ctx.canvas.height-window.currentHeight;
					}
				myBoard.putImg(out);
				}
			else if(name=="effect37"){
				//向左移动50像素
				var data=myBoard.getImageData(),out;
				window.currentOffsetX-=50;
				if(window.currentOffsetX>=0)
				out=moveImage(data,50,3);
				else{
					out=moveImage(data,50+window.currentOffsetX,3);
					window.currentOffsetX=0;
					}
				myBoard.putImg(out);
				}
			else if(name=="effect38"){
				//向右下各移动50像素
				var data=myBoard.getImageData(),out,width=data.width,height=data.height;
				window.currentOffsetX+=50
				if(window.currentOffsetX+window.currentWidth<=myBoard.ctx.canvas.width)
				out=moveImage(data,50,1);
				else{
					out=moveImage(data,50-(window.currentOffsetX+window.currentWidth-myBoard.ctx.canvas.width),1);
					window.currentOffsetX=myBoard.ctx.canvas.width-window.currentWidth;
					}
				window.currentOffsetY+=50;
				if(window.currentOffsetY+window.currentHeight<=myBoard.ctx.canvas.height)
				out=moveImage(out,50,2,width,height);
				else{
					out=moveImage(out,50-(window.currentOffsetY+window.currentHeight-myBoard.ctx.canvas.height),2,width,height);
					window.currentOffsetY=myBoard.ctx.canvas.height-window.currentHeight;
					}
				myBoard.putImg(out);
				}
			else if(name=="effect39"){
				//向左上移动50像素
				var data=myBoard.getImageData(),out,width=data.width,height=data.height;
				window.currentOffsetX-=50;
				if(window.currentOffsetX>=0)
				{
				   out=moveImage(data,50,3);
				}
				else{
					out=moveImage(data,50+window.currentOffsetX,3);
					window.currentOffsetX=0;
					};
				window.currentOffsetY-=50;
				if(window.currentOffsetY>=0)
				out=moveImage(out,50,0,width,height);
				else{
					out=moveImage(out,50+window.currentOffsetY,0,width,height);
					window.currentOffsetY=0;
					}
				myBoard.putImg(out);
				}
			else if(name=="effect40"){
				var data=myBoard.getImageData(),out=[];
					Effects.noise(data.data,out,data.width,data.height,{"strength":.5,"amount":.5});
					Effects.blur(out,out,data.width,data.height,{"kernelSize":5})
					myBoard.putImg(out);
				}
			else if(name=="effect41"){
				var that=$(this),colorData,targetData=[];
				if($(this).data("selected")==true){
					$(this).css({"background":"#fff","color":"#666"})
					}
				$(this).data("selected",false);
				$(myBoard.ctx.canvas).bind("click",function(e){
					var offset=$(this).offset(),canvasX=e.pageX-offset.left,canvasY=e.pageY-offset.top;
					colorData=this.getContext("2d").getImageData(canvasX,canvasY,1,1).data;
					that.data("selected",true).css({"background-color":"rgb("+colorData[0]+","+colorData[1]+","+colorData[2]+")"});
					$(this).unbind("click");
					//加大前景色和背景色的对比度
					for(var i=0,len=colorData.length;i<len;i++){
						targetData[i]=(colorData[i]+180)>255?((colorData[i]+180)-255):(colorData[i]+180);
						}
					that.css({"color":"rgb("+targetData[0]+","+targetData[1]+","+targetData[2]+")"});
					});
				}
			else if(name=="effect42"){
				var spans=$("#tools").find("span"),flag=false,targetSpan;
				for(var i=0,len=spans.length;i<len;i++){
					var span=spans.eq(i);
					if(span.data("name")=="effect41"&&span.data("selected")==true){
						flag=true;
						targetSpan=span;
						break;
						}
					}
				if(flag===true){
					//彩色图像二值化
					var src=myBoard.getImageData();
					if(src&&src.data){
						var data=src.data,newData=[],width=src.width,height=src.height,rgbStringLen=(targetSpan.css("background-color")).length,colorBase=targetSpan.css("background-color").indexOf("rgb")>=0?targetSpan.css("background-color").substring(4,rgbStringLen-1).split(","):hexToRGB((targetSpan.css("background-color")));
						for(var i=0,len=colorBase.length;i<len;i++){
							colorBase[i]=parseInt(colorBase[i]);
							}
						for(var y=0;y<height;y++){
							for(var x=0;x<width;x++){
								if(Math.abs(data[(y*width+x)*4]-colorBase[0])<40&&Math.abs(data[(y*width+x)*4+1]-colorBase[1])<40&&Math.abs(data[(y*width+x)*4+2]-colorBase[2])<40){
									//颜色相似，显示黑色
									newData[(y*width+x)*4]=0;
									newData[(y*width+x)*4+1]=0;
									newData[(y*width+x)*4+2]=0;
									newData[(y*width+x)*4+3]=255;
									}
								else{
									//颜色差距大，显示为白色
									newData[(y*width+x)*4]=255;
									newData[(y*width+x)*4+1]=255;
									newData[(y*width+x)*4+2]=255;
									newData[(y*width+x)*4+3]=255;
									}
								}
							}
						}
					myBoard.putImg(newData);
					}
				else{
					generate("error","未选择颜色！");
					}
				}
			else if(name=="effect43"){
				var data=myBoard.getImageData(),src=data.data,width=data.width,height=data.height;
				for(var i=(width*height);i>=0;--i){
					idx = i << 2;
					src[idx ]=vintagePresets.vintage.curves.r[src[idx]];
					src[idx+1 ]=vintagePresets.vintage.curves.g[src[idx+1]];
					src[idx+2 ]=vintagePresets.vintage.curves.b[src[idx+2]];
					src[idx ]=255-((255-src[idx ])*(255-vintagePresets.vintage.screen.r*vintagePresets.vintage.screen.a)/255);
					src[idx+1]=255-((255-src[idx+1])*(255-vintagePresets.vintage.screen.r*vintagePresets.vintage.screen.a)/255);
					src[idx+2]=255-((255-src[idx+2])*(255-vintagePresets.vintage.screen.r*vintagePresets.vintage.screen.a)/255);
					for(var j=2;j>=0;--j){
						src[idx+j]=~~(src[idx+j]>255?255:src[idx+j]<0?0:src[idx+j]);
						}
					}
				myBoard.putImg(src);
				}
			else if(name=="effect44"){
				var data=myBoard.getImageData(),src=data.data,width=data.width,height=data.height;
				for(var i=(width*height);i>=0;--i){
					idx = i << 2;
					src[idx ]=vintagePresets.sepia.curves.r[src[idx]];
					src[idx+1 ]=vintagePresets.sepia.curves.g[src[idx+1]];
					src[idx+2 ]=vintagePresets.sepia.curves.b[src[idx+2]];
					var r=src[idx],g=src[idx+1],b=src[idx+2];
					src[idx]=r * 0.393 + g * 0.769 + b * 0.189;
					src[idx+1]=r * 0.349 + g * 0.686 + b * 0.168;
					src[idx+2]=r * 0.272 + g * 0.534 + b * 0.131;
					for(var j=2;j>=0;--j){
						src[idx+j]=~~(src[idx+j]>255?255:src[idx+j]<0?0:src[idx+j]);
						}
					}
				myBoard.putImg(src);
				}
			else if(name=="effect45"){
				var data=myBoard.getImageData(),src=data.data,width=data.width,height=data.height;
				for(var i=(width*height);i>=0;--i){
					idx = i << 2;
					src[idx ]=vintagePresets.reddish.curves.r[src[idx]];
					src[idx+1 ]=vintagePresets.reddish.curves.g[src[idx+1]];
					src[idx+2 ]=vintagePresets.reddish.curves.b[src[idx+2]];
					src[idx ]=255-((255-src[idx ])*(255-vintagePresets.reddish.screen.r*vintagePresets.reddish.screen.a)/255);
					src[idx+1]=255-((255-src[idx+1])*(255-vintagePresets.reddish.screen.r*vintagePresets.reddish.screen.a)/255);
					src[idx+2]=255-((255-src[idx+2])*(255-vintagePresets.reddish.screen.r*vintagePresets.reddish.screen.a)/255);
					for(var j=2;j>=0;--j){
						src[idx+j]=~~(src[idx+j]>255?255:src[idx+j]<0?0:src[idx+j]);
						}
					}
				myBoard.putImg(src);
				}
			else if(name=="effect46"){
				//美肤
				var data=myBoard.getImageData(),olddata=myBoard.getImageData();
				data=newFilter.gaussBlur(data,10);
				data=newFilter.add(olddata,data,"滤色");
				data=newFilter.brightness(data,[-10,5]);
				myBoard.putImg(data.data);
				}
			else if(name=="effect47"){
				//素描
				var data=myBoard.getImageData(),olddata=myBoard.getImageData();
				data=newFilter.toReverse(data);
				data=newFilter.gaussBlur(data,8);
				data=newFilter.add(olddata,data,"颜色减淡");
				data=newFilter.toGray(data);
				data=newFilter.sharp(data,[1]);
				myBoard.putImg(data.data);
				}
			else if(name=="effect48"){
				//自然增强
				var data=myBoard.getImageData();
				data=newFilter.curve(data,[0,190,255]);
				data=newFilter.curve(data,[0,229,255]);
				myBoard.putImg(data.data);
				}
			else if(name=="effect49"){
				//柔化
				var data=myBoard.getImageData(),olddata=myBoard.getImageData();
				data=newFilter.gaussBlur(data,6);
				data=newFilter.add(olddata,data,"变暗");
				myBoard.putImg(data.data);
				}
			else if(name=="effect50"){
				//复古
				var data=myBoard.getImageData(),olddata=myBoard.getImageData();
				data=newFilter.toGray(data);
				olddata=newFilter.noise(olddata,[0]);
				olddata=newFilter.gaussBlur(olddata,4);
				olddata=newFilter.setHSI(olddata,[32,19,0,true]);
				data=newFilter.add(data,olddata,"叠加");
				myBoard.putImg(data.data);
				}
			else if(name=="effect51"){
				//黑白
				var data=myBoard.getImageData();
				data=newFilter.toGray(data);
				myBoard.putImg(data.data);
				}
			else if(name=="effect52"){
				//仿lomo
				var data=myBoard.getImageData(),olddata=myBoard.getImageData();
				data=newFilter.add(data,data,"滤色");
				data=newFilter.add(data,olddata,"柔光");
				olddata=newFilter.toReverse(olddata);
				data=newFilter.add(data,olddata,"正常","20%","B");
				data=newFilter.darkCorner(data,[6,200]);
				myBoard.putImg(data.data);
				}
			else if(name=="effect53"){
				//
				var data=myBoard.getImageData(),olddata=myBoard.getImageData();
				data=newFilter.curve(data,[0,50,255]);
				data=newFilter.curve(data,[0,234,255]);
				data=newFilter.add(olddata,data,"柔光");
				myBoard.putImg(data.data);
				}
			else if(name=="effect54"){
				//高对比
				var data=myBoard.getImageData();
				data=newFilter.toGray(data);
				data=newFilter.curve(data,[0,61,69,212,255]);
				data=newFilter.curve(data,[0,111,176,237,255]);
				myBoard.putImg(data.data);
				}
			else if(name=="effect55"){
				var data=myBoard.getImageData();
				data=newFilter.toGray(data);
				data=newFilter.curve(data,[0,60,142,194,255]);
				data=newFilter.curve(data,[0,194,240,247,255]);
				myBoard.putImg(data.data);
				}
			else if(name=="effect56"){
				//warmAutumn
				var data=myBoard.getImageData(),olddata=myBoard.getImageData();
				data=newFilter.setHSI(data,[32,19,0,true]);
				//data=newFilter.brightness(data,[-10,5]);
				data=newFilter.darkCorner(data,[6, 150]);
				data=newFilter.add(olddata,data,"叠加");
				myBoard.putImg(data.data);
				}
			else if(name=="effect57"){
				//木雕的效果
				var data=myBoard.getImageData(),olddata=myBoard.getImageData();
				data=newFilter.mosaic(data,[0]);
				data=newFilter.applyMatrix(data);
				data=newFilter.embossment(data);
				data=newFilter.add(olddata,data,"线性光");
				myBoard.putImg(data.data);
				}
			else if(name=="effect58"){
				//粗糙
				var data=myBoard.getImageData(),olddata=myBoard.getImageData();
				data=newFilter.dotted(data,[0]);
				data=newFilter.toReverse(data);
				data=newFilter.embossment(data);
				data=newFilter.add(olddata,data,"叠加");
				myBoard.putImg(data.data);
				}
			});
		/*$(myBoard.canvas).mousemove(function(e){
			var $canvas=$(myBoard.canvas),offset=$canvas.offset(),width=$(myBoard.canvas).width(),height=$(myBoard.canvas).height();
			//判断鼠标的位置是否在指定的区域内
			console.log(e.pageX+", "+e.pageY+"  "+offset.left+" "+(parseInt(offset.left)+40)+" "+offset.top+" "+(parseInt(offset.top)+height));
			if(e.pageX>=offset.left&&e.pageX<=offset.left+40&&e.pageY>=offset.top&&e.pageY<=offset.top+height){
				//鼠标放在了指定的位置
				if($("#tools")){
					console.log("yes");
					$("#tools").animate({
						"left":offset.left
						},100)
					}
				}
			else if($("#tools").data("mouseover")==1){
				if($("#tools")){
					$("#tools").animate({
						"left":offset.left
						},100)
					}
				}
			else{
				if($("#tools")&&$("#tools").data("mouseover")==0){
					console.log("no");
					$("#tools").animate({
						"left":(offset.left-200)
						},100);
					}
				}
			});*/
</script>
</body>
</html>
